<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="MetricGraph">
<title>MetricGraph: Random Fields on Metric Graphs • MetricGraph</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Roboto_Slab-0.4.8/font.css" rel="stylesheet">
<!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="MetricGraph: Random Fields on Metric Graphs">
<meta property="og:description" content="MetricGraph">
<meta property="og:image" content="https://davidbolin.github.io/MetricGraph/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">MetricGraph</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item">
  <a class="nav-link" href="../articles/MetricGraph.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Functions</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-vignettes">Vignettes</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-vignettes">
    <a class="dropdown-item" href="../articles/metric_graph.html">Working with metric graphs</a>
    <a class="dropdown-item" href="../articles/random_fields.html">Gaussian random fields on metric graphs</a>
    <a class="dropdown-item" href="../articles/metric_graph_data.html">Data manipulation on metric graphs</a>
    <a class="dropdown-item" href="../articles/inlabru_interface.html">inlabru interface of Whittle--Matérn fields</a>
    <a class="dropdown-item" href="../articles/inla_interface.html">INLA interface of Whittle--Matérn fields</a>
    <a class="dropdown-item" href="../articles/fem_models.html">Whittle--Matérn fields with general smoothness</a>
    <a class="dropdown-item" href="../articles/pointprocess.html">Log-Gaussian Cox processes on metric graphs</a>
    <a class="dropdown-item" href="../articles/comparison.html">Comparison of different models using real data</a>
    <a class="dropdown-item" href="../articles/isotropic_noneuclidean.html">On isotropic covariances on metric graphs with non-Euclidean edges</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/davidbolin/MetricGraph/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
<li class="nav-item">
  <a class="external-link nav-link" href="https://twitter.com/jdavidbolin" aria-label="Twitter">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>MetricGraph: Random Fields on Metric Graphs</h1>
                        <h4 data-toc-skip class="author">David Bolin,
Alexandre B. Simas, and Jonas Wallin</h4>
            
            <h4 data-toc-skip class="date">Created: 2022-11-26. Last
modified: 2024-02-26.</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/davidbolin/MetricGraph/blob/HEAD/vignettes/MetricGraph.Rmd" class="external-link"><code>vignettes/MetricGraph.Rmd</code></a></small>
      <div class="d-none name"><code>MetricGraph.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>There has lately been much interest in statistical modeling of data
on compact metric graphs such as street or river networks based on
Gaussian random fields.</p>
<p>The <code>R</code> package <code>MetricGraph</code> contains
functions for working with data and random fields on compact metric
graphs. The main functionality is contained in the
<code>metric_graph</code> class, which is used for specifying metric
graphs, adding data to them, visualization, and other basic functions
that are needed for working with data and random fields on metric
graphs. The package also implements three types of Gaussian processes on
metric graphs: The Whittle–Matérn fields introduced by <a href="https://arxiv.org/abs/2205.06163" class="external-link"><span class="citation">Bolin,
Simas, and Wallin (2024)</span></a> and <a href="https://arxiv.org/abs/2304.10372" class="external-link"><span class="citation">Bolin,
Simas, and Wallin (2023)</span></a>, Gaussian processes with isotropic
covariance functions <a href="https://projecteuclid.org/journals/annals-of-statistics/volume-48/issue-4/Isotropic-covariance-functions-on-graphs-and-their-edges/10.1214/19-AOS1896.full" class="external-link"><span class="citation">Anderes, Møller, and Rasmussen (2020)</span></a>, and
Gaussian models based on the graph Laplacian <a href="http://proceedings.mlr.press/v130/borovitskiy21a/borovitskiy21a.pdf" class="external-link"><span class="citation">Borovitskiy et al. (2021)</span></a>.</p>
<p>Basic statistical tasks such as likelihood evaluation and prediction
is implemented for these three types of models in
<code>MetricGraph</code>. Further, the package also contains interfaces
to <code>R-INLA</code> <a href="https://www.jstatsoft.org/article/view/v063i19" class="external-link"><span class="citation">Lindgren and Rue (2015)</span></a>, package available
from <a href="https://www.r-inla.org/" class="external-link">http://R-INLA. org/download/</a>
and <code>inlabru</code> <a href="https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.13168" class="external-link"><span class="citation">Bachl et al. (2019)</span></a> that facilitates using
those packages for full Bayesian inference of general Latent Gaussian
Models (LGMs) that includes Whittle–Matérn fields on metric graphs.</p>
<!-- The package is available to install from the Comprehensive R Archive
Network (CRAN) at \url{https://CRAN.R-project.org/package=MetricGraph}. A development version of the package is available via the repository [https://github.com/davidbolin/MetricGraph](https://github.com/davidbolin/MetricGraph). The development version is updated more frequently, and can easily be installed directly in R as described on the repository homepage.  -->
<p>The package is available to install via the repository <a href="https://github.com/davidbolin/MetricGraph" class="external-link">https://github.com/davidbolin/MetricGraph</a>.</p>
<p>The following sections describe the main functionality of the package
and summarizes some of the required theory. Section 2 introduces metric
graphs and the <code>metric_graph</code> class, Section 3 shows how to
work with random fields on metric graphs, and Section 4 introduces the
<code>inlabru</code> interface of the package through an application to
real data. For a complete introduction to the functionality of the
package, we refer to the Vignettes available on the package homepage <a href="https://davidbolin.github.io/MetricGraph/">https://davidbolin.github.io/MetricGraph/</a>.
In particular, that contains an introduction to the <code>INLA</code>
interface, the implementation of Whittle–Matérn fields with general
smoothness, and further details and examples for all methods in the
package.</p>
</div>
<div class="section level2">
<h2 id="the-metric_graph-class">The <code>metric_graph</code> class<a class="anchor" aria-label="anchor" href="#the-metric_graph-class"></a>
</h2>
<p>A compact metric graph <span class="math inline">\(\Gamma\)</span>
consists of a set of finitely many vertices <span class="math inline">\(\mathcal{V}=\{v_i\}\)</span> and a finite set
<span class="math inline">\(\mathcal{E}=\{e_j\}\)</span> of edges
connecting the vertices. Each edge <span class="math inline">\(e\)</span> is defined by a pair of vertices <span class="math inline">\((v_i,v_k)\)</span> and a finite length <span class="math inline">\(l_e \in (0,\infty)\)</span>. An edge in the graph
is a curve parametrized by arc-length, and a location <span class="math inline">\(s\in \Gamma\)</span> is a position on an edge, and
can thus be represented as a touple <span class="math inline">\((e,t)\)</span> where <span class="math inline">\(t\in[0,l_e]\)</span>.</p>
<div class="section level3">
<h3 id="basic-constructions">Basic constructions<a class="anchor" aria-label="anchor" href="#basic-constructions"></a>
</h3>
<p>A metric graph is represented in the <code>MetricGraph</code> package
through the class <code>metric_graph</code>. An object of this class can
be constructed in two ways. The first is to specify the vertex matrix
<code>V</code> and the edge matrix <code>E</code>, and it is then
assumed that all edges are straight lines. The second, more flexible,
option is to specify the object from a <code>SpatialLines</code> object
using the <code>sp</code> package <span class="citation">(Bivand,
Pebesma, and Gomez-Rubio 2013)</span>.</p>
<p>To illustrate this, we use the <code>osmdata</code> package to
download data from OpenStreetMap. In the following code, we extract the
streets on the campus of King Abdullah University of Science and
Technology (KAUST) as a <code>SpatialLines</code> object:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">call</span> <span class="op">&lt;-</span> <span class="fu">opq</span><span class="op">(</span>bbox <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">39.0884</span>, <span class="fl">22.33</span>, <span class="fl">39.115</span>, <span class="fl">22.3056</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">call</span> <span class="op">&lt;-</span> <span class="fu">add_osm_feature</span><span class="op">(</span><span class="va">call</span>, key <span class="op">=</span> <span class="st">"highway"</span>,value<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"motorway"</span>,</span>
<span>                                                      <span class="st">"primary"</span>,<span class="st">"secondary"</span>,</span>
<span>                                                      <span class="st">"tertiary"</span>,</span>
<span>                                                      <span class="st">"residential"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu">osmdata_sp</span><span class="op">(</span><span class="va">call</span><span class="op">)</span></span>
<span><span class="va">lines</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sp/man/SpatialLines.html" class="external-link">SpatialLines</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">osm_lines</span><span class="op">@</span><span class="va">lines</span><span class="op">)</span></span></code></pre></div>
<p>We can now create the metric graph as follows. In the command we set
the argument <code>longlat = TRUE</code> since the coordinates of the
vertices are given in Longitude and Latitude.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="va"><a href="../reference/metric_graph.html">metric_graph</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">lines</span>, longlat <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>vertex_size <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-2-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can note the warning that the graph is not connected, so let us
create a <code>graph_components</code> object that contains all
connected components as graphs and then extract the largest connected
component to work with</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graphs</span> <span class="op">&lt;-</span> <span class="va"><a href="../reference/graph_components.html">graph_components</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span>edges <span class="op">=</span> <span class="va">lines</span>, longlat <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="va">graphs</span><span class="op">$</span><span class="fu">get_largest</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-3-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The <code>graph</code> object now contains all important features of
the graph, such as the vertex matrix <code>graph$V</code>, the number of
vertices <code>graph$nV</code>, the edge matrix <code>graph$E</code>,
the number of edges <code>graph$nE</code>, and the vector of all edge
lengths <code>graph$get_edge_lengths()</code> given in the unit km
(since we specified <code>longlat = TRUE</code> in the construction).
Thus, we can obtain the range of the edge lengths in the unit m as:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="fu">get_edge_lengths</span><span class="op">(</span>unit<span class="op">=</span><span class="st">"m"</span><span class="op">)</span><span class="op">)</span> </span></code></pre></div>
<pre><code><span><span class="co">## Units: [m]</span></span>
<span><span class="co">## [1]    5.650044 2141.415006</span></span></code></pre>
<p>We will also remove the vertices of degree 2 by using the
<code>prune_vertices()</code> method:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">prune_vertices</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-5-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="understanding-coordinates-on-graphs">Understanding coordinates on graphs<a class="anchor" aria-label="anchor" href="#understanding-coordinates-on-graphs"></a>
</h3>
<p>The locations of the vertices are specified in Euclidean coordinates.
However, when specifying a position on the graph, it is not practical to
work with Euclidean coordinates since not all locations in Euclidean
space are locations on the graph. It is instead better to specify a
location on the graph by the touple <span class="math inline">\((i,
t)\)</span>, where <span class="math inline">\(i\)</span> denotes the
number of the edge and <span class="math inline">\(t\)</span> is the
location on the edge. The location <span class="math inline">\(t\)</span> can either be specified as the distance
from the start of the edge (and then takes values between 0 and the
length of the edge) or as the normalized distance from the start of the
edge (and then takes values between 0 and 1). The function
<code>coordinates</code> can be used to convert between coordinates in
Euclidean space and locations on the graph. For example the location at
normalized distance 0.2 from the start of the second edge is:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">0.2</span><span class="op">)</span>, <span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          [,1]     [,2]</span></span>
<span><span class="co">## [1,] 39.11751 22.31934</span></span></code></pre>
<p>The function can also be used to find the closest location on the
graph for a location in Euclidean space:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>XY <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">39.117</span>, <span class="fl">22.319</span><span class="op">)</span>, <span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1]      [,2]</span></span>
<span><span class="co">## [1,]    2 0.2517662</span></span></code></pre>
<p>In this case, the <code>normalized</code> argument decides whether
the returned value should be given in normalized distance or not.</p>
</div>
<div class="section level3">
<h3 id="adding-data-to-the-graph">Adding data to the graph<a class="anchor" aria-label="anchor" href="#adding-data-to-the-graph"></a>
</h3>
<p>Given that we have constructed the metric graph, we can now add data
to it. For further details on data manipulation on metric graphs, see <a href="metric_graph_data.html">Data manipulation on metric graphs</a>. As
an example, let us sample some locations on edges at random and add data
to them in the graph:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span><span class="op">)</span>,</span>
<span>                   distance_on_edge <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span>,</span>
<span>                   y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"y"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-8-1.png" width="700" style="display: block; margin: auto;"></p>
<p>One should note here that one needs to specify
<code>normalized = TRUE</code> in the function to specify that the
locations are in normalized distance on the edges. If this command is
not set, the distances are interpreted as not being normalized. The
<code>add_observations()</code> function accepts multiple types of
inputs. One scenario that can be common in applications is to have the
data as <code>SpatialPoints</code> objects, and one can then add the
observations as a <code>SpatialPointsDataFrame</code>. To illustrate
this, let us again sample some locations at random on the graph, then
use the function <code>coordinates</code> to transform those to
Longitude Latitude coordinates, which we then use to create a
<code>SpatialPointsDataFrame</code> object which we add to the
graph:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">obs.lonlat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">obs.loc</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">obs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span></span>
<span><span class="va">points</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sp/man/SpatialPoints.html" class="external-link">SpatialPointsDataFrame</a></span><span class="op">(</span>coords <span class="op">=</span> <span class="va">obs.lonlat</span>,</span>
<span>                                 data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span><span class="va">points</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<pre><code><span><span class="co">## Converting data to PtE</span></span></code></pre>
<pre><code><span><span class="co">## This step may take long. If this step is taking too long consider pruning the vertices to possibly obtain some speed up.</span></span></code></pre>
<pre><code><span><span class="co">## [1] y        .coord_x .coord_y</span></span>
<span><span class="co">## &lt;0 rows&gt; (or 0-length row.names)</span></span></code></pre>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"y"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-9-1.png" width="700" style="display: block; margin: auto;"></p>
<p>If we want to replace the data in the object, we can use
<code>clear_observations()</code> to remove all current data.</p>
</div>
<div class="section level3">
<h3 id="working-with-functions-on-metric-graphs">Working with functions on metric graphs<a class="anchor" aria-label="anchor" href="#working-with-functions-on-metric-graphs"></a>
</h3>
<p>When working with data on metric graphs, one often wants to display
functions on the graph. The best way to visualize functions on the graph
is to evaluate them on a fine mesh over the graph and then use
<code>plot_function</code>. To illustrate this procedure, let us
construct a mesh on the graph:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">100</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>mesh<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-10-1.png" width="700" style="display: block; margin: auto;"></p>
<p>In the command <code>build_mesh</code>, the argument <code>h</code>
decides the largest spacing between nodes in the mesh. Above we chose
that as 100m which is a bit coarse. So let us reduce the value of
<code>h</code> to 10m and rebuild the mesh:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">10</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span></code></pre></div>
<p>Suppose now that we want to display the function <span class="math inline">\(f(s) = \text{Longitude}(s) -
\text{Latitude}(s)\)</span> on this graph. We then first evaluate it on
the vertices of the mesh and then use the function
<code>plot_function</code> to display it:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lon</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">lat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">f</span> <span class="op">&lt;-</span> <span class="va">lon</span> <span class="op">-</span> <span class="va">lat</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">f</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-12-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Alternatively, we can set <code>plotly = TRUE</code> in the plot
command to get a 3D visualization of the function by using the
<code>plotly</code> <span class="citation">(Sievert 2020)</span>
package. When the first argument of <code>plot_function</code> is a
vector, the function assumes that the values in the vector are the
values of the function evaluated at the vertices of the mesh. As an
alternative, one can also provide the first argument as a matrix
consisting of the triplets <span class="math inline">\((i, t, f(i,
t))\)</span>, where <span class="math inline">\(i\)</span> denotes the
edge number, <span class="math inline">\(t\)</span> the location on the
edge, and <span class="math inline">\(f(i, t)\)</span> the value at that
point.</p>
</div>
</div>
<div class="section level2">
<h2 id="random-fields-on-metric-graphs">Random fields on metric graphs<a class="anchor" aria-label="anchor" href="#random-fields-on-metric-graphs"></a>
</h2>
<p>Having defined the metric graph, we are now ready to specify Gaussian
processes on it. In this section, we will briefly cover the three main
types of Gaussian processes that are supported. Be begin by the main
class of models, the Whittle–Matérn fields, then consider Gaussian
processes with isotropic covariance functions, and finally look at
discrete models based on the graph Laplacian.</p>
<div class="section level3">
<h3 id="whittlematérn-fields">Whittle–Matérn fields<a class="anchor" aria-label="anchor" href="#whittlemat%C3%A9rn-fields"></a>
</h3>
<p>The Gaussian Whittle–Matérn fields are specified as solutions to the
stochastic differential equation <span class="math display">\[
  (\kappa^2 - \Delta)^{\alpha/2} \tau u = \mathcal{W}
\]</span> on the metric graph <span class="math inline">\(\Gamma\)</span>. We can work with these models
without and approximations if the smoothness parameter <span class="math inline">\(\alpha\)</span> is an integer, and this is what we
focus on in this vignette. For details on the case of a general
smoothness parameter, see <a href="fem_models.html">Whittle–Matérn
fields with general smoothness</a>.</p>
<div class="section level4">
<h4 id="sampling">Sampling<a class="anchor" aria-label="anchor" href="#sampling"></a>
</h4>
<p>As an example, let us simulate the field <span class="math inline">\(u\)</span> on the graph using <span class="math inline">\(\alpha = 1\)</span>. To do so, we again draw some
locations at random, then sample the field at these locations and plot
the result</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">1.3</span></span>
<span><span class="va">range</span> <span class="op">&lt;-</span> <span class="fl">0.15</span> <span class="co"># range parameter</span></span>
<span><span class="va">sigma_e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span></span>
<span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">200</span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, PtE <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                                         distance_on_edge <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                                         u <span class="op">=</span> <span class="va">u</span><span class="op">)</span>,</span>
<span>                       normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"u"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-13-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can also sample the field at the mesh on the graph as follows:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, type <span class="op">=</span> <span class="st">"mesh"</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">u</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-14-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Since <span class="math inline">\(\alpha=1\)</span>, these sample
paths are continuous but not differentiable. To visualize the
correlation structure of the field, we can compute and plot the
covariances between some point and all other points in the graph as
follows:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde_covariance.html">spde_covariance</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">200</span>, <span class="fl">0.1</span><span class="op">)</span>, range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                            graph <span class="op">=</span> <span class="va">graph</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">C</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-15-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To obtain a field with differentiable sample paths, we can change to
<span class="math inline">\(\alpha=2\)</span> in the code above.</p>
</div>
<div class="section level4">
<h4 id="inference">Inference<a class="anchor" aria-label="anchor" href="#inference"></a>
</h4>
<p>In the following examples we will consider models without replicates.
Please, see the <a href="random_fields.html">Gaussian random fields on
metric graphs</a> vignette for examples with replicates.</p>
<p>Suppose that we have data of the form <span class="math display">\[
y_i = \beta_1\text{lon}(s_i) +  \beta_1\text{lat}(s_i) +  u(s_i) +
\varepsilon_i, \quad i=1,\ldots,n
\]</span> where <span class="math inline">\(s_i\in \Gamma\)</span> are
observation locations, lon and lat are the longitude and latitude of
these locations, <span class="math inline">\(\beta_1,\beta_2\)</span>
are some regression coefficients, and <span class="math inline">\(\varepsilon_i\)</span> are independent centered
Gaussian variables <span class="math inline">\(N(0,\sigma_e^2)\)</span>
representing measurement noise.</p>
<p>Let us create such observations, clear the current data in the graph,
and finally add the data on the graph:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">range</span> <span class="op">&lt;-</span> <span class="fl">0.2</span> <span class="co"># range parameter</span></span>
<span><span class="va">sigma_e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span></span>
<span><span class="va">n.obs.1</span> <span class="op">&lt;-</span> <span class="fl">400</span> <span class="co"># all edges</span></span>
<span><span class="va">n.obs.2</span> <span class="op">&lt;-</span> <span class="fl">100</span> <span class="co"># long edges</span></span>
<span></span>
<span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="va">n.obs.1</span> <span class="op">+</span> <span class="va">n.obs.2</span></span>
<span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs.1</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs.1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Let us now add some locations on long edges:</span></span>
<span><span class="va">long.edges</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">edge_lengths</span> <span class="op">&gt;</span> <span class="fl">0.5</span></span>
<span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">obs.loc</span>, <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">long.edges</span><span class="op">)</span>, <span class="va">n.obs.2</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs.2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, PtE <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span>
<span></span>
<span><span class="va">beta0</span> <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span><span class="va">beta1</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="va">beta2</span> <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="va">lonlat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span>
<span><span class="va">scaled_lonlat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale</a></span><span class="op">(</span><span class="va">lonlat</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">beta0</span> <span class="op">+</span> <span class="va">beta1</span> <span class="op">*</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">beta2</span> <span class="op">*</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">u</span> <span class="op">+</span> <span class="va">sigma_e</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span></span>
<span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                   distance_on_edge <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                   lon <span class="op">=</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                   lat <span class="op">=</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                   y <span class="op">=</span> <span class="va">y</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y</span>, X_loc <span class="op">=</span> <span class="va">obs.loc</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-16-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Our goal now is to fit a linear mixed-effects model on this data
assuming a Whittle-Mat'ern latent model with <span class="math inline">\(\alpha=1\)</span>. To this end, we can use the
<code><a href="../reference/graph_lme.html">graph_lme()</a></code> function.</p>
<p>If we do not specify the model, it will fit a linear regression
model. So, let us first fit a simple linear regression model to
illustrate:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_lm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span><span class="op">)</span></span></code></pre></div>
<p>We can get the summary:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_lm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Linear regression model</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) -1.13093    0.06936  -16.31   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          0.93551    0.07075   13.22   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          2.04390    0.07075   28.89   &lt;2e-16 ***</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No random effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">## std. dev </span></span>
<span><span class="co">## 1.550846 </span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -927.3651</span></span></code></pre>
<p>Let us now fit the linear mixed-effects model with a Whittle-Mat'ern
latent model with <span class="math inline">\(\alpha=1\)</span>. To this
end, we can either specify the <code>model</code> argument as
<code>'alpha1'</code> or as the following list:
<code>list(type = 'WhittleMatern', alpha = 1)</code>. The list makes it
easier to understand which model is being chosen as a random effect,
however, it makes it longer, and less convenient, to write. Let us use
the simplified form:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="st">'WM1'</span><span class="op">)</span></span></code></pre></div>
<p>Let us get the summary of the result:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = "WM1")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept)  -1.1014    0.1181  -9.324  &lt; 2e-16 ***</span></span>
<span><span class="co">## lon           0.9511    0.1201   7.922 2.34e-15 ***</span></span>
<span><span class="co">## lat           1.9748    0.1232  16.035  &lt; 2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##        Estimate Std.error z-value</span></span>
<span><span class="co">## tau    0.114099  0.005449  20.941</span></span>
<span><span class="co">## kappa 11.506072  1.742238   6.604</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma  1.82701   0.09598  19.036</span></span>
<span><span class="co">## range  0.17382   0.02583   6.729</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.07595   0.04519   1.681</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -794.3335 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 26</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  29.30354 secs</span></span></code></pre>
<p>We can obtain additional information by using
<code><a href="../reference/glance.graph_lme.html">glance()</a></code>:</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.graph_lme.html">glance</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs  sigma logLik   AIC   BIC deviance df.residual model         alpha</span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>         <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>   500 0.076<span style="text-decoration: underline;">0</span>  -<span style="color: #BB0000;">794.</span> <span style="text-decoration: underline;">1</span>601. <span style="text-decoration: underline;">1</span>626.    <span style="text-decoration: underline;">1</span>589.         494 WhittleMatern     1</span></span></code></pre>
<p>We will now compare with the true values of the random effects:</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma_e_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">measurement_error</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">sigma_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">range_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">results</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>sigma_e <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma_e</span>, <span class="va">sigma_e_est</span><span class="op">)</span>,</span>
<span>                      sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">sigma_est</span><span class="op">)</span>,</span>
<span>                      range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">range</span>, <span class="va">range_est</span><span class="op">)</span>,</span>
<span>                      row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimate"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">results</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##             sigma_e   sigma     range</span></span>
<span><span class="co">## Truth    0.10000000 2.00000 0.2000000</span></span>
<span><span class="co">## Estimate 0.07595015 1.82701 0.1738213</span></span></code></pre>
<p>Given these estimated parameters, we can now do kriging to estimate
the field at locations in the graph. As an example, we now obtain
predictions on the regular mesh that we previously constructed. First,
we obtain the covariates on the mesh locations.</p>
<p>Now, we can compute the predictions for <span class="math inline">\(y\)</span>. First, let us compute the posterior
mean for the field at the observation locations and plot the residuals
between the posterior means and the field:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">pred_u</span><span class="op">$</span><span class="va">resid_field</span> <span class="op">&lt;-</span> <span class="va">pred_u</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span></span>
<span><span class="va">pred_u</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">process_data</span><span class="op">(</span>data <span class="op">=</span> <span class="va">pred_u</span>, normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">pred_u</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"resid_field"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-23-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can also obtain predictions by using the <code><a href="../reference/augment.graph_lme.html">augment()</a></code>
function:</p>
<p>Let us first plot the predictions for the field, then the fitted
values:</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_aug</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/augment.graph_lme.html">augment</a></span><span class="op">(</span><span class="va">res</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_aug</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">".random"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-24-1.png" width="700"></p>
<p>Let us now plot the fitted values along with the observed values:</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_aug</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">".fitted"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-25-1.png" width="700"></p>
<p>Let us now obtain predictions of the field on a mesh of equally
spaced nodes on the graph. First, let us create the mesh and
<code>data.frame</code>:</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">50</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">lonlat_mesh</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">)</span></span>
<span><span class="va">scaled_lonlat_mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale</a></span><span class="op">(</span><span class="va">lonlat_mesh</span>, </span>
<span>                            center <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">scaled_lonlat</span>, <span class="st">"scaled:center"</span><span class="op">)</span>,</span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">scaled_lonlat</span>, <span class="st">"scaled:scale"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data_mesh_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>lon <span class="op">=</span> <span class="va">scaled_lonlat_mesh</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                              lat <span class="op">=</span> <span class="va">scaled_lonlat_mesh</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>,</span>
<span>                              edge_number <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                              distance_on_edge <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co"># Let us remove duplicated vertices (that were created due to being too close)</span></span>
<span><span class="va">data_mesh_pred</span> <span class="op">&lt;-</span> <span class="va">data_mesh_pred</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/duplicated.html" class="external-link">duplicated</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">)</span>,<span class="op">]</span></span></code></pre></div>
<p>Now, let us obtain the predictions. We can obtain estimates for the
latent field by taking the <code>re_mean</code> element from the
<code>pred</code> list obtained by calling
<code>prediction()</code>:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res</span>, newdata<span class="op">=</span><span class="va">data_mesh_pred</span>, normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">u_est</span> <span class="op">&lt;-</span> <span class="va">pred</span><span class="op">$</span><span class="va">re_mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">u_est</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-27-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Finally, let us obtain predictions for the observed values on the
mesh. In this case we use the <code>mean</code> component of the
<code>pred</code> list:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_est</span> <span class="op">&lt;-</span> <span class="va">pred</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-28-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The same procedure can be done with <span class="math inline">\(\alpha = 2\)</span>. One can also estimate <span class="math inline">\(\alpha\)</span> from data as described in the
vignette <a href="fem_models.html">Whittle–Matérn fields with general
smoothness</a>.</p>
</div>
</div>
<div class="section level3">
<h3 id="isotropic-gaussian-fields">Isotropic Gaussian fields<a class="anchor" aria-label="anchor" href="#isotropic-gaussian-fields"></a>
</h3>
<p>For metric graphs with Euclidean edges, <a href="https://projecteuclid.org/journals/annals-of-statistics/volume-48/issue-4/Isotropic-covariance-functions-on-graphs-and-their-edges/10.1214/19-AOS1896.full" class="external-link"><span class="citation">Anderes, Møller, and Rasmussen (2020)</span></a> showed
that one can define valid Gaussian processes through various isotropic
covariance functions if the distances between points are measured in the
so-called resistance metric <span class="math inline">\(d(\cdot,\cdot)\)</span>. One example of a valid
covariance function is the isotropic exponential covariance function
<span class="math display">\[
r(d(s,t)) = \sigma^2\exp(-\kappa d(s,t)).
\]</span> This covariance is very similar to that of the Whittle–Mat'ern
fields with <span class="math inline">\(\alpha = 1\)</span>. Between the
two, we recommend using the Whittle–Matérn model since it has Markov
properties which makes inference much faster. Further, that covariance
is well-defined for any compact metric graph, whereas the isotropic
exponential is only guaranteed to be positive definite if the graph has
Euclidean edges. See <a href="https://arxiv.org/abs/2304.10372" class="external-link"><span class="citation">Bolin, Simas, and Wallin (2023)</span></a> for further
comparisons.</p>
<p>However, let us now illustrate how to use it for the data that we
generated above. To work with the covariance function, the only
cumbersome thing is to compute the metric. The <code>metric_graph</code>
class has built in support for this, and we can obtain the distances
between the observation locations as</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">compute_resdist</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>However, if the goal is to fit a model using this covariance
function, there is no need for the user to compute it. It is done
internally when one uses the <code><a href="../reference/graph_lme.html">graph_lme()</a></code> function. We need
to set the <code>model</code> argument in <code><a href="../reference/graph_lme.html">graph_lme()</a></code> as a
list with type <code>"isoCov"</code> (there is no need to add additional
arguments, as the exponential covariance is the default). Let us fit a
linear regression model with a random effect given by a Gaussian field
with an isotropic exponential covariance function (alternatively, one
can also write <code>model = 'isoExp'</code>):</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"isoCov"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in graph_lme(y ~ lon + lat, graph = graph, model = list(type =</span></span>
<span><span class="co">## "isoCov")): No check for Euclidean edges have been perfomed on this graph. The</span></span>
<span><span class="co">## isotropic covariance models are only known to work for graphs with Euclidean</span></span>
<span><span class="co">## edges. You can check if the graph has Euclidean edges by running the</span></span>
<span><span class="co">## `check_euclidean()` method. See the vignette</span></span>
<span><span class="co">## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html</span></span>
<span><span class="co">## for further details.</span></span></code></pre>
<p>Observe that we received a warning saying that we did not check if
the graph has Euclidean edges. This is due to the fact that the
isotropic covariance models are only known to work for graphs with
Euclidean edges. Let us check if the graph has Euclidean edges. To this
end, we need to use the <code>check_euclidean()</code> method:</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">check_euclidean</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>Now, we simply call the graph to print its characteristics to check
the information:</p>
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span></span></code></pre></div>
<pre><code><span><span class="co">## A metric graph with  248  vertices and  397  edges.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Vertices:</span></span>
<span><span class="co">##   Degree 1: 12;  Degree 2: 1;  Degree 3: 164;  Degree 4: 67;  Degree 5: 4; </span></span>
<span><span class="co">##   With incompatible directions:  1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Edges: </span></span>
<span><span class="co">##   Lengths: </span></span>
<span><span class="co">##       Min: 0.005650044  ; Max: 2.141415  ; Total: 64.48864 </span></span>
<span><span class="co">##   Weights: </span></span>
<span><span class="co">##       Min: 1  ; Max: 1 </span></span>
<span><span class="co">##   That are circles:  0 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Graph units: </span></span>
<span><span class="co">##   Vertices unit:  degrees  ; Lengths unit:  km </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Longitude and Latitude coordinates:  TRUE</span></span>
<span><span class="co">##   Which spatial package:  sp </span></span>
<span><span class="co">##   CRS:  +proj=longlat +datum=WGS84 +no_defs</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Some characteristics of the graph:</span></span>
<span><span class="co">##   Connected: TRUE</span></span>
<span><span class="co">##   Has loops: FALSE</span></span>
<span><span class="co">##   Has multiple edges: TRUE</span></span>
<span><span class="co">##   Is a tree: FALSE</span></span>
<span><span class="co">##   Distance consistent: unknown</span></span></code></pre>
<pre><code><span><span class="co">## To check if the graph satisfies the distance consistency, run the `check_distance_consistency()` method.</span></span></code></pre>
<pre><code><span><span class="co">##   Has Euclidean edges: FALSE</span></span></code></pre>
<p>Observe that this graph DOES NOT have Euclidean edges. This means
that the model with isotropic exponential covariance is not guaranteed
to work for this graph. In any case, we can try to fit it anyway.
Observe that we will now receive a different warning, since now we know
for fact that the graph does not have Euclidean edges. In this case, we
will set <code>model</code> to <code>isoexp</code> for conveniency.</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="st">"isoexp"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in graph_lme(y ~ lon + lat, graph = graph, model = "isoexp"): This</span></span>
<span><span class="co">## graph DOES NOT have Euclidean edges. The isotropic covariance models are NOT</span></span>
<span><span class="co">## guaranteed to work for this graph! See the vignette</span></span>
<span><span class="co">## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html</span></span>
<span><span class="co">## for further details.</span></span></code></pre>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_exp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Covariance-based model</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = "isoexp")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept)  -1.1399    0.1846  -6.175 6.61e-10 ***</span></span>
<span><span class="co">## lon           0.9183    0.1423   6.454 1.09e-10 ***</span></span>
<span><span class="co">## lat           2.0044    0.1644  12.194  &lt; 2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## tau    1.71966   0.09721  17.690</span></span>
<span><span class="co">## kappa 14.04626   2.41997   5.804</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.06769   0.04953   1.367</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -801.5418 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 40</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  36.4339 secs</span></span></code></pre>
<p>We can also have a glance at the fitted model:</p>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.graph_lme.html">glance</a></span><span class="op">(</span><span class="va">res_exp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs  sigma logLik   AIC   BIC deviance df.residual model  cov_function  </span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>         </span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>   500 0.067<span style="text-decoration: underline;">7</span>  -<span style="color: #BB0000;">802.</span> <span style="text-decoration: underline;">1</span>615. <span style="text-decoration: underline;">1</span>640.    <span style="text-decoration: underline;">1</span>603.         494 isoCov exp_covariance</span></span></code></pre>
<p>Let us now compute the posterior mean for the field at the
observation locations and plot the residuals between the field and the
posterior means of the field:</p>
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_exp</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_exp</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-35-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To perform kriging prediction to other locations, one can use the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method along with a <code>data.frame</code>
containing the locations in which one wants to obtain predictions and
the corresponding covariate values at these locations. In this example
we will use the <code>data_mesh_pred</code> from the previous example.
Let us estimate the observed values at the mesh locations:</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_exp_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_exp</span>, newdata <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">y_est_exp</span> <span class="op">&lt;-</span> <span class="va">pred_exp_y</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est_exp</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-36-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="models-based-on-the-graph-laplacian">Models based on the Graph Laplacian<a class="anchor" aria-label="anchor" href="#models-based-on-the-graph-laplacian"></a>
</h3>
<p>A final set of Gaussian models that is supported by
<code>MetricGraph</code> is the Matérn type processes based on the graph
Laplacian introduced by <a href="http://proceedings.mlr.press/v130/borovitskiy21a/borovitskiy21a.pdf" class="external-link"><span class="citation">Borovitskiy et al. (2021)</span></a>. These are
multivariate Gaussian distributions, which are defined in the vertices
through the equation <span class="math display">\[
(\kappa^2\mathbf{I} - \mathbf{\Delta}_\Gamma)^{\alpha/2}\mathbf{u} =
\mathbf{W}
\]</span> Here <span class="math inline">\(\mathbf{W}\sim
N(0,\sigma^2\mathbf{I})\)</span> is a vector with independent Gaussian
variables and <span class="math inline">\(\mathbf{\Delta}_\Gamma\)</span> is the graph
Laplacian. Further, <span class="math inline">\(\mathbf{u}\)</span> is a
vector with the values of the process in the vertices of <span class="math inline">\(\Gamma\)</span>, which by definition has precision
matrix <span class="math display">\[
\mathbf{Q} = \sigma^{-2}(\kappa^2\mathbf{I} -
\mathbf{\Delta}_\Gamma)^{\alpha}
\]</span> Thus, to define these models, the only “difficult” thing is to
compute the graph Laplacian. The (weighted) graph Laplacian, where the
weights are specified by the edge lengths can be computed by the
function <code>compute_laplacian()</code> in the
<code>metric_graph</code> object. Suppose that we want to fit the data
that we defined above with this model. We can use the
<code><a href="../reference/graph_lme.html">graph_lme()</a></code> function. Also, observe that there is no need
to use the <code>compute_laplacian()</code> function, as it is done
internally. We now set the <code>model</code> argument as a list with
the <code>type</code> being <code>"GraphLaplacian"</code>
(alternatively, one can also write <code>model = 'GL1'</code>) to obtain
a graph Laplacian model with <code>alpha=1</code>:</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_gl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"GraphLaplacian"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_gl</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - graph Laplacian SPDE with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = list(type = "GraphLaplacian"))</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept)  -1.1262    0.1151  -9.784  &lt; 2e-16 ***</span></span>
<span><span class="co">## lon           0.9531    0.1205   7.913 2.52e-15 ***</span></span>
<span><span class="co">## lat           2.0330    0.1185  17.156  &lt; 2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## tau   0.110274  0.005644  19.540</span></span>
<span><span class="co">## kappa 2.954880  0.361342   8.178</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma  3.73030   0.14660  25.446</span></span>
<span><span class="co">## range  0.67685   0.08092   8.365</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.06880   0.04889   1.407</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -792.0209 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 23</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  2.44643 secs</span></span></code></pre>
<p>We can also have a glance at the fitted model:</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.graph_lme.html">glance</a></span><span class="op">(</span><span class="va">res_gl</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs  sigma logLik   AIC   BIC deviance df.residual model          alpha</span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>          <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>   500 0.068<span style="text-decoration: underline;">8</span>  -<span style="color: #BB0000;">792.</span> <span style="text-decoration: underline;">1</span>596. <span style="text-decoration: underline;">1</span>621.    <span style="text-decoration: underline;">1</span>584.         494 GraphLaplacian     1</span></span></code></pre>
<p>We can now obtain prediction at the observed locations by using the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method. Let us compute the posterior mean for the
field at the observation locations and plot the residuals between the
field and the posterior means of the field:</p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_GL</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-39-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Now, if we do predictions outside of the observation locations on a
graph Laplacian model, we need to modify the graph. This modifies the
model in its entirety. Thus, we need to refit the model with all the
observation locations we want to do predictions. However, if we use the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method with observations outside of the
observation locations, the <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> will return
predictions together with a <code>warning</code> that one should refit
the model to obtain proper predictions. Here, we will see the (incorrect
way of obtaining) predictions of the observed data:</p>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl</span>, newdata <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in predict.graph_lme(res_gl, newdata = data_mesh_pred, normalized =</span></span>
<span><span class="co">## TRUE): There are prediction locations outside of the observation locations.</span></span>
<span><span class="co">## Refit the model with all the locations you want to obtain predictions.</span></span></code></pre>
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_est_GL</span> <span class="op">&lt;-</span> <span class="va">pred_GL_y</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est_GL</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-40-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now refit the model with all the locations we want to obtain
predictions. Let us create a new data set with all the original
locations and all the locations we want to obtain predictions (with
<code>y=NA</code> at the locations we want to obtain predictions):</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_mesh_temp</span> <span class="op">&lt;-</span> <span class="va">data_mesh_pred</span></span>
<span><span class="va">data_mesh_temp</span><span class="op">[[</span><span class="st">"y"</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">data_mesh_pred</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">new_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sp/man/merge.html" class="external-link">merge</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">data_mesh_temp</span>, all <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us clone the graph and add the new data:</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph_pred</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph_pred</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph_pred</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">new_data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<p>Let us now fit the model with all data:</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_gl_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph_pred</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"GraphLaplacian"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in graph_lme(y ~ lon + lat, graph = graph_pred, model = list(type =</span></span>
<span><span class="co">## "GraphLaplacian")): optim method L-BFGS-B failed to provide a positive-definite</span></span>
<span><span class="co">## Hessian. Another optimization method was used.</span></span></code></pre>
<div class="sourceCode" id="cb94"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_gl_pred</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - graph Laplacian SPDE with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph_pred, model = list(type = "GraphLaplacian"))</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept) -1.11486   0.09908  -11.25   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          0.92625   0.08130   11.39   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          2.07185   0.08080   25.64   &lt;2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## tau    0.16682   0.02479   6.730</span></span>
<span><span class="co">## kappa  1.74728   0.42127   4.148</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma   3.2066    0.1942  16.512</span></span>
<span><span class="co">## range   1.1446    0.2376   4.817</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev   0.9317    0.1017   9.162</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -896.1099 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 501</span></span>
<span><span class="co">## Optimization method used in 'optim' = Nelder-Mead</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  6.81584 secs</span></span></code></pre>
<p>One should compare the estimates with the ones obtained in the model
without the prediction locations.</p>
<p>Let us first compute the residual between the latent field and the
posterior means at the observation locations:</p>
<div class="sourceCode" id="cb96"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_full</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl_pred</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_GL_full</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-44-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now obtain predictions at the desired locations (in the
correct way) of the observed data:</p>
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_y_full</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl_pred</span>, newdata <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">y_est_GL_full</span> <span class="op">&lt;-</span> <span class="va">pred_GL_y_full</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est_GL_full</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in viridisLite::viridis(n, alpha, begin, end, direction, option):</span></span>
<span><span class="co">## Option 'd' does not exist. Defaulting to 'viridis'.</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-45-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="the-inlabru-interface">The <code>inlabru</code> interface<a class="anchor" aria-label="anchor" href="#the-inlabru-interface"></a>
</h2>
<p>In this vignette we will present our <code>inlabru</code> interface
to Whittle–Matérn fields. The <code>MetricGraph</code> package also has
a similar interface to<code>R-INLA</code>, which is described in detail
in the <a href="inla_interface.html">INLA interface of Whittle–Matérn
fields</a> vignette.</p>
<div class="section level3">
<h3 id="basic-setup-and-estimation">Basic setup and estimation<a class="anchor" aria-label="anchor" href="#basic-setup-and-estimation"></a>
</h3>
<p>We will use the same graph and data as before. The
<code>inlabru</code> implementation requires the observation locations
to be added to the graph. However, note that for the Whittle–Matérn
fields (contrary to the models based on the graph Laplacian) we are not
changing the model by adding vertices at observation locations. We
already created the extended graph above, so we can use that. Now, we
load <code>INLA</code> and <code>inlabru</code> packages. We will also
need to create the <code>inla</code> model object with the
<code>graph_spde</code> function. By default we have
<code>alpha=1</code>.</p>
<div class="sourceCode" id="cb99"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">INLA</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="http://www.inlabru.org" class="external-link">inlabru</a></span><span class="op">)</span></span>
<span><span class="va">spde_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_spde.html">graph_spde</a></span><span class="op">(</span><span class="va">graph</span><span class="op">)</span></span></code></pre></div>
<p>Recall that the data is already on the graph object (from the
previous models above). Now, we create <code>inlabru</code>’s component,
which is a formula-like object:</p>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cmp</span> <span class="op">&lt;-</span> <span class="va">y</span> <span class="op">~</span> <span class="fu">Intercept</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span> <span class="op">+</span> <span class="fu">field</span><span class="op">(</span><span class="va">loc</span>, model <span class="op">=</span> <span class="va">spde_model</span><span class="op">)</span></span></code></pre></div>
<p>This formula is very simple since we are not assuming mean zero, so
that we do not need an intercept, and we do not have any other
covariates or model components. However, the setup is exactly the same
for more complicated models, with the only exception that we would have
more terms in the formla. Now, we directly fit the model:</p>
<div class="sourceCode" id="cb101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spde_bru_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/inlabru/reference/bru.html" class="external-link">bru</a></span><span class="op">(</span><span class="va">cmp</span>, data <span class="op">=</span> </span>
<span>              <span class="fu"><a href="../reference/graph_data_spde.html">graph_data_spde</a></span><span class="op">(</span><span class="va">spde_model</span>, loc_name <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span><span class="op">[[</span><span class="st">"data"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>The advantage / difference between the estimates we obtain here and
those above is that the <code>bru</code> function does full Bayesian
inference (assuming priors for the model parameters). We used the
default priors when creating the <code>graph_spde</code> model (see the
help text for that function). The advantage now is that we do not only
obtain point estimates but entire posterior distributions for the
parameters. To view the estimates we can use the
<code><a href="../reference/spde_metric_graph_result.html">spde_metric_graph_result()</a></code> function, then taking a
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>:</p>
<div class="sourceCode" id="cb102"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spde_bru_result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde_metric_graph_result.html">spde_metric_graph_result</a></span><span class="op">(</span><span class="va">spde_bru_fit</span>, </span>
<span>                    <span class="st">"field"</span>, <span class="va">spde_model</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">spde_bru_result</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##           mean        sd 0.025quant 0.5quant 0.975quant     mode</span></span>
<span><span class="co">## sigma 1.878850 0.1058050   1.666460 1.861940   2.077830 1.856550</span></span>
<span><span class="co">## range 0.179203 0.0269994   0.132426 0.177022   0.238259 0.172403</span></span></code></pre>
<p>Here we are showing the estimate of the practical correlation range
(<span class="math inline">\(2/\kappa\)</span>) instead of <span class="math inline">\(\kappa\)</span> since that is easier to interpret.
We now compare the means of the estimated values with the true
values:</p>
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">result_df_bru</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    parameter <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"std.dev"</span>, <span class="st">"range"</span><span class="op">)</span>,</span>
<span>    true <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">range</span><span class="op">)</span>,</span>
<span>    mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.sigma</span><span class="op">$</span><span class="va">mean</span>,</span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.range</span><span class="op">$</span><span class="va">mean</span></span>
<span>    <span class="op">)</span>,</span>
<span>    mode <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.sigma</span><span class="op">$</span><span class="va">mode</span>,</span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.range</span><span class="op">$</span><span class="va">mode</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">result_df_bru</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   parameter true      mean      mode</span></span>
<span><span class="co">## 1   std.dev  2.0 1.8788526 1.8565541</span></span>
<span><span class="co">## 2     range  0.2 0.1792027 0.1724034</span></span></code></pre>
<p>We can also plot the posterior marginal densities with the help of
the <code><a href="../reference/gg_df.metric_graph_spde_result.html">gg_df()</a></code> function:</p>
<div class="sourceCode" id="cb106"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">posterior_df_bru_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gg_df.metric_graph_spde_result.html">gg_df</a></span><span class="op">(</span><span class="va">spde_bru_result</span><span class="op">)</span></span>
<span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">posterior_df_bru_fit</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html" class="external-link">geom_line</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html" class="external-link">facet_wrap</a></span><span class="op">(</span><span class="op">~</span><span class="va">parameter</span>, scales <span class="op">=</span> <span class="st">"free"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">labs</a></span><span class="op">(</span>y <span class="op">=</span> <span class="st">"Density"</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-51-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="kriging-with-the-inlabru-implementation">Kriging with the <code>inlabru</code> implementation<a class="anchor" aria-label="anchor" href="#kriging-with-the-inlabru-implementation"></a>
</h3>
<p>Unfortunately, our <code>inlabru</code> implementation is not
compatible with <code>inlabru</code>’s <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method.
This has to do with the nature of the metric graph’s object.</p>
<p>To this end, we have provided a different <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>
method. We will now show how to do kriging with the help of this
function.</p>
<p>We begin by creating a data list with the positions we want the
predictions. In this case, we will want the predictions on a mesh.</p>
<p>The positions we want are the mesh positions, which we have in the
<code>data.frame</code> for the previous models. The function
<code><a href="../reference/graph_bru_process_data.html">graph_bru_process_data()</a></code> helps us into converting that
<code>data.frame</code> to an <code>inlabru</code> friendly format for
dealing with metric graphs:</p>
<div class="sourceCode" id="cb107"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_bru_process_data.html">graph_bru_process_data</a></span><span class="op">(</span><span class="va">data_mesh_pred</span>, loc <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span></span></code></pre></div>
<p>We can now obtain the predictions by using the <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>
method. Observe that our <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method for graph models
is a bit different from <code>inlabru</code>’s standard
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method. Indeed, the first argument is the model
created with the <code><a href="../reference/graph_spde.html">graph_spde()</a></code> function, the second is
<code>inlabru</code>’s component, and the remaining is as done with the
standard <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method in <code>inlabru</code>.</p>
<div class="sourceCode" id="cb108"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">field_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">spde_model</span>, </span>
<span>                                <span class="va">cmp</span>,</span>
<span>                                <span class="va">spde_bru_fit</span>, </span>
<span>                                newdata <span class="op">=</span> <span class="va">data_list</span>,</span>
<span>                                formula <span class="op">=</span> <span class="op">~</span> <span class="va">field</span><span class="op">)</span></span></code></pre></div>
<p>Let us plot the predictions of the latent field:</p>
<div class="sourceCode" id="cb109"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_field_prd</span> <span class="op">&lt;-</span> <span class="va">field_pred</span><span class="op">$</span><span class="va">pred</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">mean_field_prd</span>, improve_plot <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                      vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-54-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Finally, let us plot predictions of the observed data at the mesh
locations:</p>
<div class="sourceCode" id="cb110"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obs_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">spde_model</span>, </span>
<span>                                <span class="va">cmp</span>,</span>
<span>                                <span class="va">spde_bru_fit</span>, </span>
<span>                                newdata <span class="op">=</span> <span class="va">data_list</span>,</span>
<span>                                formula <span class="op">=</span> <span class="op">~</span> <span class="va">Intercept</span> <span class="op">+</span> <span class="va">lat</span> <span class="op">+</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">field</span><span class="op">)</span></span></code></pre></div>
<p>Let us plot the predictions:</p>
<div class="sourceCode" id="cb111"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_obs_prd</span> <span class="op">&lt;-</span> <span class="va">obs_pred</span><span class="op">$</span><span class="va">pred</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">mean_obs_prd</span>, improve_plot <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                    vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-56-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Anderes2020" class="csl-entry">
Anderes, Ethan, Jesper Møller, and Jakob G Rasmussen. 2020.
<span>“Isotropic Covariance Functions on Graphs and Their Edges.”</span>
<em>Annals of Statistics</em>.
</div>
<div id="ref-inlabru2019" class="csl-entry">
Bachl, Fabian E., Finn Lindgren, David L. Borchers, and Janine B.
Illian. 2019. <span>“Inlabru an R Package for Bayesian Spatial Modelling
from Ecological Survey Data.”</span> <em>Methods in Ecology and
Evolution</em>.
</div>
<div id="ref-sppackage" class="csl-entry">
Bivand, Roger S., Edzer Pebesma, and Virgilio Gomez-Rubio. 2013.
<em>Applied Spatial Data Analysis with R</em>. Springer, NY.
</div>
<div id="ref-BSW2022b" class="csl-entry">
Bolin, David, Alexandre B. Simas, and Jonas Wallin. 2023.
<span>“Statistical Properties of Gaussian Whittle–Matérn Fields on
Metric Graphs.”</span> <em>arXiv:2304.10372</em>.
</div>
<div id="ref-BSW2022a" class="csl-entry">
———. 2024. <span>“Gaussian Whittle–Matérn Fields on Metric
Graphs.”</span> <em>Bernoulli</em>.
</div>
<div id="ref-Borovitskiy2021" class="csl-entry">
Borovitskiy, Viacheslav, Iskander Azangulov, Alexander Terenin, Peter
Mostowsky, Marc Deisenroth, and Nicolas Durrande. 2021. <span>“Matérn
Gaussian Processes on Graphs.”</span> <em>International Conference on
Artificial Intelligence and Statistics</em>.
</div>
<div id="ref-LindgrenRue2015" class="csl-entry">
Lindgren, Finn, and Haavard Rue. 2015. <span>“Bayesian Spatial Modelling
with R-INLA.”</span> <em>Journal of Statistical Software</em>.
</div>
<div id="ref-plotlypackage" class="csl-entry">
Sievert, Carson. 2020. <em>Interactive Web-Based Data Visualization with
R, Plotly, and Shiny</em>. Chapman and Hall/CRC.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by David Bolin, Alexandre Simas, Jonas Wallin.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
