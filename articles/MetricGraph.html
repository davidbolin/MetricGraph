<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="MetricGraph">
<title>MetricGraph: Random Fields on Metric Graphs • MetricGraph</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><link href="../deps/Roboto_Slab-0.4.6/font.css" rel="stylesheet">
<!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="MetricGraph: Random Fields on Metric Graphs">
<meta property="og:description" content="MetricGraph">
<meta property="og:image" content="https://davidbolin.github.io/MetricGraph/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">MetricGraph</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item">
  <a class="nav-link" href="../articles/MetricGraph.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Functions</a>
</li>
<li class="nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-vignettes">Vignettes</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-vignettes">
    <a class="dropdown-item" href="../articles/metric_graph.html">Working with metric graphs</a>
    <a class="dropdown-item" href="../articles/random_fields.html">Gaussian random fields on metric graphs</a>
    <a class="dropdown-item" href="../articles/inlabru_interface.html">inlabru interface of Whittle--Matérn fields</a>
    <a class="dropdown-item" href="../articles/inla_interface.html">INLA interface of Whittle--Matérn fields</a>
    <a class="dropdown-item" href="../articles/fem_models.html">Whittle--Matérn fields with general smoothness</a>
    <a class="dropdown-item" href="../articles/pointprocess.html">Log-Gaussian Cox processes on metric graphs</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/davidbolin/MetricGraph/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
<li class="nav-item">
  <a class="external-link nav-link" href="https://twitter.com/jdavidbolin" aria-label="Twitter">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>MetricGraph: Random Fields on Metric Graphs</h1>
                        <h4 data-toc-skip class="author">David Bolin,
Alexandre B. Simas, and Jonas Wallin</h4>
            
            <h4 data-toc-skip class="date">2023-05-09</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/davidbolin/MetricGraph/blob/HEAD/vignettes/MetricGraph.Rmd" class="external-link"><code>vignettes/MetricGraph.Rmd</code></a></small>
      <div class="d-none name"><code>MetricGraph.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>There has lately been much interest in statistical modeling of data
on compact metric graphs such as street or river networks based on
Gaussian random fields.</p>
<p>The <code>R</code> package <code>MetricGraph</code> contains
functions for working with data and random fields on compact metric
graphs. The main functionality is contained in the
<code>metric_graph</code> class, which is used for specifying metric
graphs, adding data to them, visualization, and other basic functions
that are needed for working with data and random fields on metric
graphs. The package also implements three types of Gaussian processes on
metric graphs: The Whittle–Matérn fields introduced by <a href="https://arxiv.org/abs/2205.06163" class="external-link"><span class="citation">Bolin,
Simas, and Wallin (2022)</span></a> and <a href="https://arxiv.org/abs/2304.10372" class="external-link"><span class="citation">Bolin,
Simas, and Wallin (2023)</span></a>, Gaussian processes with isotropic
covariance functions <a href="https://projecteuclid.org/journals/annals-of-statistics/volume-48/issue-4/Isotropic-covariance-functions-on-graphs-and-their-edges/10.1214/19-AOS1896.full" class="external-link"><span class="citation">Anderes, Møller, and Rasmussen (2020)</span></a>, and
Gaussian models based on the graph Laplacian <a href="http://proceedings.mlr.press/v130/borovitskiy21a/borovitskiy21a.pdf" class="external-link"><span class="citation">Borovitskiy et al. (2021)</span></a>.</p>
<p>Basic statistical tasks such as likelihood evaluation and prediction
is implemented for these three types of models in
<code>MetricGraph</code>. Further, the package also contains interfaces
to <code>R-INLA</code> <a href="https://www.jstatsoft.org/article/view/v063i19" class="external-link"><span class="citation">Lindgren and Rue (2015)</span></a>, package available
from <a href="http://R-INLA.org/download/" class="external-link">http://R-INLA.
org/download/</a> and <code>inlabru</code> <a href="https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.13168" class="external-link"><span class="citation">Bachl et al. (2019)</span></a> that facilitates using
those packages for full Bayesian inference of general Latent Gaussian
Models (LGMs) that includes Whittle–Matérn fields on metric graphs.</p>
<!-- The package is available to install from the Comprehensive R Archive
Network (CRAN) at \url{https://CRAN.R-project.org/package=MetricGraph}. A development version of the package is available via the repository [https://github.com/davidbolin/MetricGraph](https://github.com/davidbolin/MetricGraph). The development version is updated more frequently, and can easily be installed directly in R as described on the repository homepage.  -->
<p>The package is available to install via the repository <a href="https://github.com/davidbolin/MetricGraph" class="external-link">https://github.com/davidbolin/MetricGraph</a>.</p>
<p>The following sections describe the main functionality of the package
and summarizes some of the required theory. Section 2 introduces metric
graphs and the <code>metric_graph</code> class, Section 3 shows how to
work with random fields on metric graphs, and Section 4 introduces the
<code>inlabru</code> interface of the package through an application to
real data. For a complete introduction to the functionality of the
package, we refer to the Vignettes available on the package homepage <a href="https://davidbolin.github.io/MetricGraph/">https://davidbolin.github.io/MetricGraph/</a>.
In particular, that contains an introduction to the <code>INLA</code>
interface, the implementation of Whittle–Matérn fields with general
smoothness, and further details and examples for all methods in the
package.</p>
</div>
<div class="section level2">
<h2 id="the-metric_graph-class">The <code>metric_graph</code> class<a class="anchor" aria-label="anchor" href="#the-metric_graph-class"></a>
</h2>
<p>A compact metric graph <span class="math inline">\(\Gamma\)</span>
consists of a set of finitely many vertices <span class="math inline">\(\mathcal{V}=\{v_i\}\)</span> and a finite set
<span class="math inline">\(\mathcal{E}=\{e_j\}\)</span> of edges
connecting the vertices. Each edge <span class="math inline">\(e\)</span> is defined by a pair of vertices <span class="math inline">\((v_i,v_k)\)</span> and a finite length <span class="math inline">\(l_e \in (0,\infty)\)</span>. An edge in the graph
is a curve parametrized by arc-length, and a location <span class="math inline">\(s\in \Gamma\)</span> is a position on an edge, and
can thus be represented as a touple <span class="math inline">\((e,t)\)</span> where <span class="math inline">\(t\in[0,l_e]\)</span>.</p>
<div class="section level3">
<h3 id="basic-constructions">Basic constructions<a class="anchor" aria-label="anchor" href="#basic-constructions"></a>
</h3>
<p>A metric graph is represented in the <code>MetricGraph</code> package
through the class <code>metric_graph</code>. An object of this class can
be constructed in two ways. The first is to specify the vertex matrix
<code>V</code> and the edge matrix <code>E</code>, and it is then
assumed that all edges are straight lines. The second, more flexible,
option is to specify the object from a <code>SpatialLines</code> object
using the <code>sp</code> package <span class="citation">(Bivand,
Pebesma, and Gomez-Rubio 2013)</span>.</p>
<p>To illustrate this, we use the <code>osmdata</code> package to
download data from OpenStreetMap. In the following code, we extract the
streets on the campus of King Abdullah University of Science and
Technology (KAUST) as a <code>SpatialLines</code> object:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">call</span> <span class="op">&lt;-</span> <span class="fu">opq</span><span class="op">(</span>bbox <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">39.0884</span>, <span class="fl">22.33</span>, <span class="fl">39.115</span>, <span class="fl">22.3056</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">call</span> <span class="op">&lt;-</span> <span class="fu">add_osm_feature</span><span class="op">(</span><span class="va">call</span>, key <span class="op">=</span> <span class="st">"highway"</span>,value<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"motorway"</span>,</span>
<span>                                                      <span class="st">"primary"</span>,<span class="st">"secondary"</span>,</span>
<span>                                                      <span class="st">"tertiary"</span>,</span>
<span>                                                      <span class="st">"residential"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu">osmdata_sp</span><span class="op">(</span><span class="va">call</span><span class="op">)</span></span>
<span><span class="va">lines</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sp/man/SpatialLines.html" class="external-link">SpatialLines</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">osm_lines</span><span class="op">@</span><span class="va">lines</span><span class="op">)</span></span></code></pre></div>
<p>We can now create the metric graph as follows. In the command we set
the argument <code>longlat = TRUE</code> since the coordinates of the
vertices are given in Longitude and Latitude.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="va"><a href="../reference/metric_graph.html">metric_graph</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">lines</span>, longlat <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## The graph is disconnected. You can use the function 'graph_components' to obtain the different connected components.</span></span></code></pre>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>vertex_size <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-2-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can note the warning that the graph is not connected, so let us
create a <code>graph_components</code> object that contains all
connected components as graphs and then extract the largest connected
component to work with</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graphs</span> <span class="op">&lt;-</span> <span class="va"><a href="../reference/graph_components.html">graph_components</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span>lines <span class="op">=</span> <span class="va">lines</span>, longlat <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="va">graphs</span><span class="op">$</span><span class="fu">get_largest</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-3-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The <code>graph</code> object now contains all important features of
the graph, such as the vertex matrix <code>graph$V</code>, the number of
vertices <code>graph$nV</code>, the edge matrix <code>graph$E</code>,
the number of edges <code>graph$nE</code>, and the vector of all edge
lengths <code>graph$edge_lengths</code> given in the unit km (since we
specified <code>longlat = TRUE</code> in the construction). Thus, we can
obtain the range of the edge lengths in the unit m as:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="va">edge_lengths</span><span class="op">)</span> <span class="op">*</span> <span class="fl">1000</span></span></code></pre></div>
<pre><code><span><span class="co">## [1]    5.64704 2141.41501</span></span></code></pre>
<p>We will also remove the vertices of degree 2 by using the
<code>prune_vertices()</code> method:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">prune_vertices</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-5-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="understanding-coordinates-on-graphs">Understanding coordinates on graphs<a class="anchor" aria-label="anchor" href="#understanding-coordinates-on-graphs"></a>
</h3>
<p>The locations of the vertices are specified in Euclidean coordinates.
However, when specifying a position on the graph, it is not practical to
work with Euclidean coordinates since not all locations in Euclidean
space are locations on the graph. It is instead better to specify a
location on the graph by the touple <span class="math inline">\((i,
t)\)</span>, where <span class="math inline">\(i\)</span> denotes the
number of the edge and <span class="math inline">\(t\)</span> is the
location on the edge. The location <span class="math inline">\(t\)</span> can either be specified as the distance
from the start of the edge (and then takes values between 0 and the
length of the edge) or as the normalized distance from the start of the
edge (and then takes values between 0 and 1). The function
<code>coordinates</code> can be used to convert between coordinates in
Euclidean space and locations on the graph. For example the location at
normalized distance 0.2 from the start of the second edge is:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">0.2</span><span class="op">)</span>, <span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          [,1]     [,2]</span></span>
<span><span class="co">## [1,] 39.11751 22.31934</span></span></code></pre>
<p>The function can also be used to find the closest location on the
graph for a location in Euclidean space:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>XY <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">39.117</span>, <span class="fl">22.319</span><span class="op">)</span>, <span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1] [,2]</span></span>
<span><span class="co">## [1,]    1    1</span></span></code></pre>
<p>In this case, the <code>normalized</code> argument decides whether
the returned value should be given in normalized distance or not.</p>
</div>
<div class="section level3">
<h3 id="adding-data-to-the-graph">Adding data to the graph<a class="anchor" aria-label="anchor" href="#adding-data-to-the-graph"></a>
</h3>
<p>Given that we have constructed the metric graph, we can now add data
to it. As an example, let us sample some locations on edges at random
and add data to them in the graph:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span><span class="op">)</span>,</span>
<span>                   distance_on_edge <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span>,</span>
<span>                   y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"y"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-8-1.png" width="700" style="display: block; margin: auto;"></p>
<p>One should note here that one needs to specify
<code>normalized = TRUE</code> in the function to specify that the
locations are in normalized distance on the edges. If this command is
not set, the distances are interpreted as not being normalized. The
<code>add_observations()</code> function accepts multiple types of
inputs. One scenario that can be common in applications is to have the
data as <code>SpatialPoints</code> objects, and one can then add the
observations as a <code>SpatialPointsDataFrame</code>. To illustrate
this, let us again sample some locations at random on the graph, then
use the function <code>coordinates</code> to transform those to
Longitude Latitude coordinates, which we then use to create a
<code>SpatialPointsDataFrame</code> object which we add to the
graph:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">obs.lonlat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">obs.loc</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">obs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span></span>
<span><span class="va">points</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sp/man/SpatialPoints.html" class="external-link">SpatialPointsDataFrame</a></span><span class="op">(</span>coords <span class="op">=</span> <span class="va">obs.lonlat</span>,</span>
<span>                                 data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span><span class="va">points</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"y"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-9-1.png" width="700" style="display: block; margin: auto;"></p>
<p>If we want to replace the data in the object, we can use
<code>clear_observations()</code> to remove all current data.</p>
</div>
<div class="section level3">
<h3 id="working-with-functions-on-metric-graphs">Working with functions on metric graphs<a class="anchor" aria-label="anchor" href="#working-with-functions-on-metric-graphs"></a>
</h3>
<p>When working with data on metric graphs, one often wants to display
functions on the graph. The best way to visualize functions on the graph
is to evaluate them on a fine mesh over the graph and then use
<code>plot_function</code>. To illustrate this procedure, let us
construct a mesh on the graph:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">100</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>mesh<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-10-1.png" width="700" style="display: block; margin: auto;"></p>
<p>In the command <code>build_mesh</code>, the argument <code>h</code>
decides the largest spacing between nodes in the mesh. Above we chose
that as 100m which is a bit coarse. So let us reduce the value of
<code>h</code> to 10m and rebuild the mesh:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">10</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span></code></pre></div>
<p>Suppose now that we want to display the function <span class="math inline">\(f(s) = \text{Longitude}(s) -
\text{Latitude}(s)\)</span> on this graph. We then first evaluate it on
the vertices of the mesh and then use the function
<code>plot_function</code> to display it:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lon</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">lat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">f</span> <span class="op">&lt;-</span> <span class="va">lon</span> <span class="op">-</span> <span class="va">lat</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">f</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-12-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Alternatively, we can set <code>plotly = TRUE</code> in the plot
command to get a 3D visualization of the function by using the
<code>plotly</code> <span class="citation">(Sievert 2020)</span>
package. When the first argument of <code>plot_function</code> is a
vector, the function assumes that the values in the vector are the
values of the function evaluated at the vertices of the mesh. As an
alternative, one can also provide the first argument as a matrix
consisting of the triplets <span class="math inline">\((i, t, f(i,
t))\)</span>, where <span class="math inline">\(i\)</span> denotes the
edge number, <span class="math inline">\(t\)</span> the location on the
edge, and <span class="math inline">\(f(i, t)\)</span> the value at that
point.</p>
</div>
</div>
<div class="section level2">
<h2 id="random-fields-on-metric-graphs">Random fields on metric graphs<a class="anchor" aria-label="anchor" href="#random-fields-on-metric-graphs"></a>
</h2>
<p>Having defined the metric graph, we are now ready to specify Gaussian
processes on it. In this section, we will briefly cover the three main
types of Gaussian processes that are supported. Be begin by the main
class of models, the Whittle–Matérn fields, then consider Gaussian
processes with isotropic covariance functions, and finally look at
discrete models based on the graph Laplacian.</p>
<div class="section level3">
<h3 id="whittlematérn-fields">Whittle–Matérn fields<a class="anchor" aria-label="anchor" href="#whittlemat%C3%A9rn-fields"></a>
</h3>
<p>The Gaussian Whittle–Matérn fields are specified as solutions to the
stochastic differential equation <span class="math display">\[
  (\kappa^2 - \Delta)^{\alpha/2} \tau u = \mathcal{W}
\]</span> on the metric graph <span class="math inline">\(\Gamma\)</span>. We can work with these models
without and approximations if the smoothness parameter <span class="math inline">\(\alpha\)</span> is an integer, and this is what we
focus on in this vignette. For details on the case of a general
smoothness parameter, see <a href="fem_models.html">Whittle–Matérn
fields with general smoothness</a>.</p>
<div class="section level4">
<h4 id="sampling">Sampling<a class="anchor" aria-label="anchor" href="#sampling"></a>
</h4>
<p>As an example, let us simulate the field <span class="math inline">\(u\)</span> on the graph using <span class="math inline">\(\alpha = 1\)</span>. To do so, we again draw some
locations at random, then sample the field at these locations and plot
the result</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">1.3</span></span>
<span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fl">0.15</span> <span class="co"># range parameter</span></span>
<span><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fl">8</span><span class="op">*</span><span class="fl">0.5</span><span class="op">)</span><span class="op">/</span><span class="va">r</span></span>
<span><span class="va">sigma_e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span></span>
<span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">200</span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># The graph has very small edges, so we will use the </span></span>
<span><span class="co"># Q method to improve numerical stability</span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, PtE <span class="op">=</span> <span class="va">obs.loc</span>, method <span class="op">=</span> <span class="st">"Q"</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                                         distance_on_edge <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                                         u <span class="op">=</span> <span class="va">u</span><span class="op">)</span>,</span>
<span>                       normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"u"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-13-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can also sample the field at the mesh on the graph as follows:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, type <span class="op">=</span> <span class="st">"mesh"</span>, method <span class="op">=</span> <span class="st">"Q"</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">u</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-14-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Since <span class="math inline">\(\alpha=1\)</span>, these sample
paths are continuous but not differentiable. To visualize the
correlation structure of the field, we can compute and plot the
covariances between some point and all other points in the graph as
follows:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/covariance_alpha1_mesh.html">covariance_alpha1_mesh</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">200</span>, <span class="fl">0.1</span><span class="op">)</span>, kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, </span>
<span>                            graph <span class="op">=</span> <span class="va">graph</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">C</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-15-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To obtain a field with differentiable sample paths, we can change to
<span class="math inline">\(\alpha=2\)</span> in the code above.</p>
</div>
<div class="section level4">
<h4 id="inference">Inference<a class="anchor" aria-label="anchor" href="#inference"></a>
</h4>
<p>In the following examples we will consider models without replicates.
Please, see the <a href="random_fields.html">Gaussian random fields on
metric graphs</a> vignette for examples with replicates.</p>
<p>Suppose that we have data of the form <span class="math display">\[
y_i = \beta_1\text{lon}(s_i) +  \beta_1\text{lat}(s_i) +  u(s_i) +
\varepsilon_i, \quad i=1,\ldots,n
\]</span> where <span class="math inline">\(s_i\in \Gamma\)</span> are
observation locations, lon and lat are the longitude and latitude of
these locations, <span class="math inline">\(\beta_1,\beta_2\)</span>
are some regression coefficients, and <span class="math inline">\(\varepsilon_i\)</span> are independent centered
Gaussian variables <span class="math inline">\(N(0,\sigma_e^2)\)</span>
representing measurement noise.</p>
<p>Let us create such observations, clear the current data in the graph,
and finally add the data on the graph:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># The graph has very small edges, so we will use the </span></span>
<span><span class="co"># Q method to improve numerical stability</span></span>
<span></span>
<span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fl">0.2</span> <span class="co"># range parameter</span></span>
<span><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fl">8</span><span class="op">*</span><span class="fl">0.5</span><span class="op">)</span><span class="op">/</span><span class="va">r</span></span>
<span><span class="va">sigma_e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span></span>
<span><span class="va">n.obs.1</span> <span class="op">&lt;-</span> <span class="fl">400</span> <span class="co"># all edges</span></span>
<span><span class="va">n.obs.2</span> <span class="op">&lt;-</span> <span class="fl">100</span> <span class="co"># long edges</span></span>
<span></span>
<span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="va">n.obs.1</span> <span class="op">+</span> <span class="va">n.obs.2</span></span>
<span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs.1</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs.1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Let us now add some locations on long edges:</span></span>
<span><span class="va">long.edges</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">edge_lengths</span> <span class="op">&gt;</span> <span class="fl">0.5</span></span>
<span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">obs.loc</span>, <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">long.edges</span><span class="op">)</span>, <span class="va">n.obs.2</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs.2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, PtE <span class="op">=</span> <span class="va">obs.loc</span>, method <span class="op">=</span> <span class="st">"Q"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">beta0</span> <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span><span class="va">beta1</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="va">beta2</span> <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="va">lonlat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span>
<span><span class="va">scaled_lonlat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale</a></span><span class="op">(</span><span class="va">lonlat</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">beta0</span> <span class="op">+</span> <span class="va">beta1</span> <span class="op">*</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">beta2</span> <span class="op">*</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">u</span> <span class="op">+</span> <span class="va">sigma_e</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span></span>
<span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                   distance_on_edge <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                   lon <span class="op">=</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                   lat <span class="op">=</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                   y <span class="op">=</span> <span class="va">y</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y</span>, X_loc <span class="op">=</span> <span class="va">obs.loc</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-16-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Our goal now is to fit a linear mixed-effects model on this data
assuming a Whittle-Mat'ern latent model with <span class="math inline">\(\alpha=1\)</span>. To this end, we can use the
<code><a href="../reference/graph_lme.html">graph_lme()</a></code> function.</p>
<p>If we do not specify the model, it will fit a linear regression
model. So, let us first fit a simple linear regression model to
illustrate:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_lm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span><span class="op">)</span></span></code></pre></div>
<p>We can get the summary:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_lm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Linear regression model</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) -1.07809    0.01696  -63.57   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          1.02701    0.01721   59.66   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          1.98526    0.01721  115.33   &lt;2e-16 ***</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No random effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##  std. dev </span></span>
<span><span class="co">## 0.3792328 </span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -223.1622</span></span></code></pre>
<p>Let us now fit the linear mixed-effects model with a Whittle-Mat'ern
latent model with <span class="math inline">\(\alpha=1\)</span>. To this
end, we can either specify the <code>model</code> argument as
<code>'alpha1'</code> or as the following list:
<code>list(type = 'WhittleMatern', alpha = 1)</code>. The list makes it
easier to understand which model is being chosen as a random effect,
however, it makes it longer, and less convenient, to write. Let us use
the simplified form:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="st">'alpha1'</span><span class="op">)</span></span></code></pre></div>
<p>Let us get the summary of the result:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = "alpha1")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept) -1.07263   0.02710  -39.58   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          1.01327   0.02664   38.04   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          2.00059   0.02800   71.45   &lt;2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma  1.99762   0.06982  28.610</span></span>
<span><span class="co">## range  0.17632   0.17718   0.995</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev   0.1046    0.1400   0.747</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -127.1997 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 25</span></span></code></pre>
<p>We will now compare with the true values of the random effects:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma_e_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">measurement_error</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">sigma_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">range_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">results</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>sigma_e <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma_e</span>, <span class="va">sigma_e_est</span><span class="op">)</span>,</span>
<span>                      sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">sigma_est</span><span class="op">)</span>,</span>
<span>                      range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">r</span>, <span class="va">range_est</span><span class="op">)</span>,</span>
<span>                      row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimate"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">results</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##            sigma_e    sigma     range</span></span>
<span><span class="co">## Truth    0.1000000 2.000000 0.2000000</span></span>
<span><span class="co">## Estimate 0.1045935 1.997625 0.1763205</span></span></code></pre>
<p>Given these estimated parameters, we can now do kriging to estimate
the field at locations in the graph. As an example, we now obtain
predictions on the regular mesh that we previously constructed. First,
we obtain the covariates on the mesh locations.</p>
<p>Now, we can compute the predictions for <span class="math inline">\(y\)</span>. First, let us compute the posterior
mean for the field at the observation locations and plot the residuals
between the posterior means and the field:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res</span>, data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_u</span><span class="op">$</span><span class="va">mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-22-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now obtain predictions of the field on a mesh of equally
spaced nodes on the graph. First, let us create the mesh and
<code>data.frame</code>:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">50</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">lonlat_mesh</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">)</span></span>
<span><span class="va">scaled_lonlat_mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale</a></span><span class="op">(</span><span class="va">lonlat_mesh</span>, </span>
<span>                            center <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">scaled_lonlat</span>, <span class="st">"scaled:center"</span><span class="op">)</span>,</span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">scaled_lonlat</span>, <span class="st">"scaled:scale"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data_mesh_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>lon <span class="op">=</span> <span class="va">scaled_lonlat_mesh</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                              lat <span class="op">=</span> <span class="va">scaled_lonlat_mesh</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>,</span>
<span>                              edge_number <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                              distance_on_edge <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co"># Let us remove duplicated vertices (that were created due to being too close)</span></span>
<span><span class="va">data_mesh_pred</span> <span class="op">&lt;-</span> <span class="va">data_mesh_pred</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/duplicated.html" class="external-link">duplicated</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">)</span>,<span class="op">]</span></span></code></pre></div>
<p>Now, let us obtain the predictions. We can obtain estimates for the
latent field by setting <code>only_latent</code> to
<code>TRUE</code>:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res</span>, data<span class="op">=</span><span class="va">data_mesh_pred</span>, normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">u_est</span> <span class="op">&lt;-</span> <span class="va">pred</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">u_est</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-24-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Finally, let us obtain predictions for the observed values on the
mesh. In this case we set <code>only_latent</code> to
<code>FALSE</code>:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res</span>, data<span class="op">=</span><span class="va">data_mesh_pred</span>, normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">y_est</span> <span class="op">&lt;-</span> <span class="va">pred_y</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">y_est</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-25-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The same procedure can be done with <span class="math inline">\(\alpha = 2\)</span>. One can also estimate <span class="math inline">\(\alpha\)</span> from data as described in the
vignette <a href="fem_models.html">Whittle–Matérn fields with general
smoothness</a>.</p>
</div>
</div>
<div class="section level3">
<h3 id="isotropic-gaussian-fields">Isotropic Gaussian fields<a class="anchor" aria-label="anchor" href="#isotropic-gaussian-fields"></a>
</h3>
<p>For metric graphs with Euclidean edges, <a href="https://projecteuclid.org/journals/annals-of-statistics/volume-48/issue-4/Isotropic-covariance-functions-on-graphs-and-their-edges/10.1214/19-AOS1896.full" class="external-link"><span class="citation">Anderes, Møller, and Rasmussen (2020)</span></a> showed
that one can define valid Gaussian processes through various isotropic
covariance functions if the distances between points are measured in the
so-called resistance metric <span class="math inline">\(d(\cdot,\cdot)\)</span>. One example of a valid
covariance function is the isotropic exponential covariance function
<span class="math display">\[
r(d(s,t)) = \sigma^2\exp(-\kappa d(s,t)).
\]</span> This covariance is very similar to that of the Whittle–Mat'ern
fields with <span class="math inline">\(\alpha = 1\)</span>. Between the
two, we recommend using the Whittle–Matérn model since it has Markov
properties which makes inference much faster. Further, that covariance
is well-defined for any compact metric graph, whereas the isotropic
exponential is only guaranteed to be positive definite if the graph has
Euclidean edges. See <a href="https://arxiv.org/abs/2304.10372" class="external-link"><span class="citation">Bolin, Simas, and Wallin (2023)</span></a> for further
comparisons.</p>
<p>However, let us now illustrate how to use it for the data that we
generated above. To work with the covariance function, the only
cumbersome thing is to compute the metric. The <code>metric_graph</code>
class has built in support for this, and we can obtain the distances
between the observation locations as</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">compute_resdist</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>However, if the goal is to fit a model using this covariance
function, there is no need for the user to compute it. It is done
internally when one uses the <code><a href="../reference/graph_lme.html">graph_lme()</a></code> function. We need
to set the <code>model</code> argument in <code><a href="../reference/graph_lme.html">graph_lme()</a></code> as a
list with type <code>"isoCov"</code> (there is no need to add additional
arguments, as the exponential covariance is the default). Let us fit a
linear regression model with a random effect given by a Gaussian field
with an isotropic exponential covariance function (alternatively, one
can also write <code>model = 'isoExp'</code>):</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"isoCov"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_exp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Covariance-based model</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = list(type = "isoCov"))</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept) -1.07718   0.03963  -27.18   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          0.99376   0.03076   32.31   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          1.98674   0.03610   55.04   &lt;2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma  0.38961   0.05266   7.398</span></span>
<span><span class="co">## kappa 15.07010   0.18452  81.673</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev   0.1004    0.1441   0.697</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -133.5132 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 31</span></span></code></pre>
<p>Let us now compute the posterior mean for the field at the
observation locations and plot the residuals between the field and the
posterior means of the field:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u_est_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_exp</span>, data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">u_est_exp</span><span class="op">$</span><span class="va">mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-28-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To perform kriging prediction to other locations, one can use the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method along with a <code>data.frame</code>
containing the locations in which one wants to obtain predictions and
the corresponding covariate values at these locations. In this example
we will use the <code>data_mesh_pred</code> from the previous example.
We start by obtaining predictions for the latent model:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_exp</span>, data <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">u_est_exp</span> <span class="op">&lt;-</span> <span class="va">pred_exp</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">u_est_exp</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-29-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Finally, let us estimated the observed values at the mesh
locations:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_exp_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_exp</span>, data <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">y_est_exp</span> <span class="op">&lt;-</span> <span class="va">pred_exp_y</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">y_est_exp</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-30-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="models-based-on-the-graph-laplacian">Models based on the Graph Laplacian<a class="anchor" aria-label="anchor" href="#models-based-on-the-graph-laplacian"></a>
</h3>
<p>A final set of Gaussian models that is supported by
<code>MetricGraph</code> is the Matérn type processes based on the graph
Laplacian introduced by <a href="http://proceedings.mlr.press/v130/borovitskiy21a/borovitskiy21a.pdf" class="external-link"><span class="citation">Borovitskiy et al. (2021)</span></a>. These are
multivariate Gaussian distributions, which are defined in the vertices
through the equation <span class="math display">\[
(\kappa^2\mathbf{I} - \mathbf{\Delta}_\Gamma)^{\alpha/2}\mathbf{u} =
\mathbf{W}
\]</span> Here <span class="math inline">\(\mathbf{W}\sim
N(0,\sigma^2\mathbf{I})\)</span> is a vector with independent Gaussian
variables and <span class="math inline">\(\mathbf{\Delta}_\Gamma\)</span> is the graph
Laplacian. Further, <span class="math inline">\(\mathbf{u}\)</span> is a
vector with the values of the process in the vertices of <span class="math inline">\(\Gamma\)</span>, which by definition has precision
matrix <span class="math display">\[
\mathbf{Q} = \sigma^{-2}(\kappa^2\mathbf{I} -
\mathbf{\Delta}_\Gamma)^{\alpha}
\]</span> Thus, to define these models, the only “difficult” thing is to
compute the graph Laplacian. The (weighted) graph Laplacian, where the
weights are specified by the edge lengths can be computed by the
function <code>compute_laplacian()</code> in the
<code>metric_graph</code> object. Suppose that we want to fit the data
that we defined above with this model. We can use the
<code><a href="../reference/graph_lme.html">graph_lme()</a></code> function. Also, observe that there is no need
to use the <code>compute_laplacian()</code> function, as it is done
internally. We now set the <code>model</code> argument as a list with
the <code>type</code> being <code>"GraphLaplacian"</code>
(alternatively, one can also write <code>model = 'GL1'</code>) to obtain
a graph Laplacian model with <code>alpha=1</code>:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_gl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"GraphLaplacian"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_gl</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - graph Laplacian SPDE with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = list(type = "GraphLaplacian"))</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept) -1.07427   0.02762  -38.89   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          1.03223   0.02856   36.15   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          1.98959   0.02826   70.41   &lt;2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma  2.06340   0.07544   27.35</span></span>
<span><span class="co">## range  2.84172   0.15065   18.86</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev   0.1038    0.1433   0.724</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -130.2486 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 30</span></span></code></pre>
<p>We can now obtain prediction at the observed locations by using the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method. Let us compute the posterior mean for the
field at the observation locations and plot the residuals between the
field and the posterior means of the field:</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_u_GL</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl</span>, data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_u_GL</span><span class="op">$</span><span class="va">mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-32-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Now, if we do predictions outside of the observation locations on a
graph Laplacian model, we need to modify the graph. This modifies the
model in its entirety. Thus, we need to refit the model with all the
observation locations we want to do predictions. However, if we use the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method with observations outside of the
observation locations, the <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> will return
predictions together with a <code>warning</code> that one should refit
the model to obtain proper predictions:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl</span>, data <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in predict.graph_lme(res_gl, data = data_mesh_pred, normalized = TRUE,</span></span>
<span><span class="co">## : There are prediction locations outside of the observation locations. Refit</span></span>
<span><span class="co">## the model with all the locations you want to obtain predictions.</span></span></code></pre>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u_est_GL</span> <span class="op">&lt;-</span> <span class="va">pred_GL</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">u_est_GL</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-33-1.png" width="700" style="display: block; margin: auto;">
and here the (incorrect way of obtaining) predictions of the observed
data:</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl</span>, data <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in predict.graph_lme(res_gl, data = data_mesh_pred, normalized = TRUE,</span></span>
<span><span class="co">## : There are prediction locations outside of the observation locations. Refit</span></span>
<span><span class="co">## the model with all the locations you want to obtain predictions.</span></span></code></pre>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_est_GL</span> <span class="op">&lt;-</span> <span class="va">pred_GL_y</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">y_est_GL</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-34-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now refit the model with all the locations we want to obtain
predictions. Let us create a new data set with all the original
locations and all the locations we want to obtain predictions (with
<code>y=NA</code> at the locations we want to obtain predictions):</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_mesh_temp</span> <span class="op">&lt;-</span> <span class="va">data_mesh_pred</span></span>
<span><span class="va">data_mesh_temp</span><span class="op">[[</span><span class="st">"y"</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">data_mesh_pred</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">new_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/sp/man/merge.html" class="external-link">merge</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">data_mesh_temp</span>, all <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us clone the graph and add the new data:</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph_pred</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph_pred</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph_pred</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">new_data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us now fit the model with all data:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_gl_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph_pred</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"GraphLaplacian"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_gl_pred</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - graph Laplacian SPDE with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph_pred, model = list(type = "GraphLaplacian"))</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept) -1.08552   0.02248  -48.29   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          1.02556   0.01923   53.32   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          1.98979   0.01948  102.16   &lt;2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma   1.2413    0.2065   6.012</span></span>
<span><span class="co">## range   1.7665    0.3039   5.812</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.28337   0.08339   3.398</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -209.5545 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 71</span></span></code></pre>
<p>One should compare the estimates with the ones obtained in the model
without the prediction locations.</p>
<p>Let us first compute the residual between the latent field and the
posterior means at the observation locations:</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_u_GL_full</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl_pred</span>, data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_u_GL_full</span><span class="op">$</span><span class="va">mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-38-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now obtain predictions at the desired locations:</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_full</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl_pred</span>, data <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">u_est_GL_full</span> <span class="op">&lt;-</span> <span class="va">pred_GL_full</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">u_est_GL_full</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-39-1.png" width="700" style="display: block; margin: auto;">
and here the correct way of obtaining predictions of the observed data
at the desired locations:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_y_full</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl_pred</span>, data <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span>, only_latent <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">y_est_GL_full</span> <span class="op">&lt;-</span> <span class="va">pred_GL_y_full</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span><span class="va">y_est_GL_full</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-40-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="the-inlabru-interface">The <code>inlabru</code> interface<a class="anchor" aria-label="anchor" href="#the-inlabru-interface"></a>
</h2>
<p>In this vignette we will present our <code>inlabru</code> interface
to Whittle–Matérn fields. The <code>MetricGraph</code> package also has
a similar interface to<code>R-INLA</code>, which is described in detail
in the <a href="inla_interface.html">INLA interface of Whittle–Matérn
fields</a> vignette.</p>
<div class="section level3">
<h3 id="basic-setup-and-estimation">Basic setup and estimation<a class="anchor" aria-label="anchor" href="#basic-setup-and-estimation"></a>
</h3>
<p>We will use the same graph and data as before. The
<code>inlabru</code> implementation requires the observation locations
to be added to the graph. However, note that for the Whittle–Matérn
fields (contrary to the models based on the graph Laplacian) we are not
changing the model by adding vertices at observation locations. We
already created the extended graph above, so we can use that. Now, we
load <code>INLA</code> and <code>inlabru</code> packages. We will also
need to create the <code>inla</code> model object with the
<code>graph_spde</code> function. By default we have
<code>alpha=1</code>.</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">INLA</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="http://www.inlabru.org" class="external-link">inlabru</a></span><span class="op">)</span></span>
<span><span class="va">spde_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_spde.html">graph_spde</a></span><span class="op">(</span><span class="va">graph</span><span class="op">)</span></span></code></pre></div>
<p>Recall that the data is already on the graph object (from the
previous models above). Now, we create <code>inlabru</code>’s component,
which is a formula-like object:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cmp</span> <span class="op">&lt;-</span> <span class="va">y</span> <span class="op">~</span> <span class="fu">Intercept</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span> <span class="op">+</span> <span class="fu">field</span><span class="op">(</span><span class="va">loc</span>, model <span class="op">=</span> <span class="va">spde_model</span><span class="op">)</span></span></code></pre></div>
<p>This formula is very simple since we are not assuming mean zero, so
that we do not need an intercept, and we do not have any other
covariates or model components. However, the setup is exactly the same
for more complicated models, with the only exception that we would have
more terms in the formla. Now, we directly fit the model:</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spde_bru_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/inlabru/reference/bru.html" class="external-link">bru</a></span><span class="op">(</span><span class="va">cmp</span>, data<span class="op">=</span><span class="fu"><a href="../reference/graph_data_spde.html">graph_data_spde</a></span><span class="op">(</span><span class="va">spde_model</span>, loc <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in inla.model.properties.generic(inla.trim.family(model), mm[names(mm) == : Model 'cgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time.</span></span>
<span><span class="co">##   Use this model with extra care!!! Further warnings are disabled.</span></span></code></pre>
<p>The advantage / difference between the estimates we obtain here and
those above is that the <code>bru</code> function does full Bayesian
inference (assuming priors for the model parameters). We used the
default priors when creating the <code>graph_spde</code> model (see the
help text for that function). The advantage now is that we do not only
obtain point estimates but entire posterior distributions for the
parameters. To view the estimates we can use the
<code><a href="../reference/spde_metric_graph_result.html">spde_metric_graph_result()</a></code> function, then taking a
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>:</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spde_bru_result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde_metric_graph_result.html">spde_metric_graph_result</a></span><span class="op">(</span><span class="va">spde_bru_fit</span>, </span>
<span>                    <span class="st">"field"</span>, <span class="va">spde_model</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">spde_bru_result</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          mean        sd 0.025quant 0.5quant 0.975quant     mode</span></span>
<span><span class="co">## sigma 2.00669 0.1372390   1.751330 2.001760   2.290100 1.991630</span></span>
<span><span class="co">## range 0.18424 0.0330468   0.128136 0.181232   0.257544 0.174975</span></span></code></pre>
<p>Here we are showing the estimate of the practical correlation range
(<span class="math inline">\(2/\kappa\)</span>) instead of <span class="math inline">\(\kappa\)</span> since that is easier to interpret.
We now compare the means of the estimated values with the true
values:</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">result_df_bru</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    parameter <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"std.dev"</span>, <span class="st">"range"</span><span class="op">)</span>,</span>
<span>    true <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="fl">2</span> <span class="op">/</span> <span class="va">kappa</span><span class="op">)</span>,</span>
<span>    mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.sigma</span><span class="op">$</span><span class="va">mean</span>,</span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.range</span><span class="op">$</span><span class="va">mean</span></span>
<span>    <span class="op">)</span>,</span>
<span>    mode <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.sigma</span><span class="op">$</span><span class="va">mode</span>,</span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.range</span><span class="op">$</span><span class="va">mode</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">result_df_bru</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   parameter true     mean      mode</span></span>
<span><span class="co">## 1   std.dev  2.0 2.006688 1.9916300</span></span>
<span><span class="co">## 2     range  0.2 0.184240 0.1749753</span></span></code></pre>
<p>We can also plot the posterior marginal densities with the help of
the <code><a href="../reference/gg_df.metric_graph_spde_result.html">gg_df()</a></code> function:</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">posterior_df_bru_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gg_df.metric_graph_spde_result.html">gg_df</a></span><span class="op">(</span><span class="va">spde_bru_result</span><span class="op">)</span></span>
<span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">posterior_df_bru_fit</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html" class="external-link">geom_line</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html" class="external-link">facet_wrap</a></span><span class="op">(</span><span class="op">~</span><span class="va">parameter</span>, scales <span class="op">=</span> <span class="st">"free"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">labs</a></span><span class="op">(</span>y <span class="op">=</span> <span class="st">"Density"</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-46-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="kriging-with-the-inlabru-implementation">Kriging with the <code>inlabru</code> implementation<a class="anchor" aria-label="anchor" href="#kriging-with-the-inlabru-implementation"></a>
</h3>
<p>Unfortunately, our <code>inlabru</code> implementation is not
compatible with <code>inlabru</code>’s <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method.
This has to do with the nature of the metric graph’s object.</p>
<p>To this end, we have provided a different <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>
method. We will now show how to do kriging with the help of this
function.</p>
<p>We begin by creating a data list with the positions we want the
predictions. In this case, we will want the predictions on a mesh.</p>
<p>The positions we want are the mesh positions, which we have in the
<code>data.frame</code> for the previous models. The function
<code><a href="../reference/graph_bru_process_data.html">graph_bru_process_data()</a></code> helps us into converting that
<code>data.frame</code> to an <code>inlabru</code> friendly format for
dealing with metric graphs:</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_bru_process_data.html">graph_bru_process_data</a></span><span class="op">(</span><span class="va">data_mesh_pred</span>, loc <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span></span></code></pre></div>
<p>We can now obtain the predictions by using the <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>
method. Observe that our <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method for graph models
is a bit different from <code>inlabru</code>’s standard
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method. Indeed, the first argument is the model
created with the <code><a href="../reference/graph_spde.html">graph_spde()</a></code> function, the second is
<code>inlabru</code>’s component, and the remaining is as done with the
standard <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method in <code>inlabru</code>.</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">field_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">spde_model</span>, </span>
<span>                                <span class="va">cmp</span>,</span>
<span>                                <span class="va">spde_bru_fit</span>, </span>
<span>                                data <span class="op">=</span> <span class="va">data_list</span>,</span>
<span>                                formula <span class="op">=</span> <span class="op">~</span> <span class="va">field</span><span class="op">)</span></span></code></pre></div>
<p>Let us plot the predictions of the latent field:</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">field_pred</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-49-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Finally, let us plot predictions of the observed data at the mesh
locations:</p>
<div class="sourceCode" id="cb70"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obs_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">spde_model</span>, </span>
<span>                                <span class="va">cmp</span>,</span>
<span>                                <span class="va">spde_bru_fit</span>, </span>
<span>                                data <span class="op">=</span> <span class="va">data_list</span>,</span>
<span>                                formula <span class="op">=</span> <span class="op">~</span> <span class="va">Intercept</span> <span class="op">+</span> <span class="va">lat</span> <span class="op">+</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">field</span><span class="op">)</span></span></code></pre></div>
<p>Let us plot the predictions:</p>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">obs_pred</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-51-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-Anderes2020" class="csl-entry">
Anderes, Ethan, Jesper Møller, and Jakob G Rasmussen. 2020.
<span>“Isotropic Covariance Functions on Graphs and Their Edges.”</span>
<em>Annals of Statistics</em>.
</div>
<div id="ref-inlabru2019" class="csl-entry">
Bachl, Fabian E., Finn Lindgren, David L. Borchers, and Janine B.
Illian. 2019. <span>“Inlabru an R Package for Bayesian Spatial Modelling
from Ecological Survey Data.”</span> <em>Methods in Ecology and
Evolution</em>.
</div>
<div id="ref-sppackage" class="csl-entry">
Bivand, Roger S., Edzer Pebesma, and Virgilio Gomez-Rubio. 2013.
<em>Applied Spatial Data Analysis with R</em>. Springer, NY.
</div>
<div id="ref-BSW2022a" class="csl-entry">
Bolin, David, Alexandre B. Simas, and Jonas Wallin. 2022.
<span>“Gaussian Whittle–Matérn Fields on Metric Graphs.”</span>
<em>arXiv:2205.06163</em>.
</div>
<div id="ref-BSW2022b" class="csl-entry">
———. 2023. <span>“Statistical Properties of Gaussian Whittle–Matérn
Fields on Metric Graphs.”</span> <em>arXiv:2304.10372</em>.
</div>
<div id="ref-Borovitskiy2021" class="csl-entry">
Borovitskiy, Viacheslav, Iskander Azangulov, Alexander Terenin, Peter
Mostowsky, Marc Deisenroth, and Nicolas Durrande. 2021. <span>“Matérn
Gaussian Processes on Graphs.”</span> <em>International Conference on
Artificial Intelligence and Statistics</em>.
</div>
<div id="ref-LindgrenRue2015" class="csl-entry">
Lindgren, Finn, and Haavard Rue. 2015. <span>“Bayesian Spatial Modelling
with R-INLA.”</span> <em>Journal of Statistical Software</em>.
</div>
<div id="ref-plotlypackage" class="csl-entry">
Sievert, Carson. 2020. <em>Interactive Web-Based Data Visualization with
R, Plotly, and Shiny</em>. Chapman and Hall/CRC.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by David Bolin, Jonas Wallin, Alexandre Simas.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
