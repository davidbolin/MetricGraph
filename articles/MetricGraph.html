<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>MetricGraph: Random Fields on Metric Graphs • MetricGraph</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Roboto_Slab-0.4.9/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="MetricGraph: Random Fields on Metric Graphs">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">MetricGraph</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.3.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="active nav-item"><a class="nav-link" href="../articles/MetricGraph.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Functions</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-vignettes" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Vignettes</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-vignettes">
<li><a class="dropdown-item" href="../articles/metric_graph.html">Working with metric graphs</a></li>
    <li><a class="dropdown-item" href="../articles/random_fields.html">Gaussian random fields on metric graphs</a></li>
    <li><a class="dropdown-item" href="../articles/metric_graph_data.html">Data manipulation on metric graphs</a></li>
    <li><a class="dropdown-item" href="../articles/inlabru_interface.html">inlabru interface of Whittle--Matern fields</a></li>
    <li><a class="dropdown-item" href="../articles/inla_interface.html">INLA interface of Whittle--Matern fields</a></li>
    <li><a class="dropdown-item" href="../articles/fem_models.html">Whittle--Matern fields with general smoothness</a></li>
    <li><a class="dropdown-item" href="../articles/pointprocess.html">Log-Gaussian Cox processes on metric graphs</a></li>
    <li><a class="dropdown-item" href="../articles/comparison.html">Comparison of different models using real data</a></li>
    <li><a class="dropdown-item" href="../articles/isotropic_noneuclidean.html">On isotropic covariances on metric graphs with non-Euclidean edges</a></li>
    <li><a class="dropdown-item" href="../articles/multi_likelihood.html">An example with multiple likelihoods in INLA and inlabru</a></li>
  </ul>
</li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/davidbolin/MetricGraph/discussions"><span class="fa fa-comments-o"></span> Discussions</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/davidbolin/MetricGraph/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://twitter.com/jdavidbolin" aria-label="Twitter"><span class="fa fa-twitter"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>MetricGraph: Random Fields on Metric Graphs</h1>
                        <h4 data-toc-skip class="author">David Bolin,
Alexandre B. Simas, and Jonas Wallin</h4>
            
            <h4 data-toc-skip class="date">Created: 2022-11-26. Last
modified: 2024-08-07.</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/davidbolin/MetricGraph/blob/devel/vignettes/MetricGraph.Rmd" class="external-link"><code>vignettes/MetricGraph.Rmd</code></a></small>
      <div class="d-none name"><code>MetricGraph.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>There has lately been much interest in statistical modeling of data
on compact metric graphs such as street or river networks based on
Gaussian random fields.</p>
<p>The <code>R</code> package <code>MetricGraph</code> contains
functions for working with data and random fields on compact metric
graphs. The main functionality is contained in the
<code>metric_graph</code> class, which is used for specifying metric
graphs, adding data to them, visualization, and other basic functions
that are needed for working with data and random fields on metric
graphs. The package also implements three types of Gaussian processes on
metric graphs: The Whittle–Matérn fields introduced by <a href="https://arxiv.org/abs/2205.06163" class="external-link"><span class="citation">Bolin,
Simas, and Wallin (2024)</span></a> and <a href="https://arxiv.org/abs/2304.10372" class="external-link"><span class="citation">Bolin,
Simas, and Wallin (2023)</span></a>, Gaussian processes with isotropic
covariance functions <a href="https://projecteuclid.org/journals/annals-of-statistics/volume-48/issue-4/Isotropic-covariance-functions-on-graphs-and-their-edges/10.1214/19-AOS1896.full" class="external-link"><span class="citation">Anderes, Møller, and Rasmussen (2020)</span></a>, and
Gaussian models based on the graph Laplacian <a href="http://proceedings.mlr.press/v130/borovitskiy21a/borovitskiy21a.pdf" class="external-link"><span class="citation">Borovitskiy et al. (2021)</span></a>.</p>
<p>Basic statistical tasks such as likelihood evaluation and prediction
is implemented for these three types of models in
<code>MetricGraph</code>. Further, the package also contains interfaces
to <code>R-INLA</code> <a href="https://www.jstatsoft.org/article/view/v063i19" class="external-link"><span class="citation">Lindgren and Rue (2015)</span></a>, package available
from <a href="https://www.r-inla.org/" class="external-link">http://R-INLA. org/download/</a>
and <code>inlabru</code> <a href="https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.13168" class="external-link"><span class="citation">Bachl et al. (2019)</span></a> that facilitates using
those packages for full Bayesian inference of general Latent Gaussian
Models (LGMs) that includes Whittle–Matérn fields on metric graphs.</p>
<!-- The package is available to install from the Comprehensive R Archive
Network (CRAN) at \url{https://CRAN.R-project.org/package=MetricGraph}. A development version of the package is available via the repository [https://github.com/davidbolin/MetricGraph](https://github.com/davidbolin/MetricGraph). The development version is updated more frequently, and can easily be installed directly in R as described on the repository homepage.  -->
<p>The package is available to install via the repository <a href="https://github.com/davidbolin/MetricGraph" class="external-link">https://github.com/davidbolin/MetricGraph</a>.</p>
<p>The following sections describe the main functionality of the package
and summarizes some of the required theory. Section 2 introduces metric
graphs and the <code>metric_graph</code> class, Section 3 shows how to
work with random fields on metric graphs, and Section 4 introduces the
<code>inlabru</code> interface of the package through an application to
real data. For a complete introduction to the functionality of the
package, we refer to the Vignettes available on the package homepage <a href="https://davidbolin.github.io/MetricGraph/">https://davidbolin.github.io/MetricGraph/</a>.
In particular, that contains an introduction to the <code>INLA</code>
interface, the implementation of Whittle–Matérn fields with general
smoothness, and further details and examples for all methods in the
package.</p>
</div>
<div class="section level2">
<h2 id="the-metric_graph-class">The <code>metric_graph</code> class<a class="anchor" aria-label="anchor" href="#the-metric_graph-class"></a>
</h2>
<p>A compact metric graph
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>
consists of a set of finitely many vertices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒱</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>v</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{V}=\{v_i\}</annotation></semantics></math>
and a finite set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ℰ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>e</mi><mi>j</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\mathcal{E}=\{e_j\}</annotation></semantics></math>
of edges connecting the vertices. Each edge
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>
is defined by a pair of vertices
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo>,</mo><msub><mi>v</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(v_i,v_k)</annotation></semantics></math>
and a finite length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mi>e</mi></msub><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>∞</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">l_e \in (0,\infty)</annotation></semantics></math>.
An edge in the graph is a curve parametrized by arc-length, and a
location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">s\in \Gamma</annotation></semantics></math>
is a position on an edge, and can thus be represented as a touple
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>e</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(e,t)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><msub><mi>l</mi><mi>e</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">t\in[0,l_e]</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="basic-constructions">Basic constructions<a class="anchor" aria-label="anchor" href="#basic-constructions"></a>
</h3>
<p>A metric graph is represented in the <code>MetricGraph</code> package
through the class <code>metric_graph</code>. An object of this class can
be constructed in two ways. The first is to specify the vertex matrix
<code>V</code> and the edge matrix <code>E</code>, and it is then
assumed that all edges are straight lines. The second, more flexible,
option is to specify the object from a <code>SpatialLines</code> object
using the <code>sp</code> package <span class="citation">(Bivand,
Pebesma, and Gomez-Rubio 2013)</span>.</p>
<p>To illustrate this, we use the <code>osmdata</code> package to
download data from OpenStreetMap. In the following code, we extract the
streets on the campus of King Abdullah University of Science and
Technology (KAUST) as a <code>SpatialLines</code> object:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">call</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://docs.ropensci.org/osmdata/reference/opq.html" class="external-link">opq</a></span><span class="op">(</span>bbox <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">39.0884</span>, <span class="fl">22.33</span>, <span class="fl">39.115</span>, <span class="fl">22.3056</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">call</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://docs.ropensci.org/osmdata/reference/add_osm_feature.html" class="external-link">add_osm_feature</a></span><span class="op">(</span><span class="va">call</span>, key <span class="op">=</span> <span class="st">"highway"</span>,value<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"motorway"</span>,</span>
<span>                                                      <span class="st">"primary"</span>,<span class="st">"secondary"</span>,</span>
<span>                                                      <span class="st">"tertiary"</span>,</span>
<span>                                                      <span class="st">"residential"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://docs.ropensci.org/osmdata/reference/osmdata_sp.html" class="external-link">osmdata_sp</a></span><span class="op">(</span><span class="va">call</span><span class="op">)</span></span>
<span><span class="va">lines</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://edzer.github.io/sp/reference/SpatialLines.html" class="external-link">SpatialLines</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">osm_lines</span><span class="op">@</span><span class="va">lines</span><span class="op">)</span></span></code></pre></div>
<p>We can now create the metric graph as follows. In the command we set
the argument <code>longlat = TRUE</code> since the coordinates of the
vertices are given in Longitude and Latitude.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="va"><a href="../reference/metric_graph.html">metric_graph</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span><span class="va">lines</span>, longlat <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>vertex_size <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-2-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can note the warning that the graph is not connected, so let us
create a <code>graph_components</code> object that contains all
connected components as graphs and then extract the largest connected
component to work with</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graphs</span> <span class="op">&lt;-</span> <span class="va"><a href="../reference/graph_components.html">graph_components</a></span><span class="op">$</span><span class="fu">new</span><span class="op">(</span>edges <span class="op">=</span> <span class="va">lines</span>, longlat <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span> <span class="op">&lt;-</span> <span class="va">graphs</span><span class="op">$</span><span class="fu">get_largest</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-3-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The <code>graph</code> object now contains all important features of
the graph, such as the vertex matrix <code>graph$V</code>, the number of
vertices <code>graph$nV</code>, the edge matrix <code>graph$E</code>,
the number of edges <code>graph$nE</code>, and the vector of all edge
lengths <code>graph$get_edge_lengths()</code> given in the unit km
(since we specified <code>longlat = TRUE</code> in the construction).
Thus, we can obtain the range of the edge lengths in the unit m as:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/range.html" class="external-link">range</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="fu">get_edge_lengths</span><span class="op">(</span>unit<span class="op">=</span><span class="st">"m"</span><span class="op">)</span><span class="op">)</span> </span></code></pre></div>
<pre><code><span><span class="co">## Units: [m]</span></span>
<span><span class="co">## [1]    5.650044 2141.415006</span></span></code></pre>
<p>We will also remove the vertices of degree 2 by using the
<code>prune_vertices()</code> method:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">prune_vertices</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-5-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="understanding-coordinates-on-graphs">Understanding coordinates on graphs<a class="anchor" aria-label="anchor" href="#understanding-coordinates-on-graphs"></a>
</h3>
<p>The locations of the vertices are specified in Euclidean coordinates.
However, when specifying a position on the graph, it is not practical to
work with Euclidean coordinates since not all locations in Euclidean
space are locations on the graph. It is instead better to specify a
location on the graph by the touple
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, t)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
denotes the number of the edge and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is the location on the edge. The location
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
can either be specified as the distance from the start of the edge (and
then takes values between 0 and the length of the edge) or as the
normalized distance from the start of the edge (and then takes values
between 0 and 1). The function <code>coordinates</code> can be used to
convert between coordinates in Euclidean space and locations on the
graph. For example the location at normalized distance 0.2 from the
start of the second edge is:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">0.2</span><span class="op">)</span>, <span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          [,1]     [,2]</span></span>
<span><span class="co">## [1,] 39.11751 22.31934</span></span></code></pre>
<p>The function can also be used to find the closest location on the
graph for a location in Euclidean space:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>XY <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">39.117</span>, <span class="fl">22.319</span><span class="op">)</span>, <span class="fl">1</span>,<span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      [,1]      [,2]</span></span>
<span><span class="co">## [1,]    2 0.2517662</span></span></code></pre>
<p>In this case, the <code>normalized</code> argument decides whether
the returned value should be given in normalized distance or not.</p>
</div>
<div class="section level3">
<h3 id="adding-data-to-the-graph">Adding data to the graph<a class="anchor" aria-label="anchor" href="#adding-data-to-the-graph"></a>
</h3>
<p>Given that we have constructed the metric graph, we can now add data
to it. For further details on data manipulation on metric graphs, see <a href="metric_graph_data.html">Data manipulation on metric graphs</a>. As
an example, let us sample some locations on edges at random and add data
to them in the graph:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">10</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>                   distance_on_edge <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span>,</span>
<span>                   y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"y"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-8-1.png" width="700" style="display: block; margin: auto;"></p>
<p>One should note here that one needs to specify
<code>normalized = TRUE</code> in the function to specify that the
locations are in normalized distance on the edges. If this command is
not set, the distances are interpreted as not being normalized. The
<code>add_observations()</code> function accepts multiple types of
inputs. One scenario that can be common in applications is to have the
data as <code>SpatialPoints</code> objects, and one can then add the
observations as a <code>SpatialPointsDataFrame</code>. To illustrate
this, let us again sample some locations at random on the graph, then
use the function <code>coordinates</code> to transform those to
Longitude Latitude coordinates, which we then use to create a
<code>SpatialPointsDataFrame</code> object which we add to the
graph:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">obs.lonlat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">obs.loc</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">obs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span></span>
<span><span class="va">points</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://edzer.github.io/sp/reference/SpatialPoints.html" class="external-link">SpatialPointsDataFrame</a></span><span class="op">(</span>coords <span class="op">=</span> <span class="va">obs.lonlat</span>,</span>
<span>                                 data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">obs</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span><span class="va">points</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<pre><code><span><span class="co">## Converting data to PtE</span></span></code></pre>
<pre><code><span><span class="co">## This step may take long. If this step is taking too long consider pruning the vertices to possibly obtain some speed up.</span></span></code></pre>
<pre><code><span><span class="co">## [1] y        .coord_x .coord_y</span></span>
<span><span class="co">## &lt;0 rows&gt; (or 0-length row.names)</span></span></code></pre>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"y"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-9-1.png" width="700" style="display: block; margin: auto;"></p>
<p>If we want to replace the data in the object, we can use
<code>clear_observations()</code> to remove all current data.</p>
</div>
<div class="section level3">
<h3 id="working-with-functions-on-metric-graphs">Working with functions on metric graphs<a class="anchor" aria-label="anchor" href="#working-with-functions-on-metric-graphs"></a>
</h3>
<p>When working with data on metric graphs, one often wants to display
functions on the graph. The best way to visualize functions on the graph
is to evaluate them on a fine mesh over the graph and then use
<code>plot_function</code>. To illustrate this procedure, let us
construct a mesh on the graph:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">100</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>mesh<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-10-1.png" width="700" style="display: block; margin: auto;"></p>
<p>In the command <code>build_mesh</code>, the argument <code>h</code>
decides the largest spacing between nodes in the mesh. Above we chose
that as 100m which is a bit coarse. So let us reduce the value of
<code>h</code> to 10m and rebuild the mesh:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">10</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span></code></pre></div>
<p>Suppose now that we want to display the function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mtext mathvariant="normal">Longitude</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mtext mathvariant="normal">Latitude</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(s) = \text{Longitude}(s) - \text{Latitude}(s)</annotation></semantics></math>
on this graph. We then first evaluate it on the vertices of the mesh and
then use the function <code>plot_function</code> to display it:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lon</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">lat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">f</span> <span class="op">&lt;-</span> <span class="va">lon</span> <span class="op">-</span> <span class="va">lat</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">f</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-12-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Alternatively, we can set <code>plotly = TRUE</code> in the plot
command to get a 3D visualization of the function by using the
<code>plotly</code> <span class="citation">(Sievert 2020)</span>
package. When the first argument of <code>plot_function</code> is a
vector, the function assumes that the values in the vector are the
values of the function evaluated at the vertices of the mesh. As an
alternative, one can also provide the first argument as a matrix
consisting of the triplets
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, t, f(i, t))</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
denotes the edge number,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
the location on the edge, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(i, t)</annotation></semantics></math>
the value at that point.</p>
</div>
</div>
<div class="section level2">
<h2 id="random-fields-on-metric-graphs">Random fields on metric graphs<a class="anchor" aria-label="anchor" href="#random-fields-on-metric-graphs"></a>
</h2>
<p>Having defined the metric graph, we are now ready to specify Gaussian
processes on it. In this section, we will briefly cover the three main
types of Gaussian processes that are supported. Be begin by the main
class of models, the Whittle–Matérn fields, then consider Gaussian
processes with isotropic covariance functions, and finally look at
discrete models based on the graph Laplacian.</p>
<div class="section level3">
<h3 id="whittlematérn-fields">Whittle–Matérn fields<a class="anchor" aria-label="anchor" href="#whittlemat%C3%A9rn-fields"></a>
</h3>
<p>The Gaussian Whittle–Matérn fields are specified as solutions to the
stochastic differential equation
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>κ</mi><mn>2</mn></msup><mo>−</mo><mi>Δ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>α</mi><mi>/</mi><mn>2</mn></mrow></msup><mi>τ</mi><mi>u</mi><mo>=</mo><mi>𝒲</mi></mrow><annotation encoding="application/x-tex">
  (\kappa^2 - \Delta)^{\alpha/2} \tau u = \mathcal{W}
</annotation></semantics></math> on the metric graph
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>.
We can work with these models without and approximations if the
smoothness parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
is an integer, and this is what we focus on in this vignette. For
details on the case of a general smoothness parameter, see <a href="fem_models.html">Whittle–Matérn fields with general
smoothness</a>.</p>
<div class="section level4">
<h4 id="sampling">Sampling<a class="anchor" aria-label="anchor" href="#sampling"></a>
</h4>
<p>As an example, let us simulate the field
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>
on the graph using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha = 1</annotation></semantics></math>.
To do so, we again draw some locations at random, then sample the field
at these locations and plot the result</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">1.3</span></span>
<span><span class="va">range</span> <span class="op">&lt;-</span> <span class="fl">0.15</span> <span class="co"># range parameter</span></span>
<span><span class="va">sigma_e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span></span>
<span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">200</span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, PtE <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                                         distance_on_edge <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                                         u <span class="op">=</span> <span class="va">u</span><span class="op">)</span>,</span>
<span>                       normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"u"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-13-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can also sample the field at the mesh on the graph as follows:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, type <span class="op">=</span> <span class="st">"mesh"</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">u</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-14-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha=1</annotation></semantics></math>,
these sample paths are continuous but not differentiable. To visualize
the correlation structure of the field, we can compute and plot the
covariances between some point and all other points in the graph as
follows:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">C</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde_covariance.html">spde_covariance</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">200</span>, <span class="fl">0.1</span><span class="op">)</span>, range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                            graph <span class="op">=</span> <span class="va">graph</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">C</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-15-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To obtain a field with differentiable sample paths, we can change to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha=2</annotation></semantics></math>
in the code above.</p>
</div>
<div class="section level4">
<h4 id="inference">Inference<a class="anchor" aria-label="anchor" href="#inference"></a>
</h4>
<p>In the following examples we will consider models without replicates.
Please, see the <a href="random_fields.html">Gaussian random fields on
metric graphs</a> vignette for examples with replicates.</p>
<p>Suppose that we have data of the form
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><msub><mi>β</mi><mn>1</mn></msub><mtext mathvariant="normal">lon</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>β</mi><mn>1</mn></msub><mtext mathvariant="normal">lat</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>i</mi></msub><mo>,</mo><mspace width="1.0em"></mspace><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">
y_i = \beta_1\text{lon}(s_i) +  \beta_1\text{lat}(s_i) +  u(s_i) + \varepsilon_i, \quad i=1,\ldots,n
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>∈</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">s_i\in \Gamma</annotation></semantics></math>
are observation locations, lon and lat are the longitude and latitude of
these locations,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mn>1</mn></msub><mo>,</mo><msub><mi>β</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\beta_1,\beta_2</annotation></semantics></math>
are some regression coefficients, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\varepsilon_i</annotation></semantics></math>
are independent centered Gaussian variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>e</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">N(0,\sigma_e^2)</annotation></semantics></math>
representing measurement noise.</p>
<p>Let us create such observations, clear the current data in the graph,
and finally add the data on the graph:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">range</span> <span class="op">&lt;-</span> <span class="fl">0.2</span> <span class="co"># range parameter</span></span>
<span><span class="va">sigma_e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span></span>
<span><span class="va">n.obs.1</span> <span class="op">&lt;-</span> <span class="fl">400</span> <span class="co"># all edges</span></span>
<span><span class="va">n.obs.2</span> <span class="op">&lt;-</span> <span class="fl">100</span> <span class="co"># long edges</span></span>
<span></span>
<span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="va">n.obs.1</span> <span class="op">+</span> <span class="va">n.obs.2</span></span>
<span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">graph</span><span class="op">$</span><span class="va">nE</span>, <span class="va">n.obs.1</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs.1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Let us now add some locations on long edges:</span></span>
<span><span class="va">long.edges</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="va">edge_lengths</span> <span class="op">&gt;</span> <span class="fl">0.5</span></span>
<span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">obs.loc</span>, <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">long.edges</span><span class="op">)</span>, <span class="va">n.obs.2</span>, replace<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs.2</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sample_spde.html">sample_spde</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, alpha <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                 graph <span class="op">=</span> <span class="va">graph</span>, PtE <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span>
<span></span>
<span><span class="va">beta0</span> <span class="op">=</span> <span class="op">-</span><span class="fl">1</span></span>
<span><span class="va">beta1</span> <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="va">beta2</span> <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="va">lonlat</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span>
<span><span class="va">scaled_lonlat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale</a></span><span class="op">(</span><span class="va">lonlat</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">beta0</span> <span class="op">+</span> <span class="va">beta1</span> <span class="op">*</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="va">beta2</span> <span class="op">*</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="va">u</span> <span class="op">+</span> <span class="va">sigma_e</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span></span>
<span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>edge_number <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                   distance_on_edge <span class="op">=</span> <span class="va">obs.loc</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                   lon <span class="op">=</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                   lat <span class="op">=</span> <span class="va">scaled_lonlat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                   y <span class="op">=</span> <span class="va">y</span><span class="op">)</span></span>
<span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y</span>, X_loc <span class="op">=</span> <span class="va">obs.loc</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-16-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Our goal now is to fit a linear mixed-effects model on this data
assuming a Whittle-Mat'ern latent model with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha=1</annotation></semantics></math>.
To this end, we can use the <code><a href="../reference/graph_lme.html">graph_lme()</a></code> function.</p>
<p>If we do not specify the model, it will fit a linear regression
model. So, let us first fit a simple linear regression model to
illustrate:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_lm</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span><span class="op">)</span></span></code></pre></div>
<p>We can get the summary:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_lm</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Linear regression model</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span><span class="co">## (Intercept) -1.13093    0.06936  -16.31   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          0.93551    0.07075   13.22   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          2.04390    0.07075   28.89   &lt;2e-16 ***</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No random effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">## std. dev </span></span>
<span><span class="co">## 1.550846 </span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -927.3651</span></span></code></pre>
<p>Let us now fit the linear mixed-effects model with a Whittle-Mat'ern
latent model with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha=1</annotation></semantics></math>.
To this end, we can either specify the <code>model</code> argument as
<code>'alpha1'</code> or as the following list:
<code>list(type = 'WhittleMatern', alpha = 1)</code>. The list makes it
easier to understand which model is being chosen as a random effect,
however, it makes it longer, and less convenient, to write. Let us use
the simplified form:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="st">'WM1'</span><span class="op">)</span></span></code></pre></div>
<p>Let us get the summary of the result:</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = "WM1")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept)  -1.1014    0.1181  -9.324  &lt; 2e-16 ***</span></span>
<span><span class="co">## lon           0.9511    0.1201   7.922 2.34e-15 ***</span></span>
<span><span class="co">## lat           1.9748    0.1232  16.035  &lt; 2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##        Estimate Std.error z-value</span></span>
<span><span class="co">## tau    0.114099  0.005449  20.941</span></span>
<span><span class="co">## kappa 11.506072  1.742238   6.604</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma  1.82701   0.09598  19.036</span></span>
<span><span class="co">## range  0.17382   0.02583   6.729</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.07595   0.04519   1.681</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -794.3335 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 26</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  44.217 secs</span></span></code></pre>
<p>We can obtain additional information by using
<code><a href="../reference/glance.graph_lme.html">glance()</a></code>:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.graph_lme.html">glance</a></span><span class="op">(</span><span class="va">res</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs  sigma logLik   AIC   BIC deviance df.residual model         alpha</span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>         <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>   500 0.076<span style="text-decoration: underline;">0</span>  -<span style="color: #BB0000;">794.</span> <span style="text-decoration: underline;">1</span>601. <span style="text-decoration: underline;">1</span>626.    <span style="text-decoration: underline;">1</span>589.         494 WhittleMatern     1</span></span></code></pre>
<p>We will now compare with the true values of the random effects:</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma_e_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">measurement_error</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">sigma_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">range_est</span> <span class="op">&lt;-</span> <span class="va">res</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span></span>
<span><span class="va">results</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>sigma_e <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma_e</span>, <span class="va">sigma_e_est</span><span class="op">)</span>,</span>
<span>                      sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">sigma_est</span><span class="op">)</span>,</span>
<span>                      range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">range</span>, <span class="va">range_est</span><span class="op">)</span>,</span>
<span>                      row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimate"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">results</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##             sigma_e   sigma     range</span></span>
<span><span class="co">## Truth    0.10000000 2.00000 0.2000000</span></span>
<span><span class="co">## Estimate 0.07595015 1.82701 0.1738213</span></span></code></pre>
<p>Given these estimated parameters, we can now do kriging to estimate
the field at locations in the graph. As an example, we now obtain
predictions on the regular mesh that we previously constructed. First,
we obtain the covariates on the mesh locations.</p>
<p>Now, we can compute the predictions for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>.
First, let us compute the posterior mean for the field at the
observation locations and plot the residuals between the posterior means
and the field:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">pred_u</span><span class="op">$</span><span class="va">resid_field</span> <span class="op">&lt;-</span> <span class="va">pred_u</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span></span>
<span><span class="va">pred_u</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">process_data</span><span class="op">(</span>data <span class="op">=</span> <span class="va">pred_u</span>, normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">pred_u</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">"resid_field"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-23-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can also obtain predictions by using the <code><a href="../reference/augment.graph_lme.html">augment()</a></code>
function:</p>
<p>Let us first plot the predictions for the field, then the fitted
values:</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_aug</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/augment.graph_lme.html">augment</a></span><span class="op">(</span><span class="va">res</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pred_aug</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">".random"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-24-1.png" width="700"></p>
<p>Let us now plot the fitted values along with the observed values:</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_aug</span> <span class="op"><a href="../reference/pipe.html">%&gt;%</a></span> <span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>data <span class="op">=</span> <span class="st">".fitted"</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-25-1.png" width="700"></p>
<p>Let us now obtain predictions of the field on a mesh of equally
spaced nodes on the graph. First, let us create the mesh and
<code>data.frame</code>:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">build_mesh</span><span class="op">(</span>h <span class="op">=</span> <span class="fl">50</span><span class="op">/</span><span class="fl">1000</span><span class="op">)</span></span>
<span><span class="va">lonlat_mesh</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">coordinates</span><span class="op">(</span>PtE <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">)</span></span>
<span><span class="va">scaled_lonlat_mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/scale.html" class="external-link">scale</a></span><span class="op">(</span><span class="va">lonlat_mesh</span>, </span>
<span>                            center <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">scaled_lonlat</span>, <span class="st">"scaled:center"</span><span class="op">)</span>,</span>
<span>                            <span class="fu"><a href="https://rdrr.io/r/base/attr.html" class="external-link">attr</a></span><span class="op">(</span><span class="va">scaled_lonlat</span>, <span class="st">"scaled:scale"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">data_mesh_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>lon <span class="op">=</span> <span class="va">scaled_lonlat_mesh</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                              lat <span class="op">=</span> <span class="va">scaled_lonlat_mesh</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>,</span>
<span>                              edge_number <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                              distance_on_edge <span class="op">=</span> <span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">VtE</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="co"># Let us remove duplicated vertices (that were created due to being too close)</span></span>
<span><span class="va">data_mesh_pred</span> <span class="op">&lt;-</span> <span class="va">data_mesh_pred</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/duplicated.html" class="external-link">duplicated</a></span><span class="op">(</span><span class="va">graph</span><span class="op">$</span><span class="va">mesh</span><span class="op">$</span><span class="va">V</span><span class="op">)</span>,<span class="op">]</span></span></code></pre></div>
<p>Now, let us obtain the predictions. We can obtain estimates for the
latent field by taking the <code>re_mean</code> element from the
<code>pred</code> list obtained by calling
<code>prediction()</code>:</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res</span>, newdata<span class="op">=</span><span class="va">data_mesh_pred</span>, normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">u_est</span> <span class="op">&lt;-</span> <span class="va">pred</span><span class="op">$</span><span class="va">re_mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">u_est</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-27-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Finally, let us obtain predictions for the observed values on the
mesh. In this case we use the <code>mean</code> component of the
<code>pred</code> list:</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_est</span> <span class="op">&lt;-</span> <span class="va">pred</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-28-1.png" width="700" style="display: block; margin: auto;"></p>
<p>The same procedure can be done with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha = 2</annotation></semantics></math>.
One can also estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
from data as described in the vignette <a href="fem_models.html">Whittle–Matérn fields with general
smoothness</a>.</p>
</div>
</div>
<div class="section level3">
<h3 id="isotropic-gaussian-fields">Isotropic Gaussian fields<a class="anchor" aria-label="anchor" href="#isotropic-gaussian-fields"></a>
</h3>
<p>For metric graphs with Euclidean edges, <a href="https://projecteuclid.org/journals/annals-of-statistics/volume-48/issue-4/Isotropic-covariance-functions-on-graphs-and-their-edges/10.1214/19-AOS1896.full" class="external-link"><span class="citation">Anderes, Møller, and Rasmussen (2020)</span></a> showed
that one can define valid Gaussian processes through various isotropic
covariance functions if the distances between points are measured in the
so-called resistance metric
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo>,</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d(\cdot,\cdot)</annotation></semantics></math>.
One example of a valid covariance function is the isotropic exponential
covariance function
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>σ</mi><mn>2</mn></msup><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mi>κ</mi><mi>d</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>,</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
r(d(s,t)) = \sigma^2\exp(-\kappa d(s,t)).
</annotation></semantics></math> This covariance is very similar to that
of the Whittle–Mat'ern fields with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\alpha = 1</annotation></semantics></math>.
Between the two, we recommend using the Whittle–Matérn model since it
has Markov properties which makes inference much faster. Further, that
covariance is well-defined for any compact metric graph, whereas the
isotropic exponential is only guaranteed to be positive definite if the
graph has Euclidean edges. See <a href="https://arxiv.org/abs/2304.10372" class="external-link"><span class="citation">Bolin,
Simas, and Wallin (2023)</span></a> for further comparisons.</p>
<p>However, let us now illustrate how to use it for the data that we
generated above. To work with the covariance function, the only
cumbersome thing is to compute the metric. The <code>metric_graph</code>
class has built in support for this, and we can obtain the distances
between the observation locations as</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">compute_resdist</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>However, if the goal is to fit a model using this covariance
function, there is no need for the user to compute it. It is done
internally when one uses the <code><a href="../reference/graph_lme.html">graph_lme()</a></code> function. We need
to set the <code>model</code> argument in <code><a href="../reference/graph_lme.html">graph_lme()</a></code> as a
list with type <code>"isoCov"</code> (there is no need to add additional
arguments, as the exponential covariance is the default). Let us fit a
linear regression model with a random effect given by a Gaussian field
with an isotropic exponential covariance function (alternatively, one
can also write <code>model = 'isoExp'</code>):</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"isoCov"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in graph_lme(y ~ lon + lat, graph = graph, model = list(type =</span></span>
<span><span class="co">## "isoCov")): No check for Euclidean edges have been perfomed on this graph. The</span></span>
<span><span class="co">## isotropic covariance models are only known to work for graphs with Euclidean</span></span>
<span><span class="co">## edges. You can check if the graph has Euclidean edges by running the</span></span>
<span><span class="co">## `check_euclidean()` method. See the vignette</span></span>
<span><span class="co">## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html</span></span>
<span><span class="co">## for further details.</span></span></code></pre>
<p>Observe that we received a warning saying that we did not check if
the graph has Euclidean edges. This is due to the fact that the
isotropic covariance models are only known to work for graphs with
Euclidean edges. Let us check if the graph has Euclidean edges. To this
end, we need to use the <code>check_euclidean()</code> method:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span><span class="op">$</span><span class="fu">check_euclidean</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>Now, we simply call the graph to print its characteristics to check
the information:</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph</span></span></code></pre></div>
<pre><code><span><span class="co">## A metric graph with  248  vertices and  397  edges.</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Vertices:</span></span>
<span><span class="co">##   Degree 1: 12;  Degree 2: 1;  Degree 3: 164;  Degree 4: 67;  Degree 5: 4; </span></span>
<span><span class="co">##   With incompatible directions:  1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Edges: </span></span>
<span><span class="co">##   Lengths: </span></span>
<span><span class="co">##       Min: 0.005650044  ; Max: 2.141415  ; Total: 64.48864 </span></span>
<span><span class="co">##   Weights: </span></span>
<span><span class="co">##       Min: 1  ; Max: 1 </span></span>
<span><span class="co">##   That are circles:  0 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Graph units: </span></span>
<span><span class="co">##   Vertices unit:  degrees  ; Lengths unit:  km </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Longitude and Latitude coordinates:  TRUE</span></span>
<span><span class="co">##   Which spatial package:  sp </span></span>
<span><span class="co">##   CRS:  +proj=longlat +datum=WGS84 +no_defs</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Some characteristics of the graph:</span></span>
<span><span class="co">##   Connected: TRUE</span></span>
<span><span class="co">##   Has loops: FALSE</span></span>
<span><span class="co">##   Has multiple edges: TRUE</span></span>
<span><span class="co">##   Is a tree: FALSE</span></span>
<span><span class="co">##   Distance consistent: unknown</span></span></code></pre>
<pre><code><span><span class="co">## To check if the graph satisfies the distance consistency, run the `check_distance_consistency()` method.</span></span></code></pre>
<pre><code><span><span class="co">##   Has Euclidean edges: FALSE</span></span></code></pre>
<p>Observe that this graph DOES NOT have Euclidean edges. This means
that the model with isotropic exponential covariance is not guaranteed
to work for this graph. In any case, we can try to fit it anyway.
Observe that we will now receive a different warning, since now we know
for fact that the graph does not have Euclidean edges. In this case, we
will set <code>model</code> to <code>isoexp</code> for conveniency.</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="st">"isoexp"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in graph_lme(y ~ lon + lat, graph = graph, model = "isoexp"): This</span></span>
<span><span class="co">## graph DOES NOT have Euclidean edges. The isotropic covariance models are NOT</span></span>
<span><span class="co">## guaranteed to work for this graph! See the vignette</span></span>
<span><span class="co">## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html</span></span>
<span><span class="co">## for further details.</span></span></code></pre>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_exp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Covariance-based model</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = "isoexp")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept)  -1.1399    0.1846  -6.175 6.61e-10 ***</span></span>
<span><span class="co">## lon           0.9183    0.1423   6.454 1.09e-10 ***</span></span>
<span><span class="co">## lat           2.0044    0.1644  12.194  &lt; 2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## tau    1.71966   0.09721  17.690</span></span>
<span><span class="co">## kappa 14.04626   2.41997   5.804</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.06769   0.04953   1.367</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -801.5418 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 40</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  16.5286 secs</span></span></code></pre>
<p>We can also have a glance at the fitted model:</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.graph_lme.html">glance</a></span><span class="op">(</span><span class="va">res_exp</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs  sigma logLik   AIC   BIC deviance df.residual model  cov_function  </span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>         </span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>   500 0.067<span style="text-decoration: underline;">7</span>  -<span style="color: #BB0000;">802.</span> <span style="text-decoration: underline;">1</span>615. <span style="text-decoration: underline;">1</span>640.    <span style="text-decoration: underline;">1</span>603.         494 isoCov exp_covariance</span></span></code></pre>
<p>Let us now compute the posterior mean for the field at the
observation locations and plot the residuals between the field and the
posterior means of the field:</p>
<div class="sourceCode" id="cb70"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_exp</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_exp</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-35-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To perform kriging prediction to other locations, one can use the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method along with a <code>data.frame</code>
containing the locations in which one wants to obtain predictions and
the corresponding covariate values at these locations. In this example
we will use the <code>data_mesh_pred</code> from the previous example.
Let us estimate the observed values at the mesh locations:</p>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_exp_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_exp</span>, newdata <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">y_est_exp</span> <span class="op">&lt;-</span> <span class="va">pred_exp_y</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est_exp</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-36-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="models-based-on-the-graph-laplacian">Models based on the Graph Laplacian<a class="anchor" aria-label="anchor" href="#models-based-on-the-graph-laplacian"></a>
</h3>
<p>A final set of Gaussian models that is supported by
<code>MetricGraph</code> is the Matérn type processes based on the graph
Laplacian introduced by <a href="http://proceedings.mlr.press/v130/borovitskiy21a/borovitskiy21a.pdf" class="external-link"><span class="citation">Borovitskiy et al. (2021)</span></a>. These are
multivariate Gaussian distributions, which are defined in the vertices
through the equation
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>κ</mi><mn>2</mn></msup><mi>𝐈</mi><mo>−</mo><msub><mi>𝚫</mi><mi>Γ</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>α</mi><mi>/</mi><mn>2</mn></mrow></msup><mi>𝐮</mi><mo>=</mo><mi>𝐖</mi></mrow><annotation encoding="application/x-tex">
(\kappa^2\mathbf{I} - \mathbf{\Delta}_\Gamma)^{\alpha/2}\mathbf{u} = \mathbf{W}
</annotation></semantics></math> Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐖</mi><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msup><mi>σ</mi><mn>2</mn></msup><mi>𝐈</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{W}\sim N(0,\sigma^2\mathbf{I})</annotation></semantics></math>
is a vector with independent Gaussian variables and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝚫</mi><mi>Γ</mi></msub><annotation encoding="application/x-tex">\mathbf{\Delta}_\Gamma</annotation></semantics></math>
is the graph Laplacian. Further,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐮</mi><annotation encoding="application/x-tex">\mathbf{u}</annotation></semantics></math>
is a vector with the values of the process in the vertices of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>,
which by definition has precision matrix
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐐</mi><mo>=</mo><msup><mi>σ</mi><mrow><mo>−</mo><mn>2</mn></mrow></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>κ</mi><mn>2</mn></msup><mi>𝐈</mi><mo>−</mo><msub><mi>𝚫</mi><mi>Γ</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>α</mi></msup></mrow><annotation encoding="application/x-tex">
\mathbf{Q} = \sigma^{-2}(\kappa^2\mathbf{I} - \mathbf{\Delta}_\Gamma)^{\alpha}
</annotation></semantics></math> Thus, to define these models, the only
“difficult” thing is to compute the graph Laplacian. The (weighted)
graph Laplacian, where the weights are specified by the edge lengths can
be computed by the function <code>compute_laplacian()</code> in the
<code>metric_graph</code> object. Suppose that we want to fit the data
that we defined above with this model. We can use the
<code><a href="../reference/graph_lme.html">graph_lme()</a></code> function. Also, observe that there is no need
to use the <code>compute_laplacian()</code> function, as it is done
internally. We now set the <code>model</code> argument as a list with
the <code>type</code> being <code>"GraphLaplacian"</code>
(alternatively, one can also write <code>model = 'GL1'</code>) to obtain
a graph Laplacian model with <code>alpha=1</code>:</p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_gl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"GraphLaplacian"</span><span class="op">)</span>, </span>
<span>                            optim_method <span class="op">=</span> <span class="st">"Nelder-Mead"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_gl</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - graph Laplacian SPDE with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph, model = list(type = "GraphLaplacian"), </span></span>
<span><span class="co">##     optim_method = "Nelder-Mead")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept)  -1.1225    0.1145  -9.801  &lt; 2e-16 ***</span></span>
<span><span class="co">## lon           0.9618    0.1199   8.024 1.02e-15 ***</span></span>
<span><span class="co">## lat           2.0373    0.1179  17.277  &lt; 2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## tau   0.109437  0.006147  17.803</span></span>
<span><span class="co">## kappa 2.993409  0.383903   7.797</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma  3.73454   0.14569  25.633</span></span>
<span><span class="co">## range  0.66813   0.07945   8.409</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.05041   0.08726   0.578</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -792.0891 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 491</span></span>
<span><span class="co">## Optimization method used in 'optim' = Nelder-Mead</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  3.3943 secs</span></span></code></pre>
<p>We can also have a glance at the fitted model:</p>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.graph_lme.html">glance</a></span><span class="op">(</span><span class="va">res_gl</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs  sigma logLik   AIC   BIC deviance df.residual model          alpha</span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>          <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>   500 0.050<span style="text-decoration: underline;">4</span>  -<span style="color: #BB0000;">792.</span> <span style="text-decoration: underline;">1</span>596. <span style="text-decoration: underline;">1</span>621.    <span style="text-decoration: underline;">1</span>584.         494 GraphLaplacian     1</span></span></code></pre>
<p>We can now obtain prediction at the observed locations by using the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method. Let us compute the posterior mean for the
field at the observation locations and plot the residuals between the
field and the posterior means of the field:</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_GL</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-39-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Now, if we do predictions outside of the observation locations on a
graph Laplacian model, we need to modify the graph. This modifies the
model in its entirety. Thus, we need to refit the model with all the
observation locations we want to do predictions. However, if we use the
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method with observations outside of the
observation locations, the <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> will return
predictions together with a <code>warning</code> that one should refit
the model to obtain proper predictions. Here, we will see the (incorrect
way of obtaining) predictions of the observed data:</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl</span>, newdata <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in predict.graph_lme(res_gl, newdata = data_mesh_pred, normalized =</span></span>
<span><span class="co">## TRUE): There are prediction locations outside of the observation locations.</span></span>
<span><span class="co">## Refit the model with all the locations you want to obtain predictions.</span></span></code></pre>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_est_GL</span> <span class="op">&lt;-</span> <span class="va">pred_GL_y</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est_GL</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-40-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now refit the model with all the locations we want to obtain
predictions. Let us create a new data set with all the original
locations and all the locations we want to obtain predictions (with
<code>y=NA</code> at the locations we want to obtain predictions):</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_mesh_temp</span> <span class="op">&lt;-</span> <span class="va">data_mesh_pred</span></span>
<span><span class="va">data_mesh_temp</span><span class="op">[[</span><span class="st">"y"</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">data_mesh_pred</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">new_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://edzer.github.io/sp/reference/merge.html" class="external-link">merge</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">data_mesh_temp</span>, all <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us clone the graph and add the new data:</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">graph_pred</span> <span class="op">&lt;-</span> <span class="va">graph</span><span class="op">$</span><span class="fu">clone</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph_pred</span><span class="op">$</span><span class="fu">clear_observations</span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">graph_pred</span><span class="op">$</span><span class="fu">add_observations</span><span class="op">(</span>data <span class="op">=</span> <span class="va">new_data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Adding observations...</span></span></code></pre>
<pre><code><span><span class="co">## The unit for edge lengths is km</span></span></code></pre>
<pre><code><span><span class="co">## The current tolerance for removing distant observations is (in km): 1.07070750299905</span></span></code></pre>
<p>Let us now fit the model with all data:</p>
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">res_gl_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_lme.html">graph_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span>, graph <span class="op">=</span> <span class="va">graph_pred</span>, model <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>type <span class="op">=</span> <span class="st">"GraphLaplacian"</span><span class="op">)</span>,</span>
<span>                                optim_method <span class="op">=</span> <span class="st">"Nelder-Mead"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">res_gl_pred</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - graph Laplacian SPDE with alpha = 1</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## graph_lme(formula = y ~ lon + lat, graph = graph_pred, model = list(type = "GraphLaplacian"), </span></span>
<span><span class="co">##     optim_method = "Nelder-Mead")</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)    </span></span>
<span><span class="co">## (Intercept) -1.11486   0.09908  -11.25   &lt;2e-16 ***</span></span>
<span><span class="co">## lon          0.92625   0.08130   11.39   &lt;2e-16 ***</span></span>
<span><span class="co">## lat          2.07185   0.08080   25.64   &lt;2e-16 ***</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## tau    0.16682   0.02479   6.730</span></span>
<span><span class="co">## kappa  1.74728   0.42127   4.148</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## sigma   3.2066    0.1942  16.512</span></span>
<span><span class="co">## range   1.1446    0.2376   4.817</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev   0.9317    0.1017   9.162</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -896.1099 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 501</span></span>
<span><span class="co">## Optimization method used in 'optim' = Nelder-Mead</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  7.19612 secs</span></span></code></pre>
<p>One should compare the estimates with the ones obtained in the model
without the prediction locations.</p>
<p>Let us first compute the residual between the latent field and the
posterior means at the observation locations:</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_full</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl_pred</span>, newdata <span class="op">=</span> <span class="va">data</span>, normalized <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot</span><span class="op">(</span>X <span class="op">=</span> <span class="va">pred_GL_full</span><span class="op">$</span><span class="va">re_mean</span> <span class="op">-</span> <span class="va">u</span>, X_loc <span class="op">=</span> <span class="va">data</span><span class="op">[</span>,<span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">]</span>, vertex_size <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-44-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now obtain predictions at the desired locations (in the
correct way) of the observed data:</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pred_GL_y_full</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">res_gl_pred</span>, newdata <span class="op">=</span> <span class="va">data_mesh_pred</span>, </span>
<span>                    normalized<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">y_est_GL_full</span> <span class="op">&lt;-</span> <span class="va">pred_GL_y_full</span><span class="op">$</span><span class="va">mean</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">y_est_GL_full</span>, vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-45-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="the-inlabru-interface">The <code>inlabru</code> interface<a class="anchor" aria-label="anchor" href="#the-inlabru-interface"></a>
</h2>
<p>In this vignette we will present our <code>inlabru</code> interface
to Whittle–Matérn fields. The <code>MetricGraph</code> package also has
a similar interface to<code>R-INLA</code>, which is described in detail
in the <a href="inla_interface.html">INLA interface of Whittle–Matérn
fields</a> vignette.</p>
<div class="section level3">
<h3 id="basic-setup-and-estimation">Basic setup and estimation<a class="anchor" aria-label="anchor" href="#basic-setup-and-estimation"></a>
</h3>
<p>We will use the same graph and data as before. The
<code>inlabru</code> implementation requires the observation locations
to be added to the graph. However, note that for the Whittle–Matérn
fields (contrary to the models based on the graph Laplacian) we are not
changing the model by adding vertices at observation locations. We
already created the extended graph above, so we can use that. Now, we
load <code>INLA</code> and <code>inlabru</code> packages. We will also
need to create the <code>inla</code> model object with the
<code>graph_spde</code> function. By default we have
<code>alpha=1</code>.</p>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">INLA</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="http://www.inlabru.org" class="external-link">inlabru</a></span><span class="op">)</span></span>
<span><span class="va">spde_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_spde.html">graph_spde</a></span><span class="op">(</span><span class="va">graph</span><span class="op">)</span></span></code></pre></div>
<p>Recall that the data is already on the graph object (from the
previous models above). Now, we create <code>inlabru</code>’s component,
which is a formula-like object:</p>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cmp</span> <span class="op">&lt;-</span> <span class="va">y</span> <span class="op">~</span> <span class="fu">Intercept</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">lat</span> <span class="op">+</span> <span class="fu">field</span><span class="op">(</span><span class="va">loc</span>, model <span class="op">=</span> <span class="va">spde_model</span><span class="op">)</span></span></code></pre></div>
<p>This formula is very simple since we are not assuming mean zero, so
that we do not need an intercept, and we do not have any other
covariates or model components. However, the setup is exactly the same
for more complicated models, with the only exception that we would have
more terms in the formla. Now, we directly fit the model:</p>
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spde_bru_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/inlabru/reference/bru.html" class="external-link">bru</a></span><span class="op">(</span><span class="va">cmp</span>, data <span class="op">=</span> </span>
<span>              <span class="fu"><a href="../reference/graph_data_spde.html">graph_data_spde</a></span><span class="op">(</span><span class="va">spde_model</span>, loc_name <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span><span class="op">[[</span><span class="st">"data"</span><span class="op">]</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>The advantage / difference between the estimates we obtain here and
those above is that the <code>bru</code> function does full Bayesian
inference (assuming priors for the model parameters). We used the
default priors when creating the <code>graph_spde</code> model (see the
help text for that function). The advantage now is that we do not only
obtain point estimates but entire posterior distributions for the
parameters. To view the estimates we can use the
<code><a href="../reference/spde_metric_graph_result.html">spde_metric_graph_result()</a></code> function, then taking a
<code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>:</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">spde_bru_result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde_metric_graph_result.html">spde_metric_graph_result</a></span><span class="op">(</span><span class="va">spde_bru_fit</span>, </span>
<span>                    <span class="st">"field"</span>, <span class="va">spde_model</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">spde_bru_result</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##          mean        sd 0.025quant 0.5quant 0.975quant     mode</span></span>
<span><span class="co">## sigma 1.86597 0.1020030   1.679700 1.861770   2.080020 1.841670</span></span>
<span><span class="co">## range 0.17940 0.0273709   0.132664 0.176922   0.239907 0.171518</span></span></code></pre>
<p>Here we are showing the estimate of the practical correlation range
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>/</mi><mi>κ</mi></mrow><annotation encoding="application/x-tex">2/\kappa</annotation></semantics></math>)
instead of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>
since that is easier to interpret. We now compare the means of the
estimated values with the true values:</p>
<div class="sourceCode" id="cb94"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">result_df_bru</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>    parameter <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"std.dev"</span>, <span class="st">"range"</span><span class="op">)</span>,</span>
<span>    true <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">range</span><span class="op">)</span>,</span>
<span>    mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.sigma</span><span class="op">$</span><span class="va">mean</span>,</span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.range</span><span class="op">$</span><span class="va">mean</span></span>
<span>    <span class="op">)</span>,</span>
<span>    mode <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.sigma</span><span class="op">$</span><span class="va">mode</span>,</span>
<span>      <span class="va">spde_bru_result</span><span class="op">$</span><span class="va">summary.range</span><span class="op">$</span><span class="va">mode</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">result_df_bru</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   parameter true      mean      mode</span></span>
<span><span class="co">## 1   std.dev  2.0 1.8659687 1.8416695</span></span>
<span><span class="co">## 2     range  0.2 0.1794003 0.1715175</span></span></code></pre>
<p>We can also plot the posterior marginal densities with the help of
the <code><a href="../reference/gg_df.metric_graph_spde_result.html">gg_df()</a></code> function:</p>
<div class="sourceCode" id="cb96"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="va">posterior_df_bru_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gg_df.metric_graph_spde_result.html">gg_df</a></span><span class="op">(</span><span class="va">spde_bru_result</span><span class="op">)</span></span>
<span></span>
<span>  <span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span></span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">posterior_df_bru_fit</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html" class="external-link">geom_line</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> </span>
<span>  <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html" class="external-link">facet_wrap</a></span><span class="op">(</span><span class="op">~</span><span class="va">parameter</span>, scales <span class="op">=</span> <span class="st">"free"</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/labs.html" class="external-link">labs</a></span><span class="op">(</span>y <span class="op">=</span> <span class="st">"Density"</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-51-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
<div class="section level3">
<h3 id="kriging-with-the-inlabru-implementation">Kriging with the <code>inlabru</code> implementation<a class="anchor" aria-label="anchor" href="#kriging-with-the-inlabru-implementation"></a>
</h3>
<p>Unfortunately, our <code>inlabru</code> implementation is not
compatible with <code>inlabru</code>’s <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method.
This has to do with the nature of the metric graph’s object.</p>
<p>To this end, we have provided a different <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>
method. We will now show how to do kriging with the help of this
function.</p>
<p>We begin by creating a data list with the positions we want the
predictions. In this case, we will want the predictions on a mesh.</p>
<p>The positions we want are the mesh positions, which we have in the
<code>data.frame</code> for the previous models. The function
<code><a href="../reference/graph_bru_process_data.html">graph_bru_process_data()</a></code> helps us into converting that
<code>data.frame</code> to an <code>inlabru</code> friendly format for
dealing with metric graphs:</p>
<div class="sourceCode" id="cb97"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data_list</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/graph_bru_process_data.html">graph_bru_process_data</a></span><span class="op">(</span><span class="va">data_mesh_pred</span>, loc <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span></span></code></pre></div>
<p>We can now obtain the predictions by using the <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>
method. Observe that our <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method for graph models
is a bit different from <code>inlabru</code>’s standard
<code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method. Indeed, the first argument is the model
created with the <code><a href="../reference/graph_spde.html">graph_spde()</a></code> function, the second is
<code>inlabru</code>’s component, and the remaining is as done with the
standard <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code> method in <code>inlabru</code>.</p>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">field_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">spde_model</span>, </span>
<span>                                <span class="va">cmp</span>,</span>
<span>                                <span class="va">spde_bru_fit</span>, </span>
<span>                                newdata <span class="op">=</span> <span class="va">data_list</span>,</span>
<span>                                formula <span class="op">=</span> <span class="op">~</span> <span class="va">field</span><span class="op">)</span></span></code></pre></div>
<p>Let us plot the predictions of the latent field:</p>
<div class="sourceCode" id="cb99"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_field_prd</span> <span class="op">&lt;-</span> <span class="va">field_pred</span><span class="op">$</span><span class="va">pred</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">mean_field_prd</span>, improve_plot <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                      vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-54-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Finally, let us plot predictions of the observed data at the mesh
locations:</p>
<div class="sourceCode" id="cb100"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">obs_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">spde_model</span>, </span>
<span>                                <span class="va">cmp</span>,</span>
<span>                                <span class="va">spde_bru_fit</span>, </span>
<span>                                newdata <span class="op">=</span> <span class="va">data_list</span>,</span>
<span>                                formula <span class="op">=</span> <span class="op">~</span> <span class="va">Intercept</span> <span class="op">+</span> <span class="va">lat</span> <span class="op">+</span> <span class="va">lon</span> <span class="op">+</span> <span class="va">field</span><span class="op">)</span></span></code></pre></div>
<p>Let us plot the predictions:</p>
<div class="sourceCode" id="cb101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mean_obs_prd</span> <span class="op">&lt;-</span> <span class="va">obs_pred</span><span class="op">$</span><span class="va">pred</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">graph</span><span class="op">$</span><span class="fu">plot_function</span><span class="op">(</span>X <span class="op">=</span> <span class="va">mean_obs_prd</span>, improve_plot <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                    vertex_size <span class="op">=</span> <span class="fl">0</span>, edge_width <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="MetricGraph_files/figure-html/unnamed-chunk-56-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Anderes2020" class="csl-entry">
Anderes, Ethan, Jesper Møller, and Jakob G Rasmussen. 2020.
<span>“Isotropic Covariance Functions on Graphs and Their Edges.”</span>
<em>Annals of Statistics</em>.
</div>
<div id="ref-inlabru2019" class="csl-entry">
Bachl, Fabian E., Finn Lindgren, David L. Borchers, and Janine B.
Illian. 2019. <span>“Inlabru an R Package for Bayesian Spatial Modelling
from Ecological Survey Data.”</span> <em>Methods in Ecology and
Evolution</em>.
</div>
<div id="ref-sppackage" class="csl-entry">
Bivand, Roger S., Edzer Pebesma, and Virgilio Gomez-Rubio. 2013.
<em>Applied Spatial Data Analysis with R</em>. Springer, NY.
</div>
<div id="ref-BSW2022b" class="csl-entry">
Bolin, David, Alexandre B. Simas, and Jonas Wallin. 2023.
<span>“Statistical Properties of Gaussian Whittle–Matérn Fields on
Metric Graphs.”</span> <em>arXiv:2304.10372</em>.
</div>
<div id="ref-BSW2022a" class="csl-entry">
———. 2024. <span>“Gaussian Whittle–Matérn Fields on Metric
Graphs.”</span> <em>Bernoulli</em>.
</div>
<div id="ref-Borovitskiy2021" class="csl-entry">
Borovitskiy, Viacheslav, Iskander Azangulov, Alexander Terenin, Peter
Mostowsky, Marc Deisenroth, and Nicolas Durrande. 2021. <span>“Matérn
Gaussian Processes on Graphs.”</span> <em>International Conference on
Artificial Intelligence and Statistics</em>.
</div>
<div id="ref-LindgrenRue2015" class="csl-entry">
Lindgren, Finn, and Haavard Rue. 2015. <span>“Bayesian Spatial Modelling
with R-INLA.”</span> <em>Journal of Statistical Software</em>.
</div>
<div id="ref-plotlypackage" class="csl-entry">
Sievert, Carson. 2020. <em>Interactive Web-Based Data Visualization with
R, Plotly, and Shiny</em>. Chapman and Hall/CRC.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by David Bolin, Alexandre Simas, Jonas Wallin.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
