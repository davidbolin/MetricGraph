[{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MetricGraph: Random Fields on Metric Graphs","text":"lately much interest statistical modeling data compact metric graphs street river networks based Gaussian random fields. R package MetricGraph contains functions working data random fields compact metric graphs. main functionality contained metric_graph class, used specifying metric graphs, adding data , visualization, basic functions needed working data random fields metric graphs. package also implements three types Gaussian processes metric graphs: Whittle–Matérn fields introduced Bolin, Simas, Wallin (2022) Bolin, Simas, Wallin (2023), Gaussian processes isotropic covariance functions Anderes, Møller, Rasmussen (2020), Gaussian models based graph Laplacian Borovitskiy et al. (2021). Basic statistical tasks likelihood evaluation prediction implemented three types models MetricGraph. , package also contains interfaces R-INLA Lindgren Rue (2015), package available http://R-INLA. org/download/ inlabru Bachl et al. (2019) facilitates using packages full Bayesian inference general Latent Gaussian Models (LGMs) includes Whittle–Matérn fields metric graphs. package available install via repository https://github.com/davidbolin/MetricGraph. following sections describe main functionality package summarizes required theory. Section 2 introduces metric graphs metric_graph class, Section 3 shows work random fields metric graphs, Section 4 introduces inlabru interface package application real data. complete introduction functionality package, refer Vignettes available package homepage https://davidbolin.github.io/MetricGraph/. particular, contains introduction INLA interface, implementation Whittle–Matérn fields general smoothness, details examples methods package.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"the-metric_graph-class","dir":"Articles","previous_headings":"","what":"The metric_graph class","title":"MetricGraph: Random Fields on Metric Graphs","text":"compact metric graph \\(\\Gamma\\) consists set finitely many vertices \\(\\mathcal{V}=\\{v_i\\}\\) finite set \\(\\mathcal{E}=\\{e_j\\}\\) edges connecting vertices. edge \\(e\\) defined pair vertices \\((v_i,v_k)\\) finite length \\(l_e \\(0,\\infty)\\). edge graph curve parametrized arc-length, location \\(s\\\\Gamma\\) position edge, can thus represented touple \\((e,t)\\) \\(t\\[0,l_e]\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"basic-constructions","dir":"Articles","previous_headings":"The metric_graph class","what":"Basic constructions","title":"MetricGraph: Random Fields on Metric Graphs","text":"metric graph represented MetricGraph package class metric_graph. object class can constructed two ways. first specify vertex matrix V edge matrix E, assumed edges straight lines. second, flexible, option specify object SpatialLines object using sp package (Bivand, Pebesma, Gomez-Rubio 2013). illustrate , use osmdata package download data OpenStreetMap. following code, extract streets campus King Abdullah University Science Technology (KAUST) SpatialLines object: can now create metric graph follows. command set argument longlat = TRUE since coordinates vertices given Longitude Latitude.  can note warning graph connected, let us create graph_components object contains connected components graphs extract largest connected component work  graph object now contains important features graph, vertex matrix graph$V, number vertices graph$nV, edge matrix graph$E, number edges graph$nE, vector edge lengths graph$edge_lengths given unit km (since specified longlat = TRUE construction). Thus, can obtain range edge lengths unit m : also remove vertices degree 2 using prune_vertices() method:","code":"call <- opq(bbox = c(39.0884, 22.33, 39.115, 22.3056)) call <- add_osm_feature(call, key = \"highway\",value=c(\"motorway\",                                                       \"primary\",\"secondary\",                                                       \"tertiary\",                                                       \"residential\")) data <- osmdata_sp(call) lines <- SpatialLines(data$osm_lines@lines) graph <- metric_graph$new(lines, longlat = TRUE) ## The graph is disconnected. You can use the function 'graph_components' to obtain the different connected components. graph$plot(vertex_size = 0.5) graphs <- graph_components$new(lines = lines, longlat = TRUE) graph <- graphs$get_largest() graph$plot(vertex_size = 0) range(graph$edge_lengths) * 1000 ## [1]    5.64704 2141.41501 graph$prune_vertices() graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"understanding-coordinates-on-graphs","dir":"Articles","previous_headings":"The metric_graph class","what":"Understanding coordinates on graphs","title":"MetricGraph: Random Fields on Metric Graphs","text":"locations vertices specified Euclidean coordinates. However, specifying position graph, practical work Euclidean coordinates since locations Euclidean space locations graph. instead better specify location graph touple \\((, t)\\), \\(\\) denotes number edge \\(t\\) location edge. location \\(t\\) can either specified distance start edge (takes values 0 length edge) normalized distance start edge (takes values 0 1). function coordinates can used convert coordinates Euclidean space locations graph. example location normalized distance 0.2 start second edge : function can also used find closest location graph location Euclidean space: case, normalized argument decides whether returned value given normalized distance .","code":"graph$coordinates(PtE = matrix(c(2, 0.2), 1,2), normalized = TRUE) ##          [,1]     [,2] ## [1,] 39.11751 22.31934 graph$coordinates(XY = matrix(c(39.117, 22.319), 1,2)) ##      [,1] [,2] ## [1,]    1    1"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"adding-data-to-the-graph","dir":"Articles","previous_headings":"The metric_graph class","what":"Adding data to the graph","title":"MetricGraph: Random Fields on Metric Graphs","text":"Given constructed metric graph, can now add data . example, let us sample locations edges random add data graph:  One note one needs specify normalized = TRUE function specify locations normalized distance edges. command set, distances interpreted normalized. add_observations() function accepts multiple types inputs. One scenario can common applications data SpatialPoints objects, one can add observations SpatialPointsDataFrame. illustrate , let us sample locations random graph, use function coordinates transform Longitude Latitude coordinates, use create SpatialPointsDataFrame object add graph:  want replace data object, can use clear_observations() remove current data.","code":"n.obs <- 10 data <- data.frame(edge_number = sample(1:graph$nE, n.obs),                    distance_on_edge = runif(n.obs),                    y = rnorm(n.obs)) graph$add_observations(data = data, normalized = TRUE) graph$plot(data = \"y\", vertex_size = 0) obs.loc <- cbind(sample(1:graph$nE, n.obs), runif(n.obs)) obs.lonlat <- graph$coordinates(PtE = obs.loc, normalized = TRUE) obs <- rnorm(n.obs) points <- SpatialPointsDataFrame(coords = obs.lonlat,                                  data = data.frame(y = obs)) graph$add_observations(points) graph$plot(data = \"y\", vertex_size = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"working-with-functions-on-metric-graphs","dir":"Articles","previous_headings":"The metric_graph class","what":"Working with functions on metric graphs","title":"MetricGraph: Random Fields on Metric Graphs","text":"working data metric graphs, one often wants display functions graph. best way visualize functions graph evaluate fine mesh graph use plot_function. illustrate procedure, let us construct mesh graph:  command build_mesh, argument h decides largest spacing nodes mesh. chose 100m bit coarse. let us reduce value h 10m rebuild mesh: Suppose now want display function \\(f(s) = \\text{Longitude}(s) - \\text{Latitude}(s)\\) graph. first evaluate vertices mesh use function plot_function display :  Alternatively, can set plotly = TRUE plot command get 3D visualization function using plotly (Sievert 2020) package. first argument plot_function vector, function assumes values vector values function evaluated vertices mesh. alternative, one can also provide first argument matrix consisting triplets \\((, t, f(, t))\\), \\(\\) denotes edge number, \\(t\\) location edge, \\(f(, t)\\) value point.","code":"graph$build_mesh(h = 100/1000) graph$plot(mesh=TRUE) graph$build_mesh(h = 10/1000) lon <- graph$mesh$V[, 1] lat <- graph$mesh$V[, 2] f <- lon - lat graph$plot_function(f, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"random-fields-on-metric-graphs","dir":"Articles","previous_headings":"","what":"Random fields on metric graphs","title":"MetricGraph: Random Fields on Metric Graphs","text":"defined metric graph, now ready specify Gaussian processes . section, briefly cover three main types Gaussian processes supported. begin main class models, Whittle–Matérn fields, consider Gaussian processes isotropic covariance functions, finally look discrete models based graph Laplacian.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"whittlematérn-fields","dir":"Articles","previous_headings":"Random fields on metric graphs","what":"Whittle–Matérn fields","title":"MetricGraph: Random Fields on Metric Graphs","text":"Gaussian Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha/2} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"sampling","dir":"Articles","previous_headings":"Random fields on metric graphs > Whittle–Matérn fields","what":"Sampling","title":"MetricGraph: Random Fields on Metric Graphs","text":"example, let us simulate field \\(u\\) graph using \\(\\alpha = 1\\). , draw locations random, sample field locations plot result  can also sample field mesh graph follows:  Since \\(\\alpha=1\\), sample paths continuous differentiable. visualize correlation structure field, can compute plot covariances point points graph follows:  obtain field differentiable sample paths, can change \\(\\alpha=2\\) code .","code":"sigma <- 1.3 range <- 0.15 # range parameter sigma_e <- 0.1  n.obs <- 200 obs.loc <- cbind(sample(1:graph$nE, n.obs, replace=TRUE), runif(n.obs))  # The graph has very small edges, so we will use the  # Q method to improve numerical stability u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = obs.loc, method = \"Q\") graph$clear_observations() graph$add_observations(data = data.frame(edge_number = obs.loc[, 1],                                          distance_on_edge = obs.loc[, 2],                                          u = u),                        normalized = TRUE) graph$plot(data = \"u\", vertex_size = 0) u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, type = \"mesh\", method = \"Q\") graph$plot_function(u, vertex_size = 0, edge_width = 0.5) C <- spde_covariance(c(200, 0.1), range = range, sigma = sigma, alpha = 1,                             graph = graph) graph$plot_function(C, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"inference","dir":"Articles","previous_headings":"Random fields on metric graphs > Whittle–Matérn fields","what":"Inference","title":"MetricGraph: Random Fields on Metric Graphs","text":"following examples consider models without replicates. Please, see Gaussian random fields metric graphs vignette examples replicates. Suppose data form \\[ y_i = \\beta_1\\text{lon}(s_i) +  \\beta_1\\text{lat}(s_i) +  u(s_i) + \\varepsilon_i, \\quad =1,\\ldots,n \\] \\(s_i\\\\Gamma\\) observation locations, lon lat longitude latitude locations, \\(\\beta_1,\\beta_2\\) regression coefficients, \\(\\varepsilon_i\\) independent centered Gaussian variables \\(N(0,\\sigma_e^2)\\) representing measurement noise. Let us create observations, clear current data graph, finally add data graph:  goal now fit linear mixed-effects model data assuming Whittle-Mat'ern latent model \\(\\alpha=1\\). end, can use graph_lme() function. specify model, fit linear regression model. , let us first fit simple linear regression model illustrate: can get summary: Let us now fit linear mixed-effects model Whittle-Mat'ern latent model \\(\\alpha=1\\). end, can either specify model argument 'alpha1' following list: list(type = 'WhittleMatern', alpha = 1). list makes easier understand model chosen random effect, however, makes longer, less convenient, write. Let us use simplified form: Let us get summary result: now compare true values random effects: Given estimated parameters, can now kriging estimate field locations graph. example, now obtain predictions regular mesh previously constructed. First, obtain covariates mesh locations. Now, can compute predictions \\(y\\). First, let us compute posterior mean field observation locations plot residuals posterior means field:  Let us now obtain predictions field mesh equally spaced nodes graph. First, let us create mesh data.frame: Now, let us obtain predictions. can obtain estimates latent field setting only_latent TRUE:  Finally, let us obtain predictions observed values mesh. case set only_latent FALSE:  procedure can done \\(\\alpha = 2\\). One can also estimate \\(\\alpha\\) data described vignette Whittle–Matérn fields general smoothness.","code":"# The graph has very small edges, so we will use the  # Q method to improve numerical stability  sigma <- 2 range <- 0.2 # range parameter sigma_e <- 0.1  n.obs.1 <- 400 # all edges n.obs.2 <- 100 # long edges  n.obs <- n.obs.1 + n.obs.2  obs.loc <- cbind(sample(1:graph$nE, n.obs.1, replace=TRUE), runif(n.obs.1))  # Let us now add some locations on long edges: long.edges <- graph$edge_lengths > 0.5  obs.loc <- rbind(obs.loc, cbind(sample(which(long.edges), n.obs.2, replace=TRUE), runif(n.obs.2)))  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = obs.loc, method = \"Q\")  beta0 = -1 beta1 = 1 beta2 = 2 lonlat <- graph$coordinates(PtE = obs.loc) scaled_lonlat <- scale(lonlat) y <- beta0 + beta1 * scaled_lonlat[, 1] + beta2 * scaled_lonlat[, 2] + u + sigma_e*rnorm(n.obs)  data <- data.frame(edge_number = obs.loc[, 1],                    distance_on_edge = obs.loc[, 2],                    lon = scaled_lonlat[, 1],                    lat = scaled_lonlat[, 2],                    y = y)  graph$clear_observations() graph$plot(X = y, X_loc = obs.loc, vertex_size = 0) graph$add_observations(data = data, normalized = TRUE) res_lm <- graph_lme(y ~ lon + lat, graph = graph) summary(res_lm) ##  ## Linear regression model ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph) ##  ## Fixed effects: ##             Estimate Std. Error t value Pr(>|t|)     ## (Intercept) -1.34614    0.07360  -18.29   <2e-16 *** ## lon          1.13078    0.07471   15.14   <2e-16 *** ## lat          1.94999    0.07471   26.10   <2e-16 *** ##  ## No random effects. ##  ## Measurement error: ## std. dev  ## 1.645836  ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -957.0889 res <- graph_lme(y ~ lon + lat, graph = graph, model = 'WM1') summary(res) ##  ## Latent model - Whittle-Matern with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph, model = \"WM1\") ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)  -1.3103    0.1204  -10.88   <2e-16 *** ## lon           1.0632    0.1181    9.00   <2e-16 *** ## lat           2.0086    0.1245   16.14   <2e-16 *** ##  ## Random effects: ##        Estimate Std.error z-value ## tau    0.112072  0.005533   20.26 ## kappa 11.169741  1.672203    6.68 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma  1.88785   0.09674  19.515 ## range  0.17906   0.02622   6.828 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.13523   0.04476   3.021 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -821.4048  ## Number of function calls by 'optim' = 20 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  1.00564 mins sigma_e_est <- res$coeff$measurement_error[[1]] sigma_est <- res$matern_coeff$random_effects[1] range_est <- res$matern_coeff$random_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##           sigma_e    sigma     range ## Truth    0.100000 2.000000 0.2000000 ## Estimate 0.135234 1.887846 0.1790552 pred_u <- predict(res, data = data, normalized = TRUE, only_latent = TRUE) graph$plot(X = pred_u$mean - u, X_loc = data[,1:2], vertex_size = 0) graph$build_mesh(h = 50/1000) lonlat_mesh <- graph$coordinates(PtE = graph$mesh$VtE) scaled_lonlat_mesh <- scale(lonlat_mesh,                              center = attr(scaled_lonlat, \"scaled:center\"),                             attr(scaled_lonlat, \"scaled:scale\")) data_mesh_pred <- data.frame(lon = scaled_lonlat_mesh[,1],                               lat = scaled_lonlat_mesh[,2],                               edge_number = graph$mesh$VtE[,1],                               distance_on_edge = graph$mesh$VtE[,2]) # Let us remove duplicated vertices (that were created due to being too close) data_mesh_pred <- data_mesh_pred[!duplicated(graph$mesh$V),] pred <- predict(res, data=data_mesh_pred, normalized=TRUE, only_latent=TRUE) u_est <- pred$mean graph$plot_function(u_est, vertex_size = 0, edge_width = 0.5) pred_y <- predict(res, data=data_mesh_pred, normalized=TRUE, only_latent=FALSE) y_est <- pred_y$mean graph$plot_function(y_est, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"isotropic-gaussian-fields","dir":"Articles","previous_headings":"Random fields on metric graphs","what":"Isotropic Gaussian fields","title":"MetricGraph: Random Fields on Metric Graphs","text":"metric graphs Euclidean edges, Anderes, Møller, Rasmussen (2020) showed one can define valid Gaussian processes various isotropic covariance functions distances points measured -called resistance metric \\(d(\\cdot,\\cdot)\\). One example valid covariance function isotropic exponential covariance function \\[ r(d(s,t)) = \\sigma^2\\exp(-\\kappa d(s,t)). \\] covariance similar Whittle–Mat'ern fields \\(\\alpha = 1\\). two, recommend using Whittle–Matérn model since Markov properties makes inference much faster. , covariance well-defined compact metric graph, whereas isotropic exponential guaranteed positive definite graph Euclidean edges. See Bolin, Simas, Wallin (2023) comparisons. However, let us now illustrate use data generated . work covariance function, cumbersome thing compute metric. metric_graph class built support , can obtain distances observation locations However, goal fit model using covariance function, need user compute . done internally one uses graph_lme() function. need set model argument graph_lme() list type \"isoCov\" (need add additional arguments, exponential covariance default). Let us fit linear regression model random effect given Gaussian field isotropic exponential covariance function (alternatively, one can also write model = 'isoExp'): Let us now compute posterior mean field observation locations plot residuals field posterior means field:  perform kriging prediction locations, one can use predict() method along data.frame containing locations one wants obtain predictions corresponding covariate values locations. example use data_mesh_pred previous example. start obtaining predictions latent model:  Finally, let us estimated observed values mesh locations:","code":"graph$compute_resdist() res_exp <- graph_lme(y ~ lon + lat, graph = graph, model = list(type = \"isoCov\")) summary(res_exp) ##  ## Latent model - Covariance-based model ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph, model = list(type = \"isoCov\")) ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)  -1.3277    0.1848  -7.183 6.82e-13 *** ## lon           0.9905    0.1407   7.040 1.93e-12 *** ## lat           1.9380    0.1661  11.665  < 2e-16 *** ##  ## Random effects: ##       Estimate Std.error z-value ## tau     1.7658    0.0931  18.966 ## kappa  13.9614    2.2533   6.196 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.12594   0.04495   2.802 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -828.7012  ## Number of function calls by 'optim' = 28 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  43.9417 secs u_est_exp <- predict(res_exp, data = data, normalized = TRUE, only_latent = TRUE) graph$plot(X = u_est_exp$mean - u, X_loc = data[,1:2], vertex_size = 0) pred_exp <- predict(res_exp, data = data_mesh_pred,                      normalized=TRUE, only_latent = TRUE) u_est_exp <- pred_exp$mean graph$plot_function(u_est_exp, vertex_size = 0, edge_width = 0.5) pred_exp_y <- predict(res_exp, data = data_mesh_pred,                      normalized=TRUE, only_latent = FALSE) y_est_exp <- pred_exp_y$mean graph$plot_function(y_est_exp, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"models-based-on-the-graph-laplacian","dir":"Articles","previous_headings":"Random fields on metric graphs","what":"Models based on the Graph Laplacian","title":"MetricGraph: Random Fields on Metric Graphs","text":"final set Gaussian models supported MetricGraph Matérn type processes based graph Laplacian introduced Borovitskiy et al. (2021). multivariate Gaussian distributions, defined vertices equation \\[ (\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha/2}\\mathbf{u} = \\mathbf{W} \\] \\(\\mathbf{W}\\sim N(0,\\sigma^2\\mathbf{})\\) vector independent Gaussian variables \\(\\mathbf{\\Delta}_\\Gamma\\) graph Laplacian. , \\(\\mathbf{u}\\) vector values process vertices \\(\\Gamma\\), definition precision matrix \\[ \\mathbf{Q} = \\sigma^{-2}(\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha} \\] Thus, define models, “difficult” thing compute graph Laplacian. (weighted) graph Laplacian, weights specified edge lengths can computed function compute_laplacian() metric_graph object. Suppose want fit data defined model. can use graph_lme() function. Also, observe need use compute_laplacian() function, done internally. now set model argument list type \"GraphLaplacian\" (alternatively, one can also write model = 'GL1') obtain graph Laplacian model alpha=1: can now obtain prediction observed locations using predict() method. Let us compute posterior mean field observation locations plot residuals field posterior means field:  Now, predictions outside observation locations graph Laplacian model, need modify graph. modifies model entirety. Thus, need refit model observation locations want predictions. However, use predict() method observations outside observation locations, predict() return predictions together warning one refit model obtain proper predictions: (incorrect way obtaining) predictions observed data:  Let us now refit model locations want obtain predictions. Let us create new data set original locations locations want obtain predictions (y=NA locations want obtain predictions): Let us clone graph add new data: Let us now fit model data: One compare estimates ones obtained model without prediction locations. Let us first compute residual latent field posterior means observation locations:  Let us now obtain predictions desired locations: correct way obtaining predictions observed data desired locations:","code":"res_gl <- graph_lme(y ~ lon + lat, graph = graph, model = list(type = \"GraphLaplacian\")) summary(res_gl) ##  ## Latent model - graph Laplacian SPDE with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph, model = list(type = \"GraphLaplacian\")) ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)  -1.3258    0.1238 -10.707   <2e-16 *** ## lon           1.1443    0.1280   8.939   <2e-16 *** ## lat           1.9706    0.1267  15.556   <2e-16 *** ##  ## Random effects: ##       Estimate Std.error z-value ## tau   0.109222  0.005767  18.940 ## kappa 2.770313  0.349990   7.915 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma  3.88966   0.15628  24.888 ## range  0.72194   0.08907   8.105 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.13131   0.04542   2.891 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -824.6198  ## Number of function calls by 'optim' = 18 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  6.0572 secs pred_u_GL <- predict(res_gl, data = data, normalized = TRUE, only_latent = TRUE) graph$plot(X = pred_u_GL$mean - u, X_loc = data[,1:2], vertex_size = 0) pred_GL <- predict(res_gl, data = data_mesh_pred,                      normalized=TRUE, only_latent = TRUE) ## Warning in predict.graph_lme(res_gl, data = data_mesh_pred, normalized = TRUE, ## : There are prediction locations outside of the observation locations. Refit ## the model with all the locations you want to obtain predictions. u_est_GL <- pred_GL$mean graph$plot_function(u_est_GL, vertex_size = 0, edge_width = 0.5) pred_GL_y <- predict(res_gl, data = data_mesh_pred,                      normalized=TRUE, only_latent = FALSE) ## Warning in predict.graph_lme(res_gl, data = data_mesh_pred, normalized = TRUE, ## : There are prediction locations outside of the observation locations. Refit ## the model with all the locations you want to obtain predictions. y_est_GL <- pred_GL_y$mean graph$plot_function(y_est_GL, vertex_size = 0, edge_width = 0.5) data_mesh_temp <- data_mesh_pred data_mesh_temp[[\"y\"]] <- rep(NA, nrow(data_mesh_pred))  new_data <- merge(data, data_mesh_temp, all = TRUE) graph_pred <- graph$clone() graph_pred$clear_observations() graph_pred$add_observations(data = new_data, normalized = TRUE) res_gl_pred <- graph_lme(y ~ lon + lat, graph = graph_pred, model = list(type = \"GraphLaplacian\")) summary(res_gl_pred) ##  ## Latent model - graph Laplacian SPDE with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph_pred, model = list(type = \"GraphLaplacian\")) ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept) -1.37886   0.09760  -14.13   <2e-16 *** ## lon          1.12680   0.08339   13.51   <2e-16 *** ## lat          1.96050   0.08442   23.22   <2e-16 *** ##  ## Random effects: ##       Estimate Std.error z-value ## tau    0.16575   0.03215   5.155 ## kappa  1.94576   0.56097   3.469 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma   3.0584    0.2125  14.394 ## range   1.0279    0.2533   4.058 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev   1.1534    0.1101   10.48 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -940.6602  ## Number of function calls by 'optim' = 31 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  9.9813 secs pred_u_GL_full <- predict(res_gl_pred, data = data, normalized = TRUE, only_latent = TRUE) graph$plot(X = pred_u_GL_full$mean - u, X_loc = data[,1:2], vertex_size = 0) pred_GL_full <- predict(res_gl_pred, data = data_mesh_pred,                      normalized=TRUE, only_latent = TRUE) u_est_GL_full <- pred_GL_full$mean graph$plot_function(u_est_GL_full, vertex_size = 0, edge_width = 0.5) pred_GL_y_full <- predict(res_gl_pred, data = data_mesh_pred,                      normalized=TRUE, only_latent = FALSE) y_est_GL_full <- pred_GL_y_full$mean graph$plot_function(y_est_GL_full, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"the-inlabru-interface","dir":"Articles","previous_headings":"","what":"The inlabru interface","title":"MetricGraph: Random Fields on Metric Graphs","text":"vignette present inlabru interface Whittle–Matérn fields. MetricGraph package also similar interface toR-INLA, described detail INLA interface Whittle–Matérn fields vignette.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"basic-setup-and-estimation","dir":"Articles","previous_headings":"The inlabru interface","what":"Basic setup and estimation","title":"MetricGraph: Random Fields on Metric Graphs","text":"use graph data . inlabru implementation requires observation locations added graph. However, note Whittle–Matérn fields (contrary models based graph Laplacian) changing model adding vertices observation locations. already created extended graph , can use . Now, load INLA inlabru packages. also need create inla model object graph_spde function. default alpha=1. Recall data already graph object (previous models ). Now, create inlabru’s component, formula-like object: formula simple since assuming mean zero, need intercept, covariates model components. However, setup exactly complicated models, exception terms formla. Now, directly fit model: advantage / difference estimates obtain bru function full Bayesian inference (assuming priors model parameters). used default priors creating graph_spde model (see help text function). advantage now obtain point estimates entire posterior distributions parameters. view estimates can use spde_metric_graph_result() function, taking summary(): showing estimate practical correlation range (\\(2/\\kappa\\)) instead \\(\\kappa\\) since easier interpret. now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:","code":"library(INLA) library(inlabru) spde_model <- graph_spde(graph) cmp <- y ~ Intercept(1) + lon + lat + field(loc, model = spde_model) spde_bru_fit <- bru(cmp, data=graph_data_spde(spde_model, loc = \"loc\")) ## Warning in inla.model.properties.generic(inla.trim.family(model), mm[names(mm) == : Model 'cgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time. ##   Use this model with extra care!!! Further warnings are disabled. spde_bru_result <- spde_metric_graph_result(spde_bru_fit,                      \"field\", spde_model)  summary(spde_bru_result) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.916840 0.0999880   1.732850 1.914330    2.12284 1.928570 ## range 0.168491 0.0245042   0.125787 0.166603    0.22187 0.162634 result_df_bru <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, range),     mean = c(       spde_bru_result$summary.sigma$mean,       spde_bru_result$summary.range$mean     ),     mode = c(       spde_bru_result$summary.sigma$mode,       spde_bru_result$summary.range$mode     )   )   print(result_df_bru) ##   parameter true      mean      mode ## 1   std.dev  2.0 1.9168398 1.9285680 ## 2     range  0.2 0.1684912 0.1626343 posterior_df_bru_fit <- gg_df(spde_bru_result)    library(ggplot2)    ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"kriging-with-the-inlabru-implementation","dir":"Articles","previous_headings":"The inlabru interface","what":"Kriging with the inlabru implementation","title":"MetricGraph: Random Fields on Metric Graphs","text":"Unfortunately, inlabru implementation compatible inlabru’s predict() method. nature metric graph’s object. end, provided different predict() method. now show kriging help function. begin creating data list positions want predictions. case, want predictions mesh. positions want mesh positions, data.frame previous models. function graph_bru_process_data() helps us converting data.frame inlabru friendly format dealing metric graphs: can now obtain predictions using predict() method. Observe predict() method graph models bit different inlabru’s standard predict() method. Indeed, first argument model created graph_spde() function, second inlabru’s component, remaining done standard predict() method inlabru. Let us plot predictions latent field:  Fin §ally, let us plot predictions observed data mesh locations: Let us plot predictions:","code":"data_list <- graph_bru_process_data(data_mesh_pred, loc = \"loc\") field_pred <- predict(spde_model,                                  cmp,                                 spde_bru_fit,                                  data = data_list,                                 formula = ~ field) mean_field_prd <- field_pred$pred[,1] graph$plot_function(mean_field_prd, vertex_size = 0) obs_pred <- predict(spde_model,                                  cmp,                                 spde_bru_fit,                                  data = data_list,                                 formula = ~ Intercept + lat + lon + field) mean_obs_prd <- obs_pred$pred[,1] graph$plot_function(mean_obs_prd, vertex_size = 0)"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Whittle--Matérn fields with general smoothness","text":"vignette introduce fit Whittle–Matérn fields general smoothness based finite element rational approximations. theory approach provided Bolin et al. (2023) Xiong, Simas, Bolin (2022). implementation, make use rSPDE package rational approximations. models thus implemented using finite element approximations. approximations needed integer smoothness parameters, details exact models refer vignettes Whittle–Matérn fields metric graphs INLA inlabru interfaces details construction metric graphs, see Working metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"constructing-the-graph-and-the-mesh","dir":"Articles","previous_headings":"","what":"Constructing the graph and the mesh","title":"Whittle--Matérn fields with general smoothness","text":"begin loading rSPDE MetricGraph packages: example, consider following metric graph  construct FEM approximation Whittle–Matérn field general smoothness, must first construct mesh graph.  command build_mesh, argument h decides largest spacing nodes mesh. can seen plot, mesh coarse, let’s reduce value h rebuild mesh: now ready specify model \\[ (\\kappa^2 - \\Delta)^{\\alpha} \\tau u = \\mathcal{W} \\] Whittle–Matérn field \\(u\\). , use matern.operators function rSPDE package: can seen code, specify \\(\\kappa\\) via practical correlation range \\(\\sqrt{8\\nu}/\\kappa\\). Also, model parametrized \\(\\tau, \\alpha\\) instead \\(\\sigma, \\nu\\). , sigma denotes standard deviation field nu smoothness parameter, related \\(\\alpha\\) via relation \\(\\alpha = \\nu + 1/2\\). object op_cov contains matrices needed evaluating distribution stochastic weights FEM approximation. Let us simulate field \\(u\\) mesh locations plot result: want evaluate \\(u(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights FEM basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\), elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. can done function mesh_A metric graph object. illustrate , let us simulate observation locations graph construct matrix: code, generate \\(50\\) observation locations per edge graph, drawn random. can noted assume observation locations given format \\((e, d)\\) \\(e\\) denotes edge observation \\(d\\) position edge, .e., relative distance first vertex edge. compute precision matrix covariance-based rational approximation one can use precision() method object returned matern.operators() function: illustration model, let us compute covariance function process mid point second edge locations mesh. covariances can calculated \\[   \\overline{\\boldsymbol{\\mathrm{}}} \\boldsymbol{\\mathrm{Q}}^{-1}\\overline{\\boldsymbol{\\mathrm{v}}}. \\] , \\(\\boldsymbol{\\mathrm{Q}}\\) precision matrix obtained rational approximation, \\(\\boldsymbol{\\mathrm{}}\\) identity matrix since evaluating approximation nodes FEM mesh, \\(\\overline{\\boldsymbol{\\mathrm{v}}}\\) \\((m+1)\\)-fold vertical concatenation vector \\(\\boldsymbol{\\mathrm{v}}\\), \\(\\boldsymbol{\\mathrm{v}}\\) vector basis functions evaluated \\(s=0.5\\).","code":"library(rSPDE)   library(MetricGraph) library(sp)   line1 <- Line(rbind(c(0,0),c(1,0)))   line2 <- Line(rbind(c(0,0),c(0,1)))   line3 <- Line(rbind(c(0,1),c(-1,1)))   theta <- seq(from=pi,to=3*pi/2,length.out = 20)   line4 <- Line(cbind(sin(theta),1+ cos(theta)))   Lines = SpatialLines(list(Lines(list(line1),ID=\"1\"),                                 Lines(list(line2),ID=\"2\"),                                 Lines(list(line3),ID=\"3\"),                                 Lines(list(line4),ID=\"4\")))   graph <- metric_graph$new(lines = Lines)   graph$plot() graph$build_mesh(h = 0.5)   graph$plot(mesh=TRUE) graph$build_mesh(h = 0.01) sigma <- 1.3   range <- 0.15   nu <- 0.8     rspde.order <- 2   op <- matern.operators(nu = nu, range = range, sigma = sigma,                           parameterization = \"matern\",                          m = rspde.order, graph = graph) u <- simulate(op) graph$plot_function(u, plotly = TRUE) obs.per.edge <- 100 obs.loc <- NULL for(i in 1:graph$nE) {   obs.loc <- rbind(obs.loc,                    cbind(rep(i,obs.per.edge), runif(obs.per.edge))) } n.obs <- obs.per.edge*graph$nE A <- graph$mesh_A(obs.loc) Q <- precision(op) v <- t(graph$mesh_A(matrix(c(2,0.5),1,2)))   v_bar <- kronecker(matrix(1, nrow = rspde.order + 1),                      v)   A_bar <- kronecker(matrix(1, ncol = rspde.order + 1),                       Matrix::Diagonal(dim(graph$mesh$V)[1]))   c_cov <- (A_bar) %*% solve(Q, v_bar)   graph$plot_function(c_cov, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-the-model-for-inference","dir":"Articles","previous_headings":"","what":"Using the model for inference","title":"Whittle--Matérn fields with general smoothness","text":"built-support computing log-likelihood functions performing kriging prediction rSPDE package can use graph model. illustrate , use simulation create noisy observations process. generate observations \\(Y_i = 1 + 2x_{i1} - 3 x_{i2} u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise, \\(x_1\\) \\(x_2\\) covariates generated relative positions observations graph. Let us now fit model. end use graph_lme() function (, finite element models, acts wrapper rspde_lme() function rSPDE package). end, let us now assemble data.frame() observations, observation locations covariates: Let us now add data graph object plot :  can now fit model. end, use graph_lme() function set model 'WM’. Let us obtain summary model: Let us compare values parameters latent model true ones:","code":"sigma.e <- 0.1      x1 <- obs.loc[,1]     x2 <- obs.loc[,2]      Y <- 1 + 2*x1 - 3*x2 + as.vector(A %*% u + sigma.e * rnorm(n.obs)) df_data <- data.frame(y = Y, edge_number = obs.loc[,1],                         distance_on_edge = obs.loc[,2],                         x1 = x1, x2 = x2) graph$add_observations(data = df_data, normalized = TRUE)  graph$plot(data = \"y\") fit <- graph_lme(y ~ x1 + x2, graph = graph, model = \"WM\") summary(fit) ##  ## Latent model - Whittle-Matern ##  ## Call: ## graph_lme(formula = y ~ x1 + x2, graph = graph, model = \"WM\") ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)   0.3994    0.7198   0.555  0.57897     ## x1            2.1203    0.2018  10.507  < 2e-16 *** ## x2           -2.3451    0.7177  -3.268  0.00108 **  ##  ## Random effects: ##        Estimate Std.error z-value ## alpha  1.264733  0.020899  60.517 ## tau    0.054938  0.005454  10.073 ## kappa 15.887315  2.459045   6.461 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## nu     0.76473   0.02090  36.592 ## sigma  1.34775   0.13570   9.932 ## range  0.15569   0.02297   6.777 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev 0.097304  0.006313   15.41 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -126.9762  ## Number of function calls by 'optim' = 95 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  49.44455 secs print(data.frame(sigma = c(sigma, fit$matern_coeff$random_effects[2]),                     range = c(range, fit$matern_coeff$random_effects[3]),                    nu = c(nu, fit$matern_coeff$random_effects[1]),                    row.names = c(\"Truth\", \"Estimates\"))) ##              sigma    range        nu ## Truth     1.300000 0.150000 0.8000000 ## Estimates 1.347753 0.155686 0.7647331"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"kriging","dir":"Articles","previous_headings":"Using the model for inference","what":"Kriging","title":"Whittle--Matérn fields with general smoothness","text":"Given estimated parameters, let us compute kriging predictor field given observations mesh nodes. perform kriging predict() method. end, need provide data.frame containing prediction locations, well values covariates prediction locations. estimate shown following figure","code":"df_pred <- data.frame(edge_number = graph$mesh$VtE[,1],                         distance_on_edge = graph$mesh$VtE[,2],                         x1 = graph$mesh$VtE[,1],                         x2 = graph$mesh$VtE[,2])    u.krig <- predict(fit, data = df_pred, normalized = TRUE) graph$plot_function(as.vector(u.krig$mean))"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"fitting-a-model-with-replicates","dir":"Articles","previous_headings":"","what":"Fitting a model with replicates","title":"Whittle--Matérn fields with general smoothness","text":"Let us now illustrate simulate data set replicates fit model data. simulate latent model replicates, set nsim argument number replicates. Now, let us generate observed values \\(Y\\): Note \\(Y\\) matrix 20 columns, column containing one replicate. need turn y vector create auxiliary vector repl indexing replicates y: Let us clear previous observations add new data graph: can now fit model way using rspde_lme() function. Note can optimize parallel setting parallel TRUE. specify replicate consider, which_repl argument, replicates considered. Let us see summary fit: Let us compare values parameters latent model true ones:","code":"n.rep <- 30   u.rep <- simulate(op, nsim = n.rep) sigma.e <- 0.3   Y.rep <- A %*% u.rep + sigma.e * matrix(rnorm(n.obs * n.rep), ncol = n.rep) y_vec <- as.vector(Y.rep) repl <- rep(1:n.rep, each = n.obs)                         df_data_repl <- data.frame(y = y_vec,                                edge_number = rep(obs.loc[,1], n.rep),                               distance_on_edge = rep(obs.loc[,2], n.rep),                                repl = repl) graph$clear_observations() graph$add_observations(data = df_data_repl, normalized = TRUE, group = \"repl\") fit_repl <- graph_lme(y ~ -1, graph = graph, model = \"WM\", parallel = TRUE) ## Warning in sqrt(diag(inv_fisher)): NaNs produced summary(fit_repl) ##  ## Latent model - Whittle-Matern ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = \"WM\", parallel = TRUE) ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## alpha  1.26478       NaN     NaN ## tau    0.05824       NaN     NaN ## kappa 15.07311   0.42234   35.69 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## nu    0.764777       NaN     NaN ## sigma 1.323443  0.025389   52.13 ## range 0.164100  0.005047   32.51 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev 0.300756  0.002942   102.2 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -9741.821  ## Number of function calls by 'optim' = 65 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  3.73011 mins  ##   set up the parallelization = 1.72115 secs print(data.frame(sigma = c(sigma, fit_repl$matern_coeff$random_effects[2]),                     range = c(range, fit_repl$matern_coeff$random_effects[3]),                    nu = c(nu, fit_repl$matern_coeff$random_effects[1]),                    row.names = c(\"Truth\", \"Estimates\"))) ##              sigma     range        nu ## Truth     1.300000 0.1500000 0.8000000 ## Estimates 1.323443 0.1641003 0.7647766"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-the-r-inla-implementation","dir":"Articles","previous_headings":"","what":"Using the R-INLA implementation","title":"Whittle--Matérn fields with general smoothness","text":"also R-INLA implementation rational SPDE approach metric graphs. begin defining model using rspde.metric_graph() function. function contains arguments function rspde.matern(). refer reader R-INLA implementation rational SPDE approach vignette details. begin clearing previous observations adding observations (case without replicates) graph: Let us create model object: default, order rational approximation 2. can now create matrix index object using functions rational SPDE approach, namely, rspde.make.() rspde.make.index(), supplying graph object mesh argument. create matrix: Now, let us create index object: remaining standard: create formula object, stack object, fit model using inla() function. , first create formula object: Now create inla.stack object: Finally, can fit model: can use functions rspde fitted models inla. instance, can see results original scale creating result object: Let us compare true values: can also plot posterior marginal densities help gg_df() function:","code":"graph$clear_observations() graph$add_observations(data = df_data, normalized = TRUE) library(INLA)   rspde_model <- rspde.metric_graph(graph) Abar <- rspde.make.A(graph) rspde.index <- rspde.make.index(name=\"field\", mesh=graph) f.s <- y ~ -1 + Intercept + x1 + x2 + f(field, model = rspde_model) stk.dat <- inla.stack(     data = data.frame(y = graph_data_spde(rspde_model)$y), A = list(Abar,1), tag = \"est\",     effects =       list(c(         rspde.index,         list(Intercept = 1)), list(x1 = graph_data_spde(rspde_model)$x1 ,                                       x2 = graph_data_spde(rspde_model)$x2)       )     ) rspde_fit <- inla(f.s, data = inla.stack.data(stk.dat),     control.inla = list(int.strategy = \"eb\"),     control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE)   ) result_fit <- rspde.result(rspde_fit, \"field\", rspde_model)   summary(result_fit) ##             mean       sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.434130 0.156989   1.152330 1.424830   1.768270 1.406150 ## range   0.172064 0.037917   0.107929 0.168671   0.256181 0.162251 ## nu      0.761109 0.100732   0.576457 0.756316   0.970437 0.744261 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_fit$summary.std.dev$mean,       result_fit$summary.range$mean,       result_fit$summary.nu$mean     ),     mode = c(       result_fit$summary.std.dev$mode,       result_fit$summary.range$mode,       result_fit$summary.nu$mode     )   )   print(result_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.4341283 1.4061545 ## 2     range 0.15 0.1720637 0.1622513 ## 3        nu 0.80 0.7611088 0.7442606 posterior_df_fit <- gg_df(result_fit)    library(ggplot2)    ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"kriging-with-the-r-inla-implementation","dir":"Articles","previous_headings":"Using the R-INLA implementation","what":"Kriging with the R-INLA implementation","title":"Whittle--Matérn fields with general smoothness","text":"kriging mesh locations: Let us now add observations prediction: Let us compute matrix prediction locations: Let us build prediction stack gather estimation stack. end, set argument only_pred TRUE, return data.frame containing NA data. Let us obtain predictions: Let us now extract indices predicted nodes store means: Finally, let us plot predicted values. end use plot_function() graph method.","code":"pred_loc <- graph$mesh$VtE graph$add_observations(data = data.frame(y=rep(NA,nrow(pred_loc)),                                  edge_number = pred_loc[,1],                                  distance_on_edge = pred_loc[,2]),                                  normalized = TRUE) Abar_prd <- rspde.make.A(graph, loc=pred_loc) data_pred <- graph_data_spde(rspde_model, only_pred=TRUE)   ef.prd <-      list(c(rspde.index, list(Intercept = 1)),            list(x1 = data_pred[[\"__distance_on_edge\"]],                 x2 = data_pred[[\"__distance_on_edge\"]]^2))   stk.prd <- inla.stack(     data = data.frame(y = data_pred$y),     A = list(Abar_prd,1), tag = \"prd\",     effects = ef.prd   )   stk.all <- inla.stack(stk.dat, stk.prd) rspde_fitprd <- inla(f.s,   data = inla.stack.data(stk.all),   control.predictor = list(     A = inla.stack.A(stk.all),     compute = TRUE, link = 1   ),   control.compute = list(     return.marginals = FALSE,     return.marginals.predictor = FALSE   ),   control.inla = list(int.strategy = \"eb\") ) id.prd <- inla.stack.index(stk.all, \"prd\")$data m.prd <- rspde_fitprd$summary.fitted.values$mean[id.prd] graph$plot_function(m.prd, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-r-inla-implementation-to-fit-models-with-replicates","dir":"Articles","previous_headings":"","what":"Using R-INLA implementation to fit models with replicates","title":"Whittle--Matérn fields with general smoothness","text":"Let us begin cloning graph clearing observations cloned graph: now add data replicates graph: fit model replicates need create corresponding matrix index object: Similarly, let us create new rspde model object: Let us now create corresponding inla.stack object, set repl argument function graph_data_spde __all since want use replicates: Observe need response variable y vector. can now create formula object, remembering since gave name argument field, creating index, need pass field.repl formula: can, finally, fit model: can obtain estimates original scale rspde.result() function: Let us compare true values parameters: can also plot posterior marginal densities help gg_df() function:","code":"graph_rep <- graph$clone() graph_rep$clear_observations() graph_rep$add_observations(data = data.frame(y=as.vector(Y.rep),                            edge_number = rep(obs.loc[,1], n.rep),                            distance_on_edge = rep(obs.loc[,2], n.rep),                           repl = rep(1:n.rep, each = n.obs)),                            group = \"repl\",                           normalized = TRUE) Abar.rep <- rspde.make.A(   mesh = graph_rep, index = rep(1:n.obs, times = n.rep),   repl = rep(1:n.rep, each = n.obs) )  mesh.index.rep <- rspde.make.index(   name = \"field\", mesh = graph_rep,   n.repl = n.rep ) rspde_model_rep <- rspde.metric_graph(graph_rep) st.dat.rep <- inla.stack(   data = graph_data_spde(rspde_model_rep,                             repl = \"__all\"),   A = Abar.rep,   effects = mesh.index.rep ) f.rep <-   y ~ -1 + f(field,     model = rspde_model_rep,     replicate = field.repl   ) rspde_fit_rep <-   inla(f.rep,     data = inla.stack.data(st.dat.rep),     family = \"gaussian\",     control.predictor =       list(A = inla.stack.A(st.dat.rep))   ) result_fit_rep <- rspde.result(rspde_fit_rep, \"field\", rspde_model)   summary(result_fit_rep) ##             mean         sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.324180 0.02600500   1.274250 1.323740   1.376390 1.322580 ## range   0.161675 0.00779559   0.146203 0.161799   0.176759 0.162484 ## nu      0.781555 0.03686130   0.714937 0.779271   0.859126 0.772007 result_rep_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_fit_rep$summary.std.dev$mean,       result_fit_rep$summary.range$mean,       result_fit_rep$summary.nu$mean     ),     mode = c(       result_fit_rep$summary.std.dev$mode,       result_fit_rep$summary.range$mode,       result_fit_rep$summary.nu$mode     )   )   print(result_rep_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.3241753 1.3225817 ## 2     range 0.15 0.1616752 0.1624839 ## 3        nu 0.80 0.7815549 0.7720072 posterior_df_fit_rep <- gg_df(result_fit_rep)    ggplot(posterior_df_fit_rep) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-inlabru-implementation","dir":"Articles","previous_headings":"","what":"Using inlabru implementation","title":"Whittle--Matérn fields with general smoothness","text":"inlabru package allows us fit models kriging straighforward manner, without handle matrices, indices inla.stack objects. Therefore, suggest reader use implementation using implementation fit real data. Let us clear graph, since contains NA observations used prediction, add observations , create new rSPDE model object: Let us now load inlabru package create component (inlabru’s formula-like object). Since using data graph, inlabru also obtain locations graph, thus, need provide locations. However, need name locations using inlabru’s predict method. Therefore, can choose name location name used graph’s data. case use name loc: Now, can directly fit model, pass name location variable loc argument graph_data_spde() function: Let us now obtain estimates parameters original scale using rspde.result() function: Let us compare true values parameters: can also plot posterior marginal densities help gg_df() function:","code":"graph$clear_observations() graph$add_observations(data = df_data,                            normalized = TRUE) rspde_model <- rspde.metric_graph(graph) library(inlabru)     cmp <-     y ~ -1 + Intercept(1) + x1 + x2 + field(loc,                            model = rspde_model) rspde_bru_fit <-     bru(cmp,         data=graph_data_spde(rspde_model, loc = \"loc\"),       options=list(       family = \"gaussian\")     ) result_bru_fit <- rspde.result(rspde_bru_fit, \"field\", rspde_model)   summary(result_bru_fit) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.429640 0.1584300   1.145640 1.420100   1.767170 1.401070 ## range   0.171657 0.0379799   0.107998 0.168050   0.256535 0.160908 ## nu      0.763252 0.1017200   0.575170 0.759114   0.973103 0.748291 result_bru_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_bru_fit$summary.std.dev$mean,       result_bru_fit$summary.range$mean,       result_bru_fit$summary.nu$mean     ),     mode = c(       result_bru_fit$summary.std.dev$mode,       result_bru_fit$summary.range$mode,       result_bru_fit$summary.nu$mode     )   )   print(result_bru_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.4296392 1.4010701 ## 2     range 0.15 0.1716573 0.1609080 ## 3        nu 0.80 0.7632525 0.7482907 posterior_df_bru_fit <- gg_df(result_bru_fit)    ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"kriging-with-the-inlabru-implementation","dir":"Articles","previous_headings":"Using inlabru implementation","what":"Kriging with the inlabru implementation","title":"Whittle--Matérn fields with general smoothness","text":"easy kriging inlabru implementation. simply need provide prediction locations predict() method. example use mesh locations. end use get_mesh_locations() method. also set bru=TRUE loc=\"loc\" obtain data list suitable used inlabru. Now, can simply provide locations predict method along fitted object rspde_bru_fit: Finally, let us plot predicted values. end use plot_function() graph method:","code":"data_prd_list <- graph$get_mesh_locations(bru = TRUE,                                             loc = \"loc\")   data_prd_list[[\"x1\"]] <- data_prd_list$loc[,2]   data_prd_list[[\"x2\"]] <- data_prd_list$loc[,2]^2 field_pred <- predict(rspde_model, cmp, rspde_bru_fit, data=data_prd_list, ~field) plot(field_pred, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-inlabru-to-fit-models-with-replicates","dir":"Articles","previous_headings":"","what":"Using inlabru to fit models with replicates","title":"Whittle--Matérn fields with general smoothness","text":"can also use inlabru implementation fit models replicates. consider data generated , number replicates 30. implementation use rspde_model_rep object. can now create component, passing vector indices replicates replicate argument. replicate argument use function graph_repl_spde() extract vector replicates, set choose __all replicates, since want replicates. Now, ready fit model. Observe set repl argument __all since use replicates loc argument loc, name gave locations. can obtain estimates original scale rspde.result() function: Let us compare true values parameters: can also plot posterior marginal densities help gg_df() function:","code":"cmp_rep <-     y ~ -1 + field(loc, model = rspde_model_rep,                               replicate = graph_repl_spde(rspde_model_rep, \"__all\")) rspde_bru_fit_rep <-     bru(cmp_rep,         data=graph_data_spde(rspde_model_rep,                           repl = \"__all\",                          loc = \"loc\"),       options=list(       family = \"gaussian\")     ) result_bru_fit_rep <- rspde.result(rspde_bru_fit_rep, \"field\", rspde_model)   summary(result_bru_fit_rep) ##             mean         sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.324190 0.02612760   1.273890 1.323820   1.376520 1.322910 ## range   0.161935 0.00761059   0.147387 0.161797   0.177278 0.161604 ## nu      0.780561 0.03597480   0.711647 0.779905   0.852876 0.778070 result_bru_rep_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_bru_fit_rep$summary.std.dev$mean,       result_bru_fit_rep$summary.range$mean,       result_bru_fit_rep$summary.nu$mean     ),     mode = c(       result_bru_fit_rep$summary.std.dev$mode,       result_bru_fit_rep$summary.range$mode,       result_bru_fit_rep$summary.nu$mode     )   )   print(result_bru_rep_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.3241904 1.3229095 ## 2     range 0.15 0.1619348 0.1616042 ## 3        nu 0.80 0.7805607 0.7780699 posterior_df_bru_fit_rep <- gg_df(result_bru_fit_rep)    ggplot(posterior_df_bru_fit_rep) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"vignette present R-INLA interface Whittle–Matérn fields. underlying theory approach provided Bolin, Simas, Wallin (2022) Bolin, Simas, Wallin (2023). introduction metric_graph class, please see Working metric graphs vignette. simplification R-INLA interface, see inlabru interface Whittle–Matérn fields vignette. Gaussian random fields metric graphs vignette, introduce models metric graphs contained package, well , perform statistical tasks models, without R-INLA inlabru interfaces. present R-INLA interface Whittle-Matérn fields providing step--step illustration. Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"a-toy-dataset","dir":"Articles","previous_headings":"","what":"A toy dataset","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"Let us begin loading MetricGraph package creating metric graph: Let us add 50 random locations edge observations: now sample observation locations plot latent field:  Let us now generate observed responses, call y. also plot observed responses metric graph.","code":"library(MetricGraph) library(sp)  line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0),c(0,1))) line3 <- Line(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 20) line4 <- Line(cbind(sin(theta),1+ cos(theta))) Lines = sp::SpatialLines(list(Lines(list(line1),ID=\"1\"),                               Lines(list(line2),ID=\"2\"),                               Lines(list(line4),ID=\"3\"),                               Lines(list(line3),ID=\"4\"))) graph <- metric_graph$new(lines = Lines) obs_per_edge <- 50 obs_loc <- NULL for(i in 1:(graph$nE)) {   obs_loc <- rbind(obs_loc,                    cbind(rep(i,obs_per_edge),                     runif(obs_per_edge))) } sigma <- 2 alpha <- 1 nu <- alpha - 0.5 r <- 0.15 # r stands for range   u <- sample_spde(range = r, sigma = sigma, alpha = alpha,                  graph = graph, PtE = obs_loc) graph$plot(X = u, X_loc = obs_loc) n_obs <- length(u) sigma.e <- 0.1  y <- u + sigma.e * rnorm(n_obs) graph$plot(X = y, X_loc = obs_loc)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"r-inla-implementation","dir":"Articles","previous_headings":"","what":"R-INLA implementation","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"now position fit model R-INLA implementation. end, need add observations graph, add_observations() method.  Now, load R-INLA package create inla model object graph_spde function. default alpha=1. Now, need create index object graph_spde_make_index() function: Observe , R-INLA, need name field. next step create observation matrix, use graph_spde_make_A() function: remaining standard R-INLA. create formula object inla.stack object inla.stack() function. data needs graph (using add_observations() method) supplied stack using graph_spde_data() function. Now, use inla.stack.data() function: Finally, fit model: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:","code":"df_graph <- data.frame(y = y, edge_number = obs_loc[,1],                         distance_on_edge = obs_loc[,2]) # Adding observations and turning them to vertices graph$add_observations(data=df_graph, normalized=TRUE) graph$plot(data=\"y\") library(INLA) spde_model <- graph_spde(graph) spde_index <- graph_spde_make_index(name=\"field\", graph_spde=spde_model) A <- graph_spde_make_A(spde_model) f.s <- y ~ -1 + Intercept + f(field, model = spde_model)  stk_dat <- inla.stack(data = graph_data_spde(spde_model),                          A = A,                          effects = c(       spde_index,       list(Intercept = 1)     )) data_stk <- inla.stack.data(stk_dat) spde_fit <- inla(f.s, data = data_stk) ## Warning in inla.model.properties.generic(inla.trim.family(model), mm[names(mm) == : Model 'cgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time. ##   Use this model with extra care!!! Further warnings are disabled. spde_result <- spde_metric_graph_result(spde_fit, \"field\", spde_model)  summary(spde_result) ##           mean        sd 0.025quant 0.5quant 0.975quant    mode ## sigma 2.027330 0.2009530  1.6642700 2.015030   2.456070 1.98477 ## range 0.146785 0.0334587  0.0943202 0.142123   0.225019 0.13243 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_result$summary.sigma$mean,       spde_result$summary.range$mean     ),     mode = c(       spde_result$summary.sigma$mode,       spde_result$summary.range$mode     )   )   print(result_df) ##   parameter true      mean      mode ## 1   std.dev 2.00 2.0273335 1.9847682 ## 2     range 0.15 0.1467846 0.1324304 posterior_df_fit <- gg_df(spde_result)    library(ggplot2)    ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"kriging-with-our-inla-implementation","dir":"Articles","previous_headings":"R-INLA implementation","what":"Kriging with our INLA implementation","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"Let us begin obtaining evenly spaced mesh respect base graph: Let us plot resulting graph:  now add observations mesh locations graph fitted R-INLA model. end use add_mesh_observations() method. enter response variables NA. can get number mesh nodes counting number rows mesh$PtE attribute. now fit new model R-INLA new graph contains prediction locations. end, create new model object graph_spde() function: Now, let us create new index object new observation (): create new vector response variables, concatenating y y_prd, create new formula object inla.stack object: Now, use inla.stack.data() function fit model: now extract means prediction locations: improve visualization, plot posterior means using plot() method:  Finally, can plot predictions together data:","code":"obs_per_edge_prd <- 50 graph$build_mesh(n = obs_per_edge_prd) graph$plot(mesh=TRUE) n_obs_mesh <- nrow(graph$mesh$PtE) y_prd <- rep(NA, n_obs_mesh) data_mesh <- data.frame(y = y_prd) graph$add_mesh_observations(data = data_mesh) spde_model_prd <- graph_spde(graph) spde_index_prd <- graph_spde_make_index(name=\"field\",                              graph_spde=spde_model_prd)  A_prd <- graph_spde_make_A(graph_spde = spde_model_prd) f_s_prd <- y ~ -1 + Intercept + f(field, model = spde_model_prd)  stk_dat_prd <- inla.stack(data = graph_data_spde(spde_model_prd),                          A = A_prd,                          effects = c(       spde_index_prd,       list(Intercept = 1)     )) data_stk_prd <- inla.stack.data(stk_dat_prd)  spde_fit_prd <- inla(f_s_prd, data = data_stk_prd) idx_prd <- which(is.na(graph_data_spde(spde_model_prd)[[\"y\"]]))  m_prd <- spde_fit_prd$summary.fitted.values$mean[idx_prd] graph$plot_function(m_prd, vertex_size = 0, edge_width = 2) p <- graph$plot_function(X = m_prd, vertex_size = 0, edge_width = 1) graph$plot(data=\"y\", vertex_size = 0, data_size = 2, p = p, edge_width = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"fitting-r-inla-models-with-replicates","dir":"Articles","previous_headings":"R-INLA implementation","what":"Fitting R-INLA models with replicates","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"now illustrate use R-INLA implementation fit models replicates. simplify exposition, use base graph. , begin clearing observations. use observation locations previous cases. Let us sample 30 replicates: Let us now generate observed responses, call y_rep. sample_spde() function returns matrix replicate column. need stack columns together column indicate replicate: can now add observations setting group argument repl: definition plot() method plots first replicate. can select replicates group argument. See Working metric graphs details.  Let us plot another replicate:  Let us now create model object: Let us first consider case use replicates. , consider case use replicates. Thus, let us assume want consider replicates 1, 3, 5, 7 9. end, index object using graph_spde_make_index() function argument n.repl set number replicates want, case 5: Similarly, create observation () matrix function graph_spde_make_A() setting repl argument replicates want: Next, create stack object, remembering need input data argument function graph_data_spde(). , determine replicates want repl argument. now create formula object, adding name field (case field) attached .repl replicate argument inside f() function. , create stack object inla.stack.data() function: Now, fit model: Let us see estimated values original scale: Let us compare true values: Now, let us consider case replicates. create new index object using graph_spde_make_index() function argument n.repl set total number replicates: Similarly, create new observation () matrix function graph_spde_make_A() setting repl argument __all: Now stack, set repl argument function graph_data_spde() __all: now create formula object way : , create stack object inla.stack.data() function: Now, fit model: Let us see estimated values original scale: Let us compare true values:","code":"graph$clear_observations() sigma_rep <- 1.5 alpha_rep <- 1 nu_rep <- alpha_rep - 0.5 r_rep <- 0.2 # r stands for range kappa_rep <- sqrt(8 * nu_rep) / r_rep  n_repl <- 30  u_rep <- sample_spde(range = r_rep, sigma = sigma_rep,                  alpha = alpha_rep,                  graph = graph, PtE = obs_loc,                  nsim = n_repl) n_obs_rep <- nrow(u_rep) sigma_e <- 0.1  y_rep <- u_rep + sigma_e * matrix(rnorm(n_obs_rep * n_repl),                                     ncol=n_repl) dl_graph <- lapply(1:ncol(y_rep), function(i){data.frame(y = y_rep[,i],                                           edge_number = obs_loc[,1],                                           distance_on_edge = obs_loc[,2],                                           repl = i)}) dl_graph <- do.call(rbind, dl_graph) graph$add_observations(data = dl_graph, normalized=TRUE,                              group = \"repl\",                             edge_number = \"edge_number\",                             distance_on_edge = \"distance_on_edge\") graph$plot(data=\"y\") graph$plot(data=\"y\", group=2) spde_model_rep <- graph_spde(graph) spde_index_rep <- graph_spde_make_index(name=\"field\",                      graph_spde=spde_model_rep,                      n.repl = 5) A_rep <- graph_spde_make_A(graph_spde=spde_model_rep,                              repl = c(1,3,5,7,9)) stk_dat_rep <- inla.stack(data = graph_data_spde(spde_model_rep,                                   repl = c(1,3,5,7,9)),                          A = A_rep,                          effects = c(       spde_index_rep,       list(Intercept = 1)     )) f_s_rep <- y ~ -1 + Intercept +      f(field, model = spde_model_rep,          replicate = field.repl) data_stk_rep <- inla.stack.data(stk_dat_rep) spde_fit_rep <- inla(f_s_rep, data = data_stk_rep) spde_result_rep <- spde_metric_graph_result(spde_fit_rep,                          \"field\", spde_model_rep)  summary(spde_result_rep) ##          mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.36346 0.0619210   1.248200 1.361680   1.489460 1.342140 ## range 0.15372 0.0154831   0.126133 0.152684   0.186837 0.150422 result_df_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_rep$summary.sigma$mean,       spde_result_rep$summary.range$mean     ),     mode = c(       spde_result_rep$summary.sigma$mode,       spde_result_rep$summary.range$mode     )   )   print(result_df_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.3634564 1.3421440 ## 2     range  0.2 0.1537203 0.1504216 spde_index_rep <- graph_spde_make_index(name=\"field\",                      graph_spde=spde_model_rep,                      n.repl = n_repl) A_rep <- graph_spde_make_A(graph_spde=spde_model_rep,                             repl=\"__all\") stk_dat_rep <- inla.stack(data = graph_data_spde(spde_model_rep,                                           repl = \"__all\"),                          A = A_rep,                          effects = c(       spde_index_rep,       list(Intercept = 1)     )) f_s_rep <- y ~ -1 + Intercept +      f(field, model = spde_model_rep,          replicate = field.repl) data_stk_rep <- inla.stack.data(stk_dat_rep) spde_fit_rep <- inla(f_s_rep, data = data_stk_rep) spde_result_rep <- spde_metric_graph_result(spde_fit_rep,                          \"field\", spde_model_rep)  summary(spde_result_rep) ##           mean         sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.479500 0.03033480   1.421790 1.478560   1.539580 1.471690 ## range 0.186062 0.00852288   0.169929 0.185836   0.203413 0.185369 result_df_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_rep$summary.sigma$mean,       spde_result_rep$summary.range$mean     ),     mode = c(       spde_result_rep$summary.sigma$mode,       spde_result_rep$summary.range$mode     )   )   print(result_df_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.4794972 1.4716905 ## 2     range  0.2 0.1860624 0.1853688"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"inlabru interface of Whittle--Matérn fields","text":"vignette present inlabru interface Whittle–Matérn fields. underlying theory approach provided Bolin, Simas, Wallin (2022) Bolin, Simas, Wallin (2023). introduction metric_graph class, please see Working metric graphs vignette. R-INLA interface, see INLA interface Whittle–Matérn fields vignette. Gaussian random fields metric graphs vignette, introduce models metric graphs contained package, well , perform statistical tasks models, without R-INLA inlabru interfaces. present inlabru interface Whittle-Matérn fields providing step--step illustration. Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"a-toy-dataset","dir":"Articles","previous_headings":"","what":"A toy dataset","title":"inlabru interface of Whittle--Matérn fields","text":"Let us begin loading MetricGraph package creating metric graph: Let us add 50 random locations edge observations: now sample observation locations plot latent field:  Let us now generate observed responses, call y. also plot observed responses metric graph.","code":"library(MetricGraph) library(sp)  line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0),c(0,1))) line3 <- Line(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 20) line4 <- Line(cbind(sin(theta),1+ cos(theta))) Lines = sp::SpatialLines(list(Lines(list(line1),ID=\"1\"),                               Lines(list(line2),ID=\"2\"),                               Lines(list(line4),ID=\"3\"),                               Lines(list(line3),ID=\"4\"))) graph_bru <- metric_graph$new(lines = Lines) obs_per_edge <- 50 obs_loc <- NULL for(i in 1:(graph_bru$nE)) {   obs_loc <- rbind(obs_loc,                    cbind(rep(i,obs_per_edge),                     runif(obs_per_edge))) } sigma <- 2 alpha <- 1 nu <- alpha - 0.5 r <- 0.15 # r stands for range  u <- sample_spde(range = r, sigma = sigma, alpha = alpha,                  graph = graph_bru, PtE = obs_loc) graph_bru$plot(X = u, X_loc = obs_loc) n_obs <- length(u) sigma.e <- 0.1  y <- u + sigma.e * rnorm(n_obs) graph_bru$plot(X = y, X_loc = obs_loc)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"inlabru-implementation","dir":"Articles","previous_headings":"","what":"inlabru implementation","title":"inlabru interface of Whittle--Matérn fields","text":"now present inlabru implementation Whittle-Matérn fields metric graphs. advantage, R-INLA implementation, requiring user provide observation matrices, indices stack objects. now position fit model inlabru implementation. end, need add observations graph, add_observations() method.  Now, load INLA inlabru packages. also need create inla model object graph_spde function. default alpha=1. Now, create inlabru’s component, formula-like object. index parameter inlabru used implementation, thus, replace repl argument, tells replicates use. replicates, supply NULL. Now, directly fit model: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:","code":"# Creating the data frame df_graph <- data.frame(y = y, edge_number = obs_loc[,1],                       distance_on_edge = obs_loc[,2]) # Adding observations and turning them to vertices graph_bru$add_observations(data = df_graph, normalized=TRUE) graph_bru$plot(data=\"y\") library(INLA) library(inlabru) spde_model_bru <- graph_spde(graph_bru) cmp <-     y ~ -1 + Intercept(1) + field(loc,                     model = spde_model_bru) spde_bru_fit <-     bru(cmp, data=graph_data_spde(spde_model_bru, loc = \"loc\")) ## Warning in inla.model.properties.generic(inla.trim.family(model), mm[names(mm) == : Model 'cgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time. ##   Use this model with extra care!!! Further warnings are disabled. spde_bru_result <- spde_metric_graph_result(spde_bru_fit,                      \"field\", spde_model_bru)  summary(spde_bru_result) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 2.021510 0.1987150  1.6670900 2.009270   2.448220 2.012400 ## range 0.146785 0.0334884  0.0942041 0.142148   0.225059 0.132511 result_df_bru <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_bru_result$summary.sigma$mean,       spde_bru_result$summary.range$mean     ),     mode = c(       spde_bru_result$summary.sigma$mode,       spde_bru_result$summary.range$mode     )   )   print(result_df_bru) ##   parameter true      mean      mode ## 1   std.dev 2.00 2.0215142 2.0124013 ## 2     range 0.15 0.1467851 0.1325112 posterior_df_bru_fit <- gg_df(spde_bru_result)    library(ggplot2)    ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"kriging-with-the-inlabru-implementation","dir":"Articles","previous_headings":"inlabru implementation","what":"Kriging with the inlabru implementation","title":"inlabru interface of Whittle--Matérn fields","text":"Unfortunately, inlabru implementation compatible inlabru’s predict() method. nature metric graph’s object. end, provided different predict() method. now show kriging help function. begin creating data list positions want predictions. case, want predictions mesh. Let us begin obtaining evenly spaced mesh respect base graph: Let us plot resulting graph:  positions want mesh positions, can obtained using get_mesh_locations() method. also set bru=TRUE loc=\"loc\" obtain data list suitable used inlabru. can now obtain predictions using predict() method. Observe predict() method graph models bit different inlabru’s standard predict() method. Indeed, first argument model created graph_spde() function, second inlabru’s component, remaining done standard predict() method inlabru. Finally, can plot predictions together data:  can also obtain 3d plot setting plotly TRUE:","code":"obs_per_edge_prd <- 50 graph_bru$build_mesh(n = obs_per_edge_prd) graph_bru$plot(mesh=TRUE) data_list <- graph_bru$get_mesh_locations(bru = TRUE,                                             loc = \"loc\") field_pred <- predict(spde_model_bru,                                  cmp,                                 spde_bru_fit,                                  data = data_list,                                 formula = ~field) plot(field_pred) plot(field_pred, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"fitting-inlabru-models-with-replicates","dir":"Articles","previous_headings":"inlabru implementation","what":"Fitting inlabru models with replicates","title":"inlabru interface of Whittle--Matérn fields","text":"now illustrate use inlabru implementation fit models replicates. simplify exposition, use base graph. , begin clearing observations: use observation locations previous cases. Let us sample 30 replicates: Let us now generate observed responses, call y_rep. can now add observations setting group argument repl: definition plot() method plots first replicate. can select replicates group argument. See Working metric graphs details.  Let us plot another replicate:  Let us now create model object: Let us first create model using replicates 1, 3, 5, 7 9. end, provide vector replicates want input argument field. created helper function, namely bru_graph_rep() help building vector: Now, fit model, setting repl argument replicates want inside graph_data_spde() function: Let us see estimated values original scale: Let us compare true values: now show fit model considering replicates. end, simply set argument bru_graph_rep() function __all. Similarly, fit model, setting repl argument “__all” inside graph_data_spde() function: Let us see estimated values original scale: Let us compare true values:","code":"graph_bru$clear_observations() sigma_rep <- 1.5 alpha_rep <- 1 nu_rep <- alpha_rep - 0.5 r_rep <- 0.2 # r stands for range  n_repl <- 30  u_rep <- sample_spde(range = r_rep, sigma = sigma_rep,                  alpha = alpha_rep,                  graph = graph_bru, PtE = obs_loc,                  nsim = n_repl) n_obs_rep <- nrow(u_rep) sigma_e <- 0.1  y_rep <- u_rep + sigma_e * matrix(rnorm(n_obs_rep * n_repl),                                     ncol=n_repl) dl_rep_graph <- lapply(1:ncol(y_rep), function(i){data.frame(y = y_rep[,i],                                           edge_number = obs_loc[,1],                                           distance_on_edge = obs_loc[,2],                                           repl = i)}) dl_rep_graph <- do.call(rbind, dl_rep_graph)  graph_bru$add_observations(data = dl_rep_graph, normalized=TRUE,                                     group = \"repl\") graph_bru$plot(data=\"y\") graph_bru$plot(data=\"y\", group=2) spde_model_bru_rep <- graph_spde(graph_bru) repl <- bru_graph_rep(c(1,3,5,7,9), spde_model_bru_rep) cmp_rep <-     y ~ -1 + Intercept(1) + field(loc,                          model = spde_model_bru_rep,                         replicate = repl) spde_bru_fit_rep <-     bru(cmp_rep,         data=graph_data_spde(spde_model_bru_rep, loc = \"loc\",         repl=c(1,3,5,7,9))) spde_result_bru_rep <- spde_metric_graph_result(spde_bru_fit_rep,                          \"field\", spde_model_bru_rep)  summary(spde_result_bru_rep) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.526390 0.0790433   1.379840 1.522990   1.692560 1.523060 ## range 0.220395 0.0259321   0.174727 0.218511   0.276451 0.214269 result_df_bru_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_bru_rep$summary.sigma$mean,       spde_result_bru_rep$summary.range$mean     ),     mode = c(       spde_result_bru_rep$summary.sigma$mode,       spde_result_bru_rep$summary.range$mode     )   )   print(result_df_bru_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.5263912 1.5230625 ## 2     range  0.2 0.2203951 0.2142688 repl <- bru_graph_rep(\"__all\", spde_model_bru_rep) cmp_rep <-     y ~ -1 + Intercept(1) + field(loc,                          model = spde_model_bru_rep,                         replicate = repl) spde_bru_fit_rep <-     bru(cmp_rep,         data=graph_data_spde(spde_model_bru_rep,          loc = \"loc\",         repl=\"__all\")) spde_result_bru_rep <- spde_metric_graph_result(spde_bru_fit_rep,                          \"field\", spde_model_bru_rep)  summary(spde_result_bru_rep) ##           mean         sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.528380 0.03189300   1.469210 1.527730   1.592780 1.523850 ## range 0.207526 0.00970054   0.189739 0.207034   0.227807 0.205828 result_df_bru_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_bru_rep$summary.sigma$mean,       spde_result_bru_rep$summary.range$mean     ),     mode = c(       spde_result_bru_rep$summary.sigma$mode,       spde_result_bru_rep$summary.range$mode     )   )   print(result_df_bru_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.5283808 1.5238493 ## 2     range  0.2 0.2075264 0.2058283"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Working with metric graphs","text":"Networks street river networks examples metric graphs. compact metric graph \\(\\Gamma\\) consists set finitely many vertices \\(\\mathcal{V}=\\{v_i\\}\\) finite set \\(\\mathcal{E}=\\{e_j\\}\\) edges connecting vertices. edge \\(e\\) curve finite length \\(l_e\\) connects two vertices. curves parameterized arc length location \\(s\\\\Gamma\\) position edge, can thus represented touple \\((e,t)\\) \\(t\\[0,l_e]\\). Compared regular graphs, one typically defines functions vertices, metric graphs interested function defined vertices edges. vignette introduce metric_graph class MetricGraph package. class provides user friendly representation metric graphs, show use class construct visualize metric graphs, add data , work functions defined graphs. details Gaussian processes inference metric graphs, refer Vignettes Gaussian random fields metric graphs INLA interface Whittle–Matérn fields inlabru interface Whittle–Matérn fields Whittle–Matérn fields general smoothness","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"basic-constructions-and-properties","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Basic constructions and properties","title":"Working with metric graphs","text":"metric graph can constructed two ways. first specify edges graph SpatialLines object using sp package. illustrate , first load sp package construct following lines can now create graph based Lines object follows  plot function used create plot various parameters set sizes colors vertices edges, plotly argument visualize graph 3D. work, plotly library must installed. also important know 2d version plot() method returns ggplot2 object can modified . instance:  Similarly, 3d version plot() method returns plotly object can also modified. instance: can now obtain various properties graph: vertex matrix, specifies Euclidian coordinates vertices edge matrix specified edges graph (.e., vertices connected lines) obtain geodesic (shortest path) distance vertices, can use function compute_geodist: second option construct graph using two matrices V E specify locations (Euclidean space) vertices edges. case, assumed graph straight lines:","code":"library(sp) line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0),c(0,1))) line3 <- Line(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 50) line4 <- Line(cbind(sin(theta),1+ cos(theta))) Lines = sp::SpatialLines(list(Lines(list(line1),ID=\"1\"),                               Lines(list(line2),ID=\"2\"),                               Lines(list(line3),ID=\"3\"),                               Lines(list(line4),ID=\"4\"))) graph <- metric_graph$new(lines = Lines) graph$plot() graph$plot(plotly = TRUE, vertex_size = 5, vertex_color = \"blue\",            edge_color = \"red\", edge_width = 2) p <- graph$plot() p + ggplot2::labs(title = \"Metric graph\",           x = \"long\", y = \"lat\") p <- graph$plot(plotly = TRUE) p <- plotly::layout(p, title = \"Metric graph\",                scene = list(xaxis=               list(title = \"Long\"),yaxis=list(title = \"Lat\"))) p graph$V ##      [,1] [,2] ## [1,]    0    0 ## [2,]    1    0 ## [3,]    0    1 ## [4,]   -1    1 graph$E ##      [,1] [,2] ## [1,]    1    2 ## [2,]    1    3 ## [3,]    3    4 ## [4,]    1    4 graph$compute_geodist() graph$geo_dist ## $`__vertices` ##          [,1]     [,2] [,3]     [,4] ## [1,] 0.000000 1.000000    1 1.570729 ## [2,] 1.000000 0.000000    2 2.570729 ## [3,] 1.000000 2.000000    0 1.000000 ## [4,] 1.570729 2.570729    1 0.000000 V <- rbind(c(0, 0), c(1, 0), c(0, 1), c(-1, 1)) E <- rbind(c(1, 2), c(1, 3), c(3, 4), c(4, 1)) graph2 <- metric_graph$new(V = V, E = E) graph2$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"tolerances-for-the-merging-vertices-and-lines","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Tolerances for the merging vertices and lines","title":"Working with metric graphs","text":"constructor graph one argument tolerance used connecting lines close Euclidean space. Specifically, tolerance argument given list three elements: vertex_vertex vertices closer number merged (default value 1e-7) vertex_line vertex end one line closer number another line, vertex connected line (default value 1e-7) line_line two lines point closer number, new vertex added point two lines connected (default value 0 means option used) options often needed constructing graphs based real data, example OpenStreetMap see later. illustrate options, suppose want construct graph following three lines:  added option degree=TRUE plot visualize degrees vertex. expected, one sees vertices degree 1, none three lines connected. streets street network, one might suspect two vertices \\((0,0)\\) \\((0,0.03)\\) really vertex two lines connected. can adjusted increasing vertex_vertex tolerance:  One might also want add vertex \\((0.5, 0.03)\\) vertex first line, two lines connected. can done adjusting vertex_line tolerance:  can see vertex \\((0.5,0)\\) indeed connected edge \\((0,0)\\) \\((1,0)\\) vertex now degree 3 since connected three edges. One can also note lines object used create graph modified internally metric_graph object connections visualized correctly sense edges actually shown connected lines. modification might take time large graphs many lines, , lines object default modified graph less 100 lines, otherwise modified. Whether modified can set via argument adjust_lines:  lines object modified, graph correct plot might show graph connected even though . Finally, add vertex intersection line2 line3 can adjust line_line tolerance:  Now, structure metric graph change add remove vertices degree 2. ,one might want remove vertices degree 2 since can reduce computational costs. can done setting remove_deg2 argument creating graph:","code":"line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0.03),c(0,1))) line3 <- Line(rbind(c(-1,1),c(0.5,0.03))) lines = SpatialLines(list(Lines(list(line1),ID=\"1\"),                           Lines(list(line2),ID=\"2\"),                           Lines(list(line3),ID=\"3\"))) graph3 <- metric_graph$new(lines = lines) ## The graph is disconnected. You can use the function 'graph_components' to obtain the different connected components. graph3$plot(degree = TRUE) print(graph3$nV) ## [1] 6 graph3 <- metric_graph$new(lines = lines, tolerance = list(vertex_vertex = 0.05)) ## The graph is disconnected. You can use the function 'graph_components' to obtain the different connected components. graph3$plot(degree = TRUE) graph3 <- metric_graph$new(lines = lines, tolerance = list(vertex_vertex = 0.05,                                                            vertex_line = 0.1)) graph3$plot(degree = TRUE) graph3 <- metric_graph$new(lines = lines, tolerance = list(vertex_vertex = 0.05,                                                            vertex_line = 0.1),                            adjust_lines = FALSE) graph3$plot(degree = TRUE) graph3 <- metric_graph$new(lines = lines, tolerance = list(vertex_vertex = 0.2,                                                            vertex_line = 0.1,                                                            line_line = 0.001)) graph3$plot(degree = TRUE) graph3 <- metric_graph$new(lines = lines, tolerance = list(vertex_vertex = 0.2,                                                            vertex_line = 0.1,                                                            line_line = 0.001),                            remove_deg2 = TRUE) graph3$plot(degree = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"understanding-coordinates-on-graphs","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Understanding coordinates on graphs","title":"Working with metric graphs","text":"locations vertices specified Euclidean coordinates. However, specifying position graph, practical work Euclidean coordinates since locations Euclidean space locations graph. instead better specify location graph touple \\((, t)\\), \\(\\) denotes number edge \\(t\\) location edge. location \\(t\\) can either specified distance start edge (takes values 0 length edge) normalized distance start edge (takes values 0 1). function coordinates can used convert coordinates Euclidean space locations graph. example location distance 0.2 start second edge : case, since edge length 1, location point normalized distance 0.2 start edge : function can also used find closest location graph location Euclidean space: case, normalized argument decides whether returned value given normalized distance .","code":"graph$coordinates(PtE = matrix(c(2, 0.2), 1,2), normalized = FALSE) ##      [,1] [,2] ## [1,]    0  0.2 graph$coordinates(PtE = matrix(c(2, 0.2), 1,2), normalized = TRUE) ##      [,1] [,2] ## [1,]    0  0.2 graph$coordinates(XY = matrix(c(0, 0.2), 1,2)) ##      [,1] [,2] ## [1,]    1    0"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"methods-for-working-with-real-data","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Methods for working with real data","title":"Working with metric graphs","text":"illustrate useage metric_graph real data, use osmdata package download data OpenStreetMap. following code, extract highways city Copenhagen:  things note data like . first coordinates given Longitude Latitude. , edge lengths default given degrees, may result small numbers: may cause numerical instabilities dealing random fields graph, also makes difficult interpret results (unless one good intuition distances degrees). avoid problems, better set longlat argument constructing graph: tells constructor coordinates given Longitude Latitude distances calculated km. now look edge lengths, given km: second thing note constructor gave warning graph connected. might ideal modeling may want study different connected components separately. concern, one can set argument check_connected = FALSE creating graph. case check done warning message printed. construct connected components, can create graph_components object: graph_components class contains list metric_graph objects, one connected component. case, components total, total edge lengths km plot , can use plot command class:  One reason multiple components might set tolerance merging nodes low. fact, looking edge lengths see vertices close meters. Let us increase tolerances vertices distance 20 meters (0.02km) apart merged, vertices withing 20 meters lines merged :  choice, see graph connected: However, since adjust_vertices argument default FALSE size graphs, plot graph might look disconnected places vertices merged. can retrieve graphas standard metric_graph object work analysis via get_largest command:","code":"library(osmdata) ## Data (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright set_overpass_url(\"https://maps.mail.ru/osm/tools/overpass/api/interpreter\") call <- opq(bbox = c(12.4,55.5,12.65,55.9)) call <- add_osm_feature(call, key = \"highway\",value=c(\"motorway\", \"primary\",                                                       \"secondary\")) data <- osmdata_sp(call)  graph5 <- metric_graph$new(SpatialLines(data$osm_lines@lines)) ## The graph is disconnected. You can use the function 'graph_components' to obtain the different connected components. graph5$plot(vertex_size = 0) range(graph5$edge_lengths) ## [1] 4.920366e-06 1.115746e-01 graph5 <- metric_graph$new(SpatialLines(data$osm_lines@lines), longlat = TRUE) ## The graph is disconnected. You can use the function 'graph_components' to obtain the different connected components. range(graph5$edge_lengths) ## [1] 4.733358e-04 1.120969e+01 graphs <- graph_components$new(SpatialLines(data$osm_lines@lines), longlat = TRUE) graphs$n ## [1] 13 graphs$lengths ##  [1] 179.38215236 113.27654524  37.81672291  10.74757337  10.67854187 ##  [6]   9.41059609   8.96001745   8.72277800   4.28810613   4.18299106 ## [11]   1.90370343   0.07721604   0.03892546 graphs$plot(vertex_size = 0) min(graph5$edge_lengths) * 1000 ## [1] 0.4733358 graphs <- graph_components$new(SpatialLines(data$osm_lines@lines), longlat = TRUE,                                tolerance = list(vertex_vertex = 0.02,                                                 vertex_line = 0.02)) graphs$plot(vertex_size = 0) graphs$n ## [1] 1 graph5 <- graphs$get_largest()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"adding-data-to-the-graph","dir":"Articles","previous_headings":"","what":"Adding data to the graph","title":"Working with metric graphs","text":"Given constructed metric graph, can now add data . example, let us consider first graph suppose observations distance 0.5 start edge. One way specifying follows  certain situations, might easier specify relative distances edges, 0 represents start 1 end edge (instead edge length). , can simply specify normalized = TRUE adding observations. example, let us add one observation midpoint fourth edge:  alternative method specify observations spatial points objects, locations given Euclidean coordinates. case observations added closes location graph:  want replace data object, can use clear_observations() remove current data: metric_graph object can hold multiple variables data, one can also specify group argument useful specifying data grouped, example case data observed different time points. example, let us add two variables observed two separate time points: NA given variable, indicates specific variable measured location group. can now plot individual variables specifying names plot function together group number want see. default first group shown.  cases, might want add observation locations vertices graph. can done follows:  One can note command adds observation locations, groups vertices.","code":"obs.loc <- cbind(1:4, rep(0.5, 4)) obs <- c(1,2,3,4) df_graph <- data.frame(y = obs, edge_number = obs.loc[,1],                          distance_on_edge = obs.loc[,2]) graph$add_observations(data = df_graph) graph$plot(data = \"y\", data_size = 2) obs.loc <- matrix(c(4, 0.5),1,2) obs <- c(5) df_new <- data.frame(y=obs, edge_number = obs.loc[,1],                            distance_on_edge = obs.loc[,2]) graph$add_observations(data=df_new, normalized = TRUE) graph$plot(data = \"y\") obs.loc <- rbind(c(0.7, 0), c(0, 0.2)) obs <- c(6,7) points <- SpatialPointsDataFrame(coords = obs.loc,                                  data = data.frame(y = obs)) graph$add_observations(points) graph$plot(data = \"y\") graph$clear_observations() obs.loc <- cbind(c(1:4, 1:4), c(rep(0.5, 4), rep(0.7, 4))) df_rep <- data.frame(y = c(1, 2, NA, 3, 4, 6, 5, 7),                      x = c(NA, 8, 9, 10, 11, 12, 13, NA),                      edge_number = obs.loc[,1],                       distance_on_edge = obs.loc[,2],                      time = c(rep(1, 4), rep(2, 4))) graph$add_observations(data = df_rep, group = \"time\") graph$plot(data = \"y\", group = 2) graph$observation_to_vertex() graph$plot(data = \"x\", group = 1)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"working-with-functions-on-metric-graphs","dir":"Articles","previous_headings":"","what":"Working with functions on metric graphs","title":"Working with metric graphs","text":"working data metric graphs, one often wants display functions graph. best way visualize functions graph evaluate fine mesh graph use plot_function. illustrate procedure, let us consider following graph:  command build_mesh, argument h decides largest spacing nodes mesh. can seen plot, mesh coarse, let’s reduce value h rebuild mesh: Suppose now want display function \\(f(x, y) = x^2 - y^2\\) graph. first evaluate vertices mesh use function plot_function display :  Alternatively, can set plotly = TRUE plot command get 3D visualization function: first argument plot_function vector, function assumes values vector values function evaluated vertices mesh. alternative, one can also provide first argument matrix consisting triplets \\((, t, f(, t))\\). \\(\\) denotes edge number, \\(t\\) location edge, \\(f(, t)\\) value point. illustrate , let us first construct set locations evenly spaced edge, convert Euclidean coordinates can evaluate function , finally plot result:","code":"V <- rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(-1, 1), c(-1, 0), c(0, -1)) E <- rbind(c(1, 2), c(2, 3), c(3, 4), c(4, 5),            c(5, 6), c(6, 1), c(4, 1),c(1, 7)) graph <- metric_graph$new(V = V, E = E) graph$build_mesh(h = 0.5) graph$plot(mesh=TRUE) graph$build_mesh(h = 0.01) x <- graph$mesh$V[, 1] y <- graph$mesh$V[, 2] f <- x^2 - y^2 graph$plot_function(f) graph$plot_function(f, plotly = TRUE) n.e <- 30 PtE <- cbind(rep(1:graph$nE, each = n.e),               rep(seq(from = 0, to = 1, length.out = n.e), graph$nE)) XY <- graph$coordinates(PtE) f <- XY[, 1]^2 - XY[, 2]^2 graph$plot_function(cbind(PtE, f), plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/pointprocess.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Log-Gaussian Cox processes on metric graphs","text":"vignette introduce work log-Gaussian Cox processes based Whittle–Matérn fields metric graphs. simplify integration R-INLA inlabru hese models constructed using finite element approximations implemented rSPDE package. theoretical details given forthcoming article (Bolin, Simas, Wallin 2023).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/pointprocess.html","id":"constructing-the-graph-and-the-mesh","dir":"Articles","previous_headings":"","what":"Constructing the graph and the mesh","title":"Log-Gaussian Cox processes on metric graphs","text":"begin loading rSPDE, MetricGraph INLA packages: example, consider default graph package:  construct FEM approximation Whittle–Matérn field, must first construct mesh graph.  next step build mass stiffness matrices FEM basis. now ready specify sample log-Gaussian Cox process model intensity \\(\\lambda = \\exp(\\beta + u)\\) \\(\\beta\\) intercept \\(u\\) Gaussian Whittle–Matérn field specified \\[ (\\kappa^2 - \\Delta)^{\\alpha/2} \\tau u = \\mathcal{W}. \\] can use function graph_lgcp follows: object returned function list simulated Gaussian process points graph. can plot simulated intensity function  plot simulated points, can add graph plot:","code":"library(rSPDE) library(MetricGraph) library(INLA) graph <- metric_graph$new(tolerance = list(vertex_vertex = 1e-1, vertex_line = 1e-3, line_line = 1e-3),                           remove_deg2 = TRUE) graph$plot() graph$build_mesh(h = 0.1) graph$plot(mesh=TRUE) graph$compute_fem() sigma <- 0.5   range <- 1.5   alpha <- 2   lgcp_sample <- graph_lgcp(intercept = 1, sigma = sigma,                             range = range, alpha = alpha,                             graph = graph) graph$plot_function(exp(lgcp_sample$u), vertex_size = 0) graph$add_observations(data = data.frame(y=rep(1,length(lgcp_sample$edge_loc)),                                          edge_number = lgcp_sample$edge_number,                                          distance_on_edge = lgcp_sample$edge_loc),                        normalized = TRUE) graph$plot(vertex_size = 0, data = \"y\")"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/pointprocess.html","id":"r-inla-implementation","dir":"Articles","previous_headings":"","what":"R-INLA implementation","title":"Log-Gaussian Cox processes on metric graphs","text":"now position fit model R-INLA implementation. working log-Gaussian Cox processes, likelihood term \\(\\int_\\Gamma \\exp(u(s)) ds\\) needs handled separately. done using mid-point rule suggested SPDE models (lgcp?) approximate \\[ \\int_\\Gamma \\exp(u(s)) ds \\approx \\sum_{=1}^p \\widetilde{}_i \\exp\\left(u(\\widetilde{s}_i)\\right). \\] Using fact \\(u(s) = \\sum_{j=1}^n \\varphi(s) u_i\\) FEM approximation, can write integral \\(\\widetilde{\\alpha}^T\\exp(\\widetilde{}u)\\) \\(\\widetilde{}_{ij} = \\varphi_j(\\widetilde{s}_i)\\) \\(\\widetilde{}\\) vector integration weights. quantities can obtained weights used exposure terms Poisson likelihiood R-INLA. , easiest way construct model add integration points zero observations graph, corresponding exposure weights. also need add exposure terms (zero) actual observation locations: now create inla model object graph_spde function. simplicity, assume \\(\\alpha\\) known fixed true value model. Next, create index object observation matrix: now create inla.stack object inla.stack() function. stage, important data added graph since supplied stack using graph_spde_data() function. can now fit model using R-INLA: Let us extract estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:  Finally, can plot estimated field \\(u\\):  can compared field used generate data:","code":"Atilde <- graph$mesh_A(graph$mesh$VtE) atilde <- graph$mesh$weights #clear the previous data in the graph graph$clear_observations()  #Add the data together with the exposure terms graph$add_observations(data = data.frame(y = rep(1,length(lgcp_sample$edge_loc)),                                          e = rep(0,length(lgcp_sample$edge_loc)),                                          edge_number = lgcp_sample$edge_number,                                          distance_on_edge = lgcp_sample$edge_loc),                        normalized = TRUE)  #Add integration points graph$add_observations(data = data.frame(y = rep(0,length(atilde)),                                          e = atilde,                                          edge_number = graph$mesh$VtE[,1],                                          distance_on_edge = graph$mesh$VtE[,2]),                        normalized = TRUE) rspde_model <- rspde.metric_graph(graph, nu = alpha - 1/2) spde_index <- rspde.make.index(name=\"field\", mesh=graph, nu = alpha - 1/2) A <- rspde.make.A(mesh = graph, nu = alpha - 1/2) stk <- inla.stack(data = graph_data_spde(rspde_model),                    A = A,                    effects = c(spde_index, list(Intercept = 1))) spde_fit <- inla(y ~ -1 + Intercept + f(field, model = rspde_model),                   family = \"poisson\", data = inla.stack.data(stk),                  control.predictor = list(A = inla.stack.A(stk), compute = TRUE),                  E = inla.stack.data(stk)$e) ## Warning in inla.model.properties.generic(inla.trim.family(model), mm[names(mm) == : Model 'cgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time. ##   Use this model with extra care!!! Further warnings are disabled. spde_result <- rspde.result(spde_fit, \"field\", rspde_model)  summary(spde_result) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.573178 0.0839096   0.423246 0.568359   0.752044 0.559446 ## range   1.581660 0.4557980   0.882817 1.514920   2.660000 1.385670 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, range),     mean = c(       spde_result$summary.std.dev$mean,       spde_result$summary.range$mean     ),     mode = c(       spde_result$summary.std.dev$mode,       spde_result$summary.range$mode     )   )   print(result_df) ##   parameter true      mean      mode ## 1   std.dev  0.5 0.5731776 0.5594459 ## 2     range  1.5 1.5816581 1.3856746 posterior_df_fit <- gg_df(spde_result)    library(ggplot2)    ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\") n.obs <- length(graph$data$y) n.field <- dim(graph$mesh$VtE)[1] u_posterior <- spde_fit$summary.linear.predictor$mean[(n.obs+1):(n.obs+n.field)] graph$plot_function(u_posterior, vertex_size = 0) graph$plot_function(lgcp_sample$u, vertex_size = 0)"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Gaussian random fields on metric graphs","text":"vignette introduce work Gaussian random fields metric graphs. main models Whittle–Matérn fields introduced Bolin, Simas, Wallin (2022) Bolin, Simas, Wallin (2023). package also support isotropic Gaussian processes, particular Gaussian processes isotropic exponential covariance functions introduced Anderes, Møller, Rasmussen (2020). Finally, Gaussian models based graph Laplacian, introduced Borovitskiy et al. (2021) also supported, even though defined Gaussian processes metric graph, vertices. example throughout vignette, consider following metric graph:  details construction metric graphs, see Working metric graphs","code":"library(sp) line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0),c(0,1))) line3 <- Line(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 20) line4 <- Line(cbind(sin(theta),1+ cos(theta))) Lines = sp::SpatialLines(list(Lines(list(line1),ID=\"1\"),                               Lines(list(line2),ID=\"2\"),                               Lines(list(line3),ID=\"3\"),                               Lines(list(line4),ID=\"4\"))) graph <- metric_graph$new(lines = Lines) graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"whittlematérn-fields","dir":"Articles","previous_headings":"","what":"Whittle–Matérn fields","title":"Gaussian random fields on metric graphs","text":"Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha/2} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"sampling","dir":"Articles","previous_headings":"Whittle–Matérn fields","what":"Sampling","title":"Gaussian random fields on metric graphs","text":"example, let us simulate field \\(u\\) graph using \\(\\alpha = 1\\). , first need specify sample . first example, let us specify locations manually:  many cases, one wants sample field evenly spaced locations graph. avoid specify locations manually, can first create mesh graph  command build_mesh, argument h decides largest spacing nodes mesh. can now sample field mesh plot result function follows:  Let us construct finer mesh, simulate field, visualize simulation 3D specifying plotly argument plot function: Since \\(\\alpha=1\\), sample paths continuous differentiable. visualize correlation structure field, can compute plot covariances point points graph follows: obtain field differentiable sample paths, can change \\(\\alpha=2\\). corresponding covariance function looks follows: Let us simulate process \\(\\alpha=2\\) well:","code":"PtE <- cbind(rep(1:4, each = 4),              rep(c(0.2, 0.4, 0.6, 0.8), times = 4))  sigma <- 1.3 alpha <- 1 range <- 0.2 u <- sample_spde(kappa = kappa, sigma = sigma,                   range = range,                  graph = graph, PtE = PtE) graph$plot(X = u, X_loc = PtE) graph$build_mesh(h = 0.1) graph$plot(mesh=TRUE) u <- sample_spde(range = range, sigma = sigma, alpha = alpha,                  graph = graph, type = \"mesh\") graph$plot_function(u) graph$build_mesh(h = 0.01)   u <- sample_spde(range = range, sigma = sigma, alpha = alpha,                  graph = graph, type = \"mesh\") graph$plot_function(u, plotly = TRUE) ## Loading required namespace: plotly C <- spde_covariance(c(2, 0.2), range = range, sigma = sigma, alpha = 1,                             graph = graph) graph$plot_function(C, plotly = TRUE) C <- spde_covariance(c(2, 0.2), range = range, sigma = sigma, alpha = 2,                             graph = graph) graph$plot_function(C, plotly = TRUE) u <- sample_spde(range = range, sigma = sigma, alpha = 2,                  graph = graph, type = \"mesh\") graph$plot_function(u, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"inference","dir":"Articles","previous_headings":"Whittle–Matérn fields","what":"Inference","title":"Gaussian random fields on metric graphs","text":"MetricGraph package contains implementations linear mixed effects models, random effect can Whittle–Matérn fields, model observed Gaussian measurement noise. also implemented random effects SPDE fields obtained graph Laplacian well models isotropic covariances. section illustrate methods. use Whittle–Matérn fields complicated hierarchical models, recommend using interfaces INLA inlabru packages. See INLA interface Whittle–Matérn fields inlabru interface Whittle–Matérn fields details . Suppose want estimate model parameters Whittle–Matérn field \\(u(s)\\) observed Gaussian measurement noise. , assume given observations \\[ y_i = u(s_i) + \\varepsilon_i, \\quad =1,\\ldots,n \\] \\(s_i\\\\Gamma\\) observation locations \\(\\varepsilon_i\\) independent centered Gaussian variables \\(N(0,\\sigma_e^2)\\) representing measurement noise. Let us start generating data like adding metric graph:  can now use graph_lme() function fit model. default linear regression model chosen. Since want fit model latent model given Whittle-Matérn field \\(\\alpha=1\\), set model argument either 'alpha1' list(model = 'WhittleMatern', alpha = 1) (first convenient less decriptive). choose parameterization_latent \"spde\" obtain estimated values kappa sigma. default provides estimated values range parameter sigma. Let us now compare true values: Given estimated parameters, can now kriging estimate field locations graph. example, now estimate field regular mesh previously constructed. procedure can done \\(\\alpha = 2\\). One can also estimate \\(\\alpha\\) data described vignette Whittle–Matérn fields general smoothness.","code":"range <- 0.2 sigma <- 1.3 sigma_e <- 0.1 alpha <- 1  n.obs.per.edge <- 75 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = alpha,                  graph = graph, PtE = PtE)  y <- u + sigma_e*rnorm(n.obs.per.edge * graph$nE)  df_data <- data.frame(y = y, edge_number = PtE[,1],                         distance_on_edge = PtE[,2])  graph$clear_observations() # Removing previous observations graph$add_observations(data = df_data, normalized = TRUE) graph$plot(data = \"y\") res <- graph_lme(y ~ -1, graph = graph, model = 'WM1')  summary(res) ##  ## Latent model - Whittle-Matern with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = \"WM1\") ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## tau   0.171448  0.009441  18.161 ## kappa 8.075632  2.085471   3.872 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma  1.45133   0.17196   8.440 ## range  0.24766   0.06292   3.936 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev   0.1101    0.0248   4.439 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -244.4674  ## Number of function calls by 'optim' = 17 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  2.83151 secs sigma_e_est <- res$coeff$measurement_error sigma_est <- res$matern_coeff$random_effects[1] range_est <- res$matern_coeff$random_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e    sigma     range ## Truth    0.1000000 1.300000 0.2000000 ## Estimate 0.1100823 1.451328 0.2476586 u_est <- predict(res, data.frame(edge_number = graph$mesh$VtE[,1],                         distance_on_edge = graph$mesh$VtE[,2]), normalized = TRUE)  graph$plot_function(u_est$mean, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"isotropic-gaussian-processes","dir":"Articles","previous_headings":"","what":"Isotropic Gaussian processes","title":"Gaussian random fields on metric graphs","text":"metric graphs Euclidean edges, Anderes, Møller, Rasmussen (2020) showed one can define valid Gaussian processes various isotropic covariance functions distances points measured -called resistance metric \\(d(\\cdot,\\cdot)\\). One example valid covariance function isotropic exponential covariance function \\[ r(d(s,t)) = \\sigma^2\\exp(-\\kappa d(s,t)). \\] use , valid covariance, metric graph, cumbersome thing compute metric. metric_graph class built support , now illustrate. Suppose want sample Gaussian process exponential covariance mesh graph considered . , need compute resistance metric mesh locations, can done follows: can now construct covariance matrix process: One can note covariance function looks quite similar Whittle–Matérn fields \\(\\alpha = 1\\). Let us plot corresponding Whittle–Matérn covariance compare: similarities two covairance functions, recomend using Whittle–Matérn since Markov properties makes inference much faster used. , covariance well-defined compact metric graph, whereas isotropic exponential guaranteed positive definite graph Euclidean edges. See Bolin, Simas, Wallin (2023) comparisons. However, let us now illustrate can fit covariance data. first clear observations previously added graph, simulate observation locations , sample processes locations, finally construct data add metric graph:  can now fit model graph_lme() function. need model list(type=\"isoCov\"), default exponential covariance used. Let us now compute posterior mean field observation locations:","code":"graph$compute_resdist_mesh() sigma <- 1 kappa <- 5 Sigma <- sigma^2*exp(-kappa*graph$mesh$res_dist) graph$plot_function(Sigma[20,], plotly = TRUE) P <- c(1, graph$mesh$V[20,1]) C.wm <- spde_covariance(P,range=2/kappa, sigma=sigma, graph=graph, alpha = 1) p <- graph$plot_function(Sigma[20,], plotly = TRUE) graph$plot_function(C.wm, plotly = TRUE, p = p, line_color = 'rgb(100,0,0)',                     support_width = 0) graph$clear_observations() sigma <-1.5 kappa <- 20 sigma_e <- 0.1 n.obs.per.edge <- 50  PtE <- NULL for(i in 1:graph$nE){   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) } D <- graph$compute_resdist_PtE(PtE, normalized = TRUE) # Sigma <- sigma^2*exp(-kappa*D) Sigma <- as.matrix(exp_covariance(D, c(sigma, kappa))) u <- t(chol(Matrix::forceSymmetric(Sigma)))%*%rnorm(n.obs.per.edge * graph$nE) y <- u + sigma_e*rnorm(n.obs.per.edge * graph$nE)  df_isocov <- data.frame(y = as.vector(y), edge_number = PtE[,1],                         distance_on_edge = PtE[,2])  graph$add_observations(data = df_isocov, normalized=TRUE) graph$plot(data = \"y\") res_exp <- graph_lme(y ~ -1, graph = graph, model = list(type = \"isoCov\")) summary(res_exp) ##  ## Latent model - Covariance-based model ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = list(type = \"isoCov\")) ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## tau     1.4150    0.1088   13.01 ## kappa  25.8047    5.4787    4.71 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.15027   0.08407   1.787 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -268.2396  ## Number of function calls by 'optim' = 20 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  2.86556 secs sigma_e_est <- res_exp$coeff$measurement_error sigma_est <- res_exp$coeff$random_effects[1] kappa_est <- res_exp$coeff$random_effects[2]  results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       kappa = c(kappa, kappa_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e    sigma    kappa ## Truth    0.1000000 1.500000 20.00000 ## Estimate 0.1502698 1.415023 25.80468 u_est_exp <- predict(res_exp, df_isocov, normalized = TRUE) graph$plot(X = u_est_exp$mean, X_loc = PtE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"models-based-on-the-graph-laplacian","dir":"Articles","previous_headings":"","what":"Models based on the Graph Laplacian","title":"Gaussian random fields on metric graphs","text":"final set Gaussian models supported MetricGraph Matérn type processes based graph Laplacian introduced Borovitskiy et al. (2021). multivariate Gaussian distributions, defined vertices equation \\[ (\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha/2}\\mathbf{u} = \\mathbf{W} \\] \\(\\mathbf{W}\\sim N(0,\\sigma^2\\mathbf{})\\) vector independent Gaussian variables \\(\\mathbf{\\Delta}_\\Gamma\\) graph Laplacian. , \\(\\mathbf{u}\\) vector values process vertices \\(\\Gamma\\), definition precision matrix \\[ \\mathbf{Q} = \\sigma^{-2}(\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha} \\] Thus, define models, `difficult'' thing compute  graph Laplacian. (weighted) graph Laplacian, weights specified edge lengths can computed functioncompute_laplacian()themetric_graph` object. first generate random locations, compute Laplacian locations: Let us now generate data graph Laplacian model \\(\\alpha=1\\):  can fit model data similarly fit previous models, help function graph_lme():","code":"n.obs.per.edge <- 100 PtE <- NULL for(i in 1:graph$nE){   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), sort(runif(n.obs.per.edge)))) } ## Removing problematic locations (locations very close) to improve numerical stability prob_points <- which(abs(diff(PtE[,2])) < 1e-3) prob_points <- c(prob_points, which(PtE[,2] < 1e-3)) prob_points <- c(prob_points, which(PtE[,2] > 1 - 1e-3))  PtE <- PtE[!(1:nrow(PtE)%in%prob_points),] df_temp <- data.frame(y = 0, edge_number = PtE[,1],                         distance_on_edge = PtE[,2])                          graph$clear_observations() graph$add_observations(data = df_temp, normalized = TRUE) graph$compute_laplacian()  GL <- graph$Laplacian[[1]] library(Matrix)  tau <- 1 kappa <- 10 sigma_e <- 0.1  Q <- (kappa^2 * Diagonal(nrow(GL)) + GL) * tau^2 LQ <- chol(forceSymmetric(Q)) u <- solve(LQ, rnorm(nrow(Q)))[(attr(GL, \"nV_idx\") + 1):nrow(GL)] # The first attr(GL, \"nV_idx\") values are on the original vertices y <- u + sigma_e*rnorm(length(u))  df_GL <- data.frame(y = as.vector(y), edge_number = PtE[,1],                         distance_on_edge = PtE[,2])  graph$clear_observations() graph$add_observations(data = df_GL, normalized=TRUE) graph$plot(data = \"y\") res_GL <- graph_lme(y ~ -1, graph = graph, model = list(type = \"graphLaplacian\"))  sigma_e_est <- res_GL$coeff$measurement_error tau_est <- res_GL$coeff$random_effects[1] kappa_est <- res_GL$coeff$random_effects[2]  results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       tau = c(tau, tau_est),                       kappa = c(kappa, kappa_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e      tau     kappa ## Truth    0.1000000 1.000000 10.000000 ## Estimate 0.1125888 1.291488  7.342343"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-comparison-using-cross-validation","dir":"Articles","previous_headings":"","what":"A comparison using cross-validation","title":"Gaussian random fields on metric graphs","text":"Let us now compare different models terms predictive ability. start simulating data frome Whittle–Matérn field \\(\\alpha = 2\\), fit different models discussed, compare predictive ability leave-one-crossvalidation. change things bit, let us consider different graph:  Let us now generate observation locations random locations edge sample process:  now fit different models data: Finally, use function posterior_crossvalidation perform leave-one-cross validation based estimated parameters compare results:","code":"V <- rbind(c(0, 0),            c(1, 0),            c(1, 1),            c(0, 1),            c(-1, 1),            c(-1, 0),            c(0, -1)) E <- rbind(c(1, 2),            c(2, 3),            c(3, 4),            c(4, 5),            c(5, 6),            c(6, 1),            c(4, 1),            c(1, 7)) graph <- metric_graph$new(V = V, E = E) graph$plot() range <- 0.15 sigma <- 2 sigma_e <- 0.3 theta <-  c(sigma_e, sigma, kappa)  n.obs.per.edge <- 15 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 2,                  graph = graph, PtE = PtE, method = \"Q\")  y <- u + sigma_e*rnorm(n.obs.per.edge * graph$nE)  df_cv <- data.frame(y = y, edge_number = PtE[,1],                       distance_on_edge = PtE[,2])  graph$add_observations(data=df_cv, normalized = TRUE) graph$plot(data = TRUE) #alpha = 1 model fit_alpha1 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"WhittleMatern\", alpha = 1))  #alpha = 2 model fit_alpha2 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"WhittleMatern\", alpha = 2))  #Isotropic exponential fit_isoexp <- graph_lme(y ~ -1, graph=graph, model = list(type = \"isoCov\"))  #Graph Laplacian  fit_GL1 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"graphLaplacian\", alpha = 1))  fit_GL2 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"graphLaplacian\", alpha = 2)) cv.alpha1 <- posterior_crossvalidation(fit_alpha1) cv.alpha2 <- posterior_crossvalidation(fit_alpha2) cv.exp <- posterior_crossvalidation(fit_isoexp) cv.GL1 <- posterior_crossvalidation(fit_GL1) cv.GL2 <- posterior_crossvalidation(fit_GL2) results <- data.frame(rmse = c(cv.alpha1$rmse, cv.alpha2$rmse, cv.exp$rmse,                                cv.GL1$rmse, cv.GL2$rmse),                       mae = c(cv.alpha1$mae, cv.alpha2$mae, cv.exp$mae,                                cv.GL1$mae, cv.GL2$mae),                       crps = c(cv.alpha1$crps, cv.alpha2$crps, cv.exp$crps,                                cv.GL1$crps, cv.GL2$crps),                       scrps = c(cv.alpha1$scrps, cv.alpha2$scrps, cv.exp$scrps,                                cv.GL1$scrps, cv.GL2$scrps),                       logscore = c(cv.alpha1$logscore, cv.alpha2$logscore,                                    cv.exp$logscore, cv.GL1$logscore,                                     cv.GL2$logscore),                       row.names = c(\"alpha=1\", \"alpha=2\", \"isoExp\",                                     \"GL1\", \"GL2\")) round(1000*results) ##         rmse mae crps scrps logscore ## alpha=1 1190 856  590  1008     1310 ## alpha=2 1065 760  524   947     1175 ## isoExp  1197 862  593  1011     1315 ## GL1     1230 875  601  1012     1317 ## GL2     1171 814  557   966     1218"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-model-with-replicates","dir":"Articles","previous_headings":"","what":"A model with replicates","title":"Gaussian random fields on metric graphs","text":"Let us illustrate now one can fit model replicates. end, consider graph previous example.  Let us now generate observation locations random locations edge sample process. Let us sample Whitlle–Matérn process metric graph alpha=1. consider 20 replicates. end, set nsim=20: plot first replicate, can simply call graph$plot(data=TRUE). plot another replicate, set argument group index replicate want plot. Let us plot first second replicates:    fit model, simply proceed identical manner case without replicates using graph_lme() function: Let us now fit model isotropic exponential covariance data: kriging, proceed identical way, providing data.frame locations want obtain predictions. Let us obtain predictions observation locations. setting return_as_list TRUE obtain list predictions, element consists predictions corresponding replicate. Let us now plot predictions first replicate using number indicates order replicate:  can also use name replicate. Let us plot predictions replicate y.15:","code":"V <- rbind(c(0, 0),            c(1, 0),            c(1, 1),            c(0, 1),            c(-1, 1),            c(-1, 0),            c(0, -1)) E <- rbind(c(1, 2),            c(2, 3),            c(3, 4),            c(4, 5),            c(5, 6),            c(6, 1),            c(4, 1),            c(1, 7)) graph <- metric_graph$new(V = V, E = E) graph$plot() library(tidyr)  range <- 0.15 sigma <- 2 sigma_e <- 0.1 theta <-  c(sigma_e, sigma, kappa)  n_repl <- 20  n.obs.per.edge <- 30 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = PtE, nsim = n_repl)  y <- u + sigma_e*matrix(rnorm(n.obs.per.edge * graph$nE * n_repl), ncol = n_repl)  df_graph <- data.frame(y=y, edge_number = PtE[,1],                       distance_on_edge = PtE[,2])  df_graph <- pivot_longer(df_graph, cols = `y.1`:`y.20`, names_to = \"repl\", values_to = \"y\")  graph$add_observations(data = df_graph, normalized = TRUE, group=\"repl\") graph$plot(data=\"y\") graph$plot(data=\"y\", group=\"y.2\") graph$plot(data=\"y\", group=2) fit_repl <- graph_lme(y ~ -1, graph = graph, model = \"WM1\")  sigma_e_est <- fit_repl$coeff$measurement_error sigma_est <- fit_repl$matern_coeff$random_effects[1] range_est <- fit_repl$matern_coeff$random_effects[2]   results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e    sigma     range ## Truth    0.1000000 2.000000 0.1500000 ## Estimate 0.1026216 2.073746 0.1655893 fit_repl_isoexp <- graph_lme(y ~ -1, graph = graph,                             model = list(type = \"isoCov\"))  summary(fit_repl_isoexp) ##  ## Latent model - Covariance-based model ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = list(type = \"isoCov\")) ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## tau    2.06397   0.03654   56.48 ## kappa 12.28910   0.52458   23.43 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.10152   0.01284   7.907 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -7535.72  ## Number of function calls by 'optim' = 19 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  30.37974 secs df_pred <-  data.frame(edge_number = PtE[,1],                       distance_on_edge = PtE[,2])  pred_alpha1 <- predict(fit_repl, data = df_pred, normalized = TRUE, return_as_list = TRUE) graph$plot(X = pred_alpha1$mean[[1]], X_loc = df_pred) graph$plot(X = pred_alpha1$mean[[\"y.15\"]], X_loc = df_pred)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-model-with-covariates","dir":"Articles","previous_headings":"","what":"A model with covariates","title":"Gaussian random fields on metric graphs","text":"example consider first graph:  Let us now generate observation locations random locations edge sample process. Let us sample Whitlle–Matérn process metric graph alpha=1. include intercept covariates. covariates can added columns data.frame passed add_observations() function. Let us now estimate parameters using graph_lme() function: kriging, can use predict() method together data.frame containing locations covariates locations want obtain predictions. Let us obtain predictions observation locations: Let us now plot predictions first replicate using number indicates order replicate:","code":"line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0),c(0,1))) line3 <- Line(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 20) line4 <- Line(cbind(sin(theta),1+ cos(theta))) Lines = sp::SpatialLines(list(Lines(list(line1),ID=\"1\"),                               Lines(list(line2),ID=\"2\"),                               Lines(list(line3),ID=\"3\"),                               Lines(list(line4),ID=\"4\"))) graph <- metric_graph$new(lines = Lines) graph$plot() graph$clear_observations() range <- 0.15 sigma <- 2 sigma_e <- 0.1 theta <-  c(sigma_e, sigma, kappa)  n.obs.per.edge <- 75 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = PtE)  beta <- c(2,1)  X_cov <- cbind(1, runif(nrow(PtE)))  y <- X_cov %*% beta +  u + sigma_e*rnorm(n.obs.per.edge * graph$nE) df_graph <- data.frame(y=y, x1 = X_cov[,2], edge_number = PtE[,1], distance_on_edge=PtE[,2]) graph$add_observations(data=df_graph, normalized = TRUE) fit_cov <- graph_lme(y ~ x1, graph = graph, model = \"WM1\") sigma_e_est <- fit_cov$coeff$measurement_error sigma_est <- fit_cov$matern_coeff$random_effects[1] range_est <- fit_cov$matern_coeff$random_effects[2] beta_1_est <- fit_cov$coeff$fixed_effects[1] beta_2_est <- fit_cov$coeff$fixed_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       beta_1 = c(beta[1], beta_1_est),                       beta_2 = c(beta[2], beta_2_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##             sigma_e    sigma     range   beta_1   beta_2 ## Truth    0.10000000 2.000000 0.1500000 2.000000 1.000000 ## Estimate 0.09994719 1.825482 0.1339663 2.155762 1.077388 pred_cov <- predict(fit_cov, data = df_graph, normalized = TRUE) graph$plot(X = pred_cov$mean, X_loc = df_graph[,3:4])"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-model-with-covariates-and-replicates","dir":"Articles","previous_headings":"","what":"A model with covariates and replicates","title":"Gaussian random fields on metric graphs","text":"Let us consider graph previous example:  Let us now generate observation locations random locations edge sample process. Let us sample Whitlle–Matérn process metric graph alpha=1 20 replicates. include intercept covariates. covariates can added data.frame passed add_observations() function. Let us now estimate parameters graph_lme() function: Finally, can kriging analogous manner previous cases. Let us obtain predictions first replicate observation locations: Let us now plot predictions first replicate using number indicates order replicate:","code":"line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0),c(0,1))) line3 <- Line(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 20) line4 <- Line(cbind(sin(theta),1+ cos(theta))) Lines = sp::SpatialLines(list(Lines(list(line1),ID=\"1\"),                               Lines(list(line2),ID=\"2\"),                               Lines(list(line3),ID=\"3\"),                               Lines(list(line4),ID=\"4\"))) graph <- metric_graph$new(lines = Lines) graph$plot() range <- 0.2 sigma <- 2 sigma_e <- 0.1 theta <-  c(sigma_e, sigma, kappa)  n.obs.per.edge <- 30 n_repl <- 20 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = PtE, nsim = n_repl)  beta <- c(2,1)  X_cov <- cbind(1, runif(nrow(PtE)))  y <- NULL for(i in 1:n_repl){   y_tmp <- X_cov %*% beta +  u[,i] + sigma_e*rnorm(n.obs.per.edge * graph$nE)   y <- cbind(y, y_tmp) }  data_list <- lapply(1:n_repl, function(i){data.frame(y = y[,i], x1 = X_cov[,2],                                           edge_number = PtE[,1],                                           distance_on_edge = PtE[,2], repl = i)})  df_graph <- do.call(rbind, data_list)  graph$add_observations(data = df_graph, normalized = TRUE, group = \"repl\") fit_cov_repl <- graph_lme(y ~ x1, graph = graph, model = \"WM1\") sigma_e_est <- fit_cov_repl$coeff$measurement_error sigma_est <- fit_cov_repl$matern_coeff$random_effects[1] range_est <- fit_cov_repl$matern_coeff$random_effects[2] beta_1_est <- fit_cov_repl$coeff$fixed_effects[1] beta_2_est <- fit_cov_repl$coeff$fixed_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       beta_1 = c(beta[1], beta_1_est),                       beta_2 = c(beta[2], beta_2_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e    sigma     range   beta_1    beta_2 ## Truth    0.1000000 2.000000 0.2000000 2.000000 1.0000000 ## Estimate 0.1066712 1.982246 0.2020837 2.014758 0.9629276 df_pred <-  data.frame(edge_number = PtE[,1],                       distance_on_edge = PtE[,2], x1 = X_cov[,2])  pred_cov_repl <- predict(fit_cov_repl, data = df_pred, normalized = TRUE, return_as_list = TRUE) graph$plot(X = pred_cov_repl$mean[[1]], X_loc = df_pred[,1:2])"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Maintainer, author. Jonas Wallin. Author. Alexandre Simas. Author.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Wallin J, Simas (2023). MetricGraph: Random fields metric graphs. R package version 1.1.1, https://CRAN.R-project.org/package=MetricGraph. Bolin D, Simas , Wallin J (2022). “Gaussian Whittle-Matérn fields metric graphs.” arXiv preprint arXiv:2205.06163. doi:10.48550/arXiv.2205.06163. Bolin D, Kovács M, Kumar V, Simas (2023). “Regularity numerical approximation fractional elliptic differential equations compact metric graphs.” arXiv preprint arXiv:2302.03995. doi:10.48550/arXiv.2302.03995. Bolin D, Simas , Wallin J (2023). “Markov properties Gaussian random fields compact metric graphs.” arXiv preprint arXiv:2304.03190. doi:10.48550/arXiv.2304.03190. Bolin D, Simas , Wallin J (2023). “Statistical inference Gaussian Whittle-Matérn fields metric graphs.” arXiv preprint arXiv:2304.10372. doi:10.48550/arXiv.2304.10372.","code":"@Manual{,   title = {MetricGraph: Random fields on metric graphs},   author = {David Bolin and Jonas Wallin and Alexandre B. Simas},   year = {2023},   note = {R package version 1.1.1},   url = {https://CRAN.R-project.org/package=MetricGraph}, } @Article{,   title = {Gaussian Whittle-Matérn fields on metric graphs},   author = {David Bolin and Alexandre B. Simas and Jonas Wallin},   year = {2022},   journal = {arXiv preprint arXiv:2205.06163},   doi = {10.48550/arXiv.2205.06163}, } @Article{,   title = {Regularity and numerical approximation of fractional elliptic differential equations on compact metric graphs},   author = {David Bolin and Mihály Kovács and Vivek Kumar and Alexandre B. Simas},   year = {2023},   journal = {arXiv preprint arXiv:2302.03995},   doi = {10.48550/arXiv.2302.03995}, } @Article{,   title = {Markov properties of Gaussian random fields on compact metric graphs},   author = {David Bolin and Alexandre B. Simas and Jonas Wallin},   year = {2023},   journal = {arXiv preprint arXiv:2304.03190},   doi = {10.48550/arXiv.2304.03190}, } @Article{,   title = {Statistical inference for Gaussian Whittle-Matérn fields on metric graphs},   author = {David Bolin and Alexandre B. Simas and Jonas Wallin},   year = {2023},   journal = {arXiv preprint arXiv:2304.10372},   doi = {10.48550/arXiv.2304.10372}, }"},{"path":"https://davidbolin.github.io/MetricGraph/index.html","id":"metricgraph","dir":"","previous_headings":"","what":"Random Fields on Metric Graphs","title":"Random Fields on Metric Graphs","text":"MetricGraph R package used working data random fields metric graphs, street river networks. main functionality contained metric_graph class, used specifying metric graphs, adding data , visualization, basic functions needed working data random fields metric graphs. package also implements various Gaussian fields metric graphs, particular Whittle–Matérn fields introduced references . Basic statistical tasks likelihood evaluation prediction implemented Gaussian fields MetricGraph. , package also contains interfaces R-INLA inlabru facilitates using packages full Bayesian inference general Latent Gaussian Models (LGMs) includes Whittle-Matérn fields metric graphs. get started package, please go MetricGraph: Random Fields Metric Graphs vignette. comprehensive examples, please see vignettes vignettes tab.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Random Fields on Metric Graphs","text":"D. Bolin, . Simas, J. Wallin (2022) Gaussian Whittle-Matérn fields metric graphs. ArXiv:2205.06163 D. Bolin, M. Kovács, V. Kumar, . Simas (2023) Regularity numerical approximation fractional elliptic differential equations compact metric graphs. ArXiv:2302.03995 D. Bolin, . Simas, J. Wallin (2023) Markov properties Gaussian random fields compact metric graphs. ArXiv:2304.03190 D. Bolin, . Simas, J. Wallin (2023) Statistical inference Gaussian Whittle-Matérn fields metric graphs. ArXiv:2304.10372","code":""},{"path":"https://davidbolin.github.io/MetricGraph/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Random Fields on Metric Graphs","text":"latest CRAN release package can installed directly CRAN install.packages(\"MetricGraph\"). also possible install CRAN version github using command: latest stable version can installed using command R. development version can installed using command","code":"remotes::install_github(\"davidbolin/metricgraph\", ref = \"cran\") remotes::install_github(\"davidbolin/metricgraph\", ref = \"stable\") remotes::install_github(\"davidbolin/metricgraph\", ref = \"devel\")"},{"path":"https://davidbolin.github.io/MetricGraph/reference/MetricGraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian processes on metric graphs — MetricGraph","title":"Gaussian processes on metric graphs — MetricGraph","text":"'MetricGraph' used creation manipulation metric graphs, street river networks. also several functions thatfacilitates operations visualizations data metric graphs, creation large class random fields stochastic partial differential equations spaces. main models Whittle-Matérn fields, specified fractional elliptic SPDE $$(\\kappa^2 - \\Delta)^{\\alpha/2} (\\tau u(s)) = W,$$ \\(\\kappa,\\tau>0\\) \\(\\alpha>1/2\\) parameters \\(W\\) Gaussian white noise. contains exact implementations model \\(\\alpha=1\\) \\(\\alpha=2\\), contains approximate implementations, via finite element method, \\(\\alpha > 0.5\\). also implements models based graph Laplacians isotropic covariance functions. Several utility functions specifying graphs, computing likelihoods, performing prediction, simulating processes, visualizing results metric graphs provided. particular, linear mixed effects models including random field components can fitted data based computationally efficient sparse matrix representations. Interfaces R packages 'INLA' 'inlabru' also provided, facilitate working Bayesian statistical models metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/MetricGraph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gaussian processes on metric graphs — MetricGraph","text":"heart package R6 class [metric_graph()]. used specifying metric graphs, contains various utility functions needed specifying Gaussian processes spaces. Linear mixed effects models provided (see [graph_lme]) perform predictions (see [predict.graph_lme]). package also interfaces 'INLA' (see [graph_spde]), interface also works 'inlabru'. detailed introduction package, see 'MetricGraph' Vignettes.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_graph_rep.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a vector of replicates to be used with 'inlabru' — bru_graph_rep","title":"Creates a vector of replicates to be used with 'inlabru' — bru_graph_rep","text":"Auxiliary function create vector replicates used 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_graph_rep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a vector of replicates to be used with 'inlabru' — bru_graph_rep","text":"","code":"bru_graph_rep(repl, graph_spde)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_graph_rep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a vector of replicates to be used with 'inlabru' — bru_graph_rep","text":"repl vector replicates. set __all, vector replicates generated. graph_spde Name field.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_graph_rep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a vector of replicates to be used with 'inlabru' — bru_graph_rep","text":"vector replicates used 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_mapper.inla_metric_graph_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","title":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","text":"Metric graph 'inlabru' mapper","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_mapper.inla_metric_graph_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","text":"","code":"bru_get_mapper.inla_metric_graph_spde(model, ...)  ibm_n.bru_mapper_inla_metric_graph_spde(mapper, ...)  ibm_values.bru_mapper_inla_metric_graph_spde(mapper, ...)  ibm_jacobian.bru_mapper_inla_metric_graph_spde(mapper, input, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_mapper.inla_metric_graph_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","text":"model inla_metric_graph_spde construct extract mapper ... Arguments passed methods mapper bru_mapper.inla_metric_graph_spde object input values produce mapping matrix","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential covariance function — exp_covariance","title":"Exponential covariance function — exp_covariance","text":"Evaluates exponential covariance function $$C(h) = \\sigma^2 \\exp\\{-kappa h\\}$$","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential covariance function — exp_covariance","text":"","code":"exp_covariance(h, theta)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential covariance function — exp_covariance","text":"h Distances evaluate covariance function . theta vector c(sigma, kappa), sigma standard deviation kappa range-like parameter.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential covariance function — exp_covariance","text":"vector values covariance function.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"Returns 'ggplot2'-friendly data-frame marginal posterior densities.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"","code":"# S3 method for metric_graph_spde_result gg_df(   result,   parameter = result$params,   transform = TRUE,   restrict_x_axis = parameter,   restrict_quantiles = list(sigma = c(0, 1), range = c(0, 1), kappa = c(0, 1), sigma =     c(0, 1)),   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"result metric_graph_spde_result object. parameter Vector. parameters get posterior density data.frame? options sigma, range kappa. transform posterior density given original scale? restrict_x_axis Variables restrict range x axis based quantiles. restrict_quantiles List quantiles restrict x axis. ... used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"data.frame containing posterior densities.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data frames or data lists to be used with 'inlabru' in metric\ngraphs — graph_bru_process_data","title":"Prepare data frames or data lists to be used with 'inlabru' in metric\ngraphs — graph_bru_process_data","text":"Prepare data frames data lists used 'inlabru' metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data frames or data lists to be used with 'inlabru' in metric\ngraphs — graph_bru_process_data","text":"","code":"graph_bru_process_data(   data,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   loc = \"loc\" )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data frames or data lists to be used with 'inlabru' in metric\ngraphs — graph_bru_process_data","text":"data data.frame list containing covariates, edge number distance edge locations obtain prediction. edge_number Name variable contains edge number, default edge_number. distance_on_edge Name variable contains distance edge, default distance_on_edge. loc character. Name locations used 'inlabru' component.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data frames or data lists to be used with 'inlabru' in metric\ngraphs — graph_bru_process_data","text":"list containing processed data used user-friendly manner 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Connected components of metric graph — graph_components","title":"Connected components of metric graph — graph_components","text":"Class representing connected components metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connected components of metric graph — graph_components","text":"Object R6Class creating metric graph components.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Connected components of metric graph — graph_components","text":"list metric_graph objects (representing different connected components full graph) created vertex edge matrices, sp::SpatialLines object line representing edge. details, see vignette: vignette(\"metric_graph\", package = \"MetricGraph\")","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Connected components of metric graph — graph_components","text":"graphs List graphs representing connected components. n number graphs. sizes Number vertices graphs. lengths Total edge lengths graphs. Create metric graphs connected components","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Connected components of metric graph — graph_components","text":"graph_components$new() graph_components$get_largest() graph_components$plot() graph_components$clone()","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$new(lines = NULL, V = NULL, E = NULL, by_length = TRUE, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connected components of metric graph — graph_components","text":"lines Object type SpatialLinesDataFrame SpatialLines. V n x 2 matrix Euclidean coordinates n vertices. E m x 2 matrix row represents edge. by_length Sort components total edge length? FALSE, components sorted number vertices. ... Additional arguments used specifying graphs longlat TRUE, assumed coordinates given Longitude/Latitude distances computed km. tolerance Vertices closer number merged constructing graph (default = 1e-10). longlat = TRUE, tolerance given km.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Connected components of metric graph — graph_components","text":"graph_components object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"method-get-largest-","dir":"Reference","previous_headings":"","what":"Method get_largest()","title":"Connected components of metric graph — graph_components","text":"Returns largest component graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$get_largest()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Connected components of metric graph — graph_components","text":"metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Connected components of metric graph — graph_components","text":"Plots components.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$plot(edge_colors = NULL, vertex_colors = NULL, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connected components of metric graph — graph_components","text":"edge_colors 3 x nc matrix RGB values edge colors used plotting graph. vertex_colors 3 x nc matrix RGB values edge colors used plotting graph. ... Additional arguments plotting individual graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Connected components of metric graph — graph_components","text":"ggplot object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Connected components of metric graph — graph_components","text":"objects class cloneable method.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$clone(deep = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connected components of metric graph — graph_components","text":"deep Whether make deep clone.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connected components of metric graph — graph_components","text":"","code":"library(sp) line1 <- Line(rbind(c(0, 0), c(1, 0))) line2 <- Line(rbind(c(1, 0), c(2, 0))) line3 <- Line(rbind(c(1, 1), c(2, 1))) Lines <-  SpatialLines(list(Lines(list(line1), ID = \"1\"),                            Lines(list(line2), ID = \"2\"),                            Lines(list(line3), ID = \"3\"))) graphs <- graph_components$new(Lines) graphs$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Data extraction for 'rSPDE' models — graph_data_spde","title":"Data extraction for 'rSPDE' models — graph_data_spde","text":"Extracts data metric graphs used 'INLA' 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data extraction for 'rSPDE' models — graph_data_spde","text":"","code":"graph_data_spde(graph_spde, repl = NULL, only_pred = FALSE, loc = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data extraction for 'rSPDE' models — graph_data_spde","text":"graph_spde inla_metric_graph_spde object built graph_spde() function rspde_metric_graph object built rspde.metric_graph() function 'rSPDE' package. repl replicates? replicates, one can set repl NULL. one wants replicates, one sets repl __all. only_pred return data.frame prediction data? loc Character name location variable used 'inlabru' prediction.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data extraction for 'rSPDE' models — graph_data_spde","text":"'INLA' 'inlabru' friendly list data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn\nfields on metric graphs — graph_lgcp","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn\nfields on metric graphs — graph_lgcp","text":"Simulation log-Gaussian Cox processes driven Whittle-Matérn fields metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn\nfields on metric graphs — graph_lgcp","text":"","code":"graph_lgcp(intercept = 0, sigma, range, alpha, graph)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn\nfields on metric graphs — graph_lgcp","text":"intercept Mean value Gaussian process. sigma Parameter marginal standard deviations. range Parameter practical correlation range. alpha Smoothness parameter (1 2). graph metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn\nfields on metric graphs — graph_lgcp","text":"List Gaussian process sample simulated points.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph linear mixed effects models — graph_lme","title":"Metric graph linear mixed effects models — graph_lme","text":"Fitting linear mixed effects model metric graphs. random effects can Gaussian Whittle-Matern fields, discrete Gaussian Markov random fields based graph Laplacian, well Gaussian random fields isotropic covariance functions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph linear mixed effects models — graph_lme","text":"","code":"graph_lme(   formula,   graph,   model = list(type = \"linearModel\"),   which_repl = NULL,   optim_method = \"L-BFGS-B\",   starting_values_latent = NULL,   start_sigma_e = NULL,   BC = 1,   parallel = FALSE,   n_cores = parallel::detectCores() - 1,   optim_controls = list(),   improve_hessian = FALSE,   hessian_args = list() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph linear mixed effects models — graph_lme","text":"formula Formula object describing relation response variables fixed effects. graph metric_graph object. model random effects model used (also includes option random effects). can either character, whose options 'lm', linear models without random effects; 'WM1' 'WM2' Whittle-Matern models \\(\\alpha\\)=1 2, exact precision matrices, respectively; 'WM' Whittle-Matern models one also estimates smoothness parameter via finite-element method; 'isoExp' model isotropic exponential covariance; 'GL1' 'GL2' SPDE model based graph Laplacian \\(\\alpha\\) = 1 2, respectively. also option provide list containing elements type, can linearModel, WhittleMatern, graphLaplacian isoCov. linearModel corresponds linear model without random effects. WhittleMatern models, , list contains type = 'WhittleMatern', one can choose finite element approximation precision matrix adding fem = TRUE list, use exact precision matrix (setting fem = FALSE). fem FALSE, also parameter alpha, determine order SPDE, either 1 2. fem TRUE alpha specified, default value alpha=1 used. fem TRUE one specify alpha, estimated data. However, one wants alpha fixed value, user can specify either alpha nu list. See vignettes examples. Finally, type 'WhittleMatern', optional argument, rspde_order, chooses order rational approximation. default rspde_order 2. Finally, one wants fit nonstationary model, fem necessarily needs TRUE, one needs also supply matrices B.tau B.kappa B.range B.sigma. graph-Laplacian models, list must also contain parameter alpha (1 default). isoCov models, list must contain parameter cov_function, containing covariance function. function accepts string input following covariance functions: 'exp_covariance', 'WM1', 'WM2', 'GL1', 'GL2'. another covariance function, function must provided cov_function argument. default 'exp_covariance', exponential covariance. also covariance-based versions Whittle-Matern graph Laplacian models, however much slower, following (string) values 'cov_function': 'alpha1' 'alpha2' Whittle-Matern fields, 'GL1' 'GL2' graph Laplacian models. Finally, Whittle-Matern models, additional parameter version, can either 1 2, tell version likelihood used. Version 1 default. which_repl Vector list containing replicates consider model. NULL replicates considered. optim_method method used optim function. starting_values_latent vector containing starting values latent model. latent model WhittleMatern graphLaplacian, starting values provided vector form c(sigma,kappa) c(sigma,range) depending parameterization. model isoCov, starting values provided vector containing parameters covariance function. start_sigma_e Starting value standard deviation measurament error. BC WhittleMatern models, decides boundary condition use (0,1). , 0 Neumann boundary conditions 1 specifies stationary boundary conditions. parallel logical. Indicating whether use optimParallel() . n_cores Number cores used parallel true. optim_controls Additional controls passed optim() optimParallel(). improve_hessian precise estimate hessian obtained? Turning might increase overall time. hessian_args List controls used improve_hessian TRUE. list can contain arguments passed method.args argument hessian function. See help hessian function 'numDeriv' package details. Observet accepts \"Richardson\" method now, method \"complex\" supported.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metric graph linear mixed effects models — graph_lme","text":"list containing fitted model.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_repl_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction of vector of replicates for 'inlabru' — graph_repl_spde","title":"Extraction of vector of replicates for 'inlabru' — graph_repl_spde","text":"Extracts vector replicates 'rSPDE' model object 'inlabru'","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_repl_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extraction of vector of replicates for 'inlabru' — graph_repl_spde","text":"","code":"graph_repl_spde(graph_spde, repl = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_repl_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extraction of vector of replicates for 'inlabru' — graph_repl_spde","text":"graph_spde rspde_metric_graph object built rspde.metric_graph() function 'rSPDE' package. repl replicates? replicates, one can set repl NULL. one wants replicates, one sets repl __all.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_repl_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extraction of vector of replicates for 'inlabru' — graph_repl_spde","text":"vector replicates.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"function creates 'INLA' object can used 'INLA' 'inlabru' fit Whittle-Matérn fields metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"","code":"graph_spde(   graph_object,   alpha = 1,   stationary_endpoints = \"all\",   parameterization = c(\"matern\", \"spde\"),   start_range = NULL,   prior_range = NULL,   start_kappa = NULL,   start_sigma = NULL,   prior_kappa = NULL,   prior_sigma = NULL,   shared_lib = \"detect\",   debug = FALSE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"graph_object metric_graph object. alpha order SPDE. stationary_endpoints vertices degree 1 contain stationary boundary conditions? parameterization parameterization used? options 'matern' (sigma range) 'spde' (sigma kappa). start_range Starting value range parameter. prior_range list containing elements meanlog sdlog, , mean standard deviation range parameter log scale. used prior.kappa non-null. start_kappa Starting value kappa. start_sigma Starting value sigma. prior_kappa list containing elements meanlog sdlog, , mean standard deviation kappa log scale. prior_sigma list containing elements meanlog sdlog, , mean standard deviation sigma log scale. shared_lib shared lib use cgeneric implementation? \"detect\", check shared lib exists locally, case use . Otherwise use 'INLA's shared library. 'INLA', use shared lib 'INLA's installation. 'MetricGraph', use local installation (work installation CRAN). Otherwise, can directly supply path .(.dll) file. debug debug displayed?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"'INLA' object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"function used construct Matern SPDE model metric graph. latent field \\(u\\) solution SPDE $$(\\kappa^2 - \\Delta)^\\alpha u = \\sigma W,$$ \\(W\\) Gaussian white noise metric graph. model implements exactly cases \\(\\alpha = 1\\) \\(\\alpha = 2\\). finite element approximation general \\(\\alpha\\) refer reader 'rSPDE' package Whittle--Matérn fields general smoothness vignette. also alternative parameterization \\(\\rho = \\frac{\\sqrt{8(\\alpha-0.5)}}{\\kappa}\\), can interpreted range parameter. Let \\(\\kappa_0\\) \\(\\sigma_0\\) starting values \\(\\kappa\\) \\(\\sigma\\), write \\(\\sigma = \\exp\\{\\theta_1\\}\\) \\(\\kappa = \\exp\\{\\theta_2\\}\\). assume priors \\(\\theta_1\\) \\(\\theta_2\\) normally distributed mean, respectively, \\(\\log(\\sigma_0)\\) \\(\\log(\\kappa_0)\\), variance 10. Similarly, let \\(\\rho_0\\) starting value \\(\\rho\\), write \\(\\rho = \\exp\\{\\theta_2\\}\\) assume normal prior \\(\\theta_2\\), mean \\(\\log(\\rho_0)\\) variance 10.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation/prediction matrices for 'rSPDE' models — graph_spde_make_A","title":"Observation/prediction matrices for 'rSPDE' models — graph_spde_make_A","text":"Constructs observation/prediction weight matrices metric graph models.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation/prediction matrices for 'rSPDE' models — graph_spde_make_A","text":"","code":"graph_spde_make_A(graph_spde, repl = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation/prediction matrices for 'rSPDE' models — graph_spde_make_A","text":"graph_spde inla_metric_graph_spde object built graph_spde() function. repl replicates? replicates, use replicates, one can set NULL.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation/prediction matrices for 'rSPDE' models — graph_spde_make_A","text":"observation matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Model index vector generation for metric graph models — graph_spde_make_index","title":"Model index vector generation for metric graph models — graph_spde_make_index","text":"Generates list named index vectors 'INLA'-based metric graph models.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model index vector generation for metric graph models — graph_spde_make_index","text":"","code":"graph_spde_make_index(name, graph_spde, n.group = 1, n.repl = 1, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model index vector generation for metric graph models — graph_spde_make_index","text":"name character string base name effect. graph_spde inla_metric_graph_spde object built graph_spde() function. n.group Number groups. n.repl Number replicates. ... Currently used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model index vector generation for metric graph models — graph_spde_make_index","text":"list indexes.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Starting values for random field models on metric graphs — graph_starting_values","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"Computes appropriate starting values optimization Gaussian random field models metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"","code":"graph_starting_values(   graph,   model = c(\"alpha1\", \"alpha2\", \"isoExp\", \"GL1\", \"GL2\"),   data = TRUE,   data_name = NULL,   range_par = FALSE,   nu = FALSE,   manual_data = NULL,   like_format = FALSE,   log_scale = FALSE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"graph metric_graph object. model Type model, \"alpha1\", \"alpha2\", \"isoExp\", \"GL1\", \"GL2\" supported. data data used obtain improved starting values? data_name name response variable graph$data. range_par initial value range parameter returned instead kappa? nu initial value nu returned? manual_data vector (matrix) response variables. like_format starting values returned sigma.e last element? format likelihood constructor 'rSPDE' package. log_scale initial values returned log scale?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"vector, c(start_sigma_e, start_sigma, start_kappa)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/logo_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Create lines for package name — logo_lines","title":"Create lines for package name — logo_lines","text":"Create lines package name","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/logo_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create lines for package name — logo_lines","text":"","code":"logo_lines()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/logo_lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create lines for package name — logo_lines","text":"SpatialLines object package name.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":null,"dir":"Reference","previous_headings":"","what":"Space-time precision operator Euler discretization — make_Q_euler","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"precision matrix vertices space-time field","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"","code":"make_Q_euler(graph, t, kappa, rho, gamma, alpha, beta, sigma, theta = 1)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"graph metric_graph object. t Vector time points. kappa Spatial range parameter. rho Drift parameter. gamma Temporal range parameter. alpha Smoothness parameter (integer) spatial operator. beta Smoothness parameter (integer) Q-Wiener process. sigma Variance parameter. theta Parameter theta Euler scheme.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"Precision matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Space-time precision operator discretization — make_Q_spacetime","title":"Space-time precision operator discretization — make_Q_spacetime","text":"precision matrix vertices space-time field.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Space-time precision operator discretization — make_Q_spacetime","text":"","code":"make_Q_spacetime(graph, t, kappa, rho, gamma, alpha, beta, sigma)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Space-time precision operator discretization — make_Q_spacetime","text":"graph metric_graph object. t Vector time points. kappa Spatial range parameter. rho Drift parameter. gamma Temporal range parameter. alpha Smoothness parameter (integer) spatial operator. beta Smoothness parameter (integer) Q-Wiener process. sigma Variance parameter.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Space-time precision operator discretization — make_Q_spacetime","text":"Precision matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph — metric_graph","title":"Metric graph — metric_graph","text":"Class representing general metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metric graph — metric_graph","text":"Object R6Class creating metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"graph object created vertex edge matrices, sp::SpatialLines object line representing edge. details, see vignette: vignette(\"metric_graph\", package = \"MetricGraph\")","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Metric graph — metric_graph","text":"V Matrix positions Euclidean space vertices graph. nV number vertices. E Matrix edges graph, row represents edge, E[,1] vertex start ith edge E[,2] vertex end edge. nE number edges. edge_lengths Vector lengths edges graph. EID Vector IDs edges graph. LtE Matrix edge positions lines. ELend Vector locations end points edges lines graph. locations normalized line. ELstart Vector locations starting points edges lines graph. locations normalized line. C Constraint matrix used set Kirchhoff constraints. CoB Change--basis object used Kirchhoff constraints. data List containing data metric graph. PtV Vector indices vertices observation locations. mesh Mesh object used plotting. lines lines graph. geo_dist Geodesic distances vertices graph. res_dist Resistance distances observation locations. Laplacian weighted graph Laplacian vertices graph. weights given edge lengths.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Metric graph — metric_graph","text":"metric_graph$new() metric_graph$compute_geodist() metric_graph$compute_geodist_PtE() metric_graph$compute_geodist_mesh() metric_graph$compute_resdist() metric_graph$compute_resdist_PtE() metric_graph$get_degrees() metric_graph$compute_resdist_mesh() metric_graph$compute_laplacian() metric_graph$prune_vertices() metric_graph$get_PtE() metric_graph$get_Spoints() metric_graph$observation_to_vertex() metric_graph$get_mesh_locations() metric_graph$clear_observations() metric_graph$add_observations() metric_graph$buildC() metric_graph$build_mesh() metric_graph$compute_fem() metric_graph$mesh_A() metric_graph$VtEfirst() metric_graph$plot() metric_graph$plot_connections() metric_graph$plot_function() metric_graph$plot_movie() metric_graph$add_mesh_observations() metric_graph$get_initial_graph() metric_graph$() metric_graph$coordinates() metric_graph$clone()","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Metric graph — metric_graph","text":"Create new metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$new(   lines = NULL,   V = NULL,   E = NULL,   longlat = FALSE,   tolerance = list(vertex_vertex = 1e-07, vertex_line = 1e-07, line_line = 0),   check_connected = TRUE,   adjust_lines = NULL,   remove_deg2 = FALSE,   remove_circles = TRUE,   verbose = FALSE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"lines Object type SpatialLinesDataFrame SpatialLines. V n x 2 matrix Euclidean coordinates n vertices. E m x 2 matrix row represents one m edges. longlat TRUE, assumed coordinates given. Longitude/Latitude distances computed km. tolerance List provides tolerances construction graph: vertex_vertex Vertices closer number merged (default = 1e-7). vertex_line vertex end one line closer number another line, vertex connected line (default = 1e-7). line_line two lines point closer number, new vertex added point two lines connected (default = 0). longlat = TRUE, tolerances given km. check_connected TRUE, checked whether graph connected warning given case. adjust_lines Set TRUE adjust lines object match graph connections. can take time large graphs, default TRUE graphs 100 lines, FALSE larger graphs. remove_deg2 Set TRUE remove vertices degree 2 initialization. Default FALSE. remove_circles circlular edges length smaller number removed. default vertex_vertex tolerance. verbose Print progress graph creation.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"graph object can initialized two ways. first method specify V E. case, edges assumed straight lines. second option specify graph via lines input. case, vertices set end points lines. Thus, two lines intersecting somewhere else, viewed vertex.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-geodist-","dir":"Reference","previous_headings":"","what":"Method compute_geodist()","title":"Metric graph — metric_graph","text":"Computes shortest path distances vertices graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_geodist(full = FALSE, obs = TRUE, group = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"full geodesic distances computed available locations? FALSE, computed separately locations group. obs geodesic distances computed observation locations? group Vector list containing groups compute distance . NULL, computed groups.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. computed geodesic distances stored geo_dist element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-geodist-pte-","dir":"Reference","previous_headings":"","what":"Method compute_geodist_PtE()","title":"Metric graph — metric_graph","text":"Computes shortest path distances vertices graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_geodist_PtE(   PtE,   normalized = TRUE,   include_vertices = TRUE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Points compute metric . normalized locations PtE normalized distance? include_vertices original vertices included distance matrix?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"matrix containing geodesic distances.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-geodist-mesh-","dir":"Reference","previous_headings":"","what":"Method compute_geodist_mesh()","title":"Metric graph — metric_graph","text":"Computes shortest path distances vertices mesh.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_geodist_mesh()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. geodesic distances mesh stored mesh$geo_dist metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-resdist-","dir":"Reference","previous_headings":"","what":"Method compute_resdist()","title":"Metric graph — metric_graph","text":"Computes resistance distance observation locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_resdist(full = FALSE, obs = TRUE, group = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"full resistance distances computed available locations. FALSE, computed separately locations group. obs resistance distances computed observation locations? group Vector list containing groups compute distance . NULL, computed groups.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. geodesic distances stored res_dist element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-resdist-pte-","dir":"Reference","previous_headings":"","what":"Method compute_resdist_PtE()","title":"Metric graph — metric_graph","text":"Computes resistance distance observation locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_resdist_PtE(   PtE,   normalized = TRUE,   include_vertices = FALSE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Points compute metric . normalized locations PtE normalized distance? include_vertices original vertices included Laplacian matrix?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"matrix containing resistance distances.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-degrees-","dir":"Reference","previous_headings":"","what":"Method get_degrees()","title":"Metric graph — metric_graph","text":"Returns degrees vertices metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_degrees()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"vector containing degrees vertices.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-resdist-mesh-","dir":"Reference","previous_headings":"","what":"Method compute_resdist_mesh()","title":"Metric graph — metric_graph","text":"Computes resistance metric vertices mesh.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_resdist_mesh()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. geodesic distances mesh stored mesh$res_dist element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-laplacian-","dir":"Reference","previous_headings":"","what":"Method compute_laplacian()","title":"Metric graph — metric_graph","text":"Computes weigthed graph Laplacian graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_laplacian(full = FALSE, obs = TRUE, group = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"full resistance distances computed available locations. FALSE, computed separately locations group. obs resistance distances computed observation locations? group Vector list containing groups compute Laplacian . NULL, computed groups.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"reutrn value. Called side effects. Laplacian stored Laplacian element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-prune-vertices-","dir":"Reference","previous_headings":"","what":"Method prune_vertices()","title":"Metric graph — metric_graph","text":"Removes vertices degree 2 metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$prune_vertices()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-pte-","dir":"Reference","previous_headings":"","what":"Method get_PtE()","title":"Metric graph — metric_graph","text":"Gets PtE data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_PtE()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"matrix two columns, first column contains edge number second column contains distance edge observation locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-spoints-","dir":"Reference","previous_headings":"","what":"Method get_Spoints()","title":"Metric graph — metric_graph","text":"Gets spatial points data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_Spoints()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-11","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"SpatialPoints object observation locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-observation-to-vertex-","dir":"Reference","previous_headings":"","what":"Method observation_to_vertex()","title":"Metric graph — metric_graph","text":"Adds observation locations vertices graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$observation_to_vertex(tolerance = 1e-15)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"tolerance Observations locations merged single vertex closer number (given relative edge distance 0 1). default 1e-15.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-12","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-mesh-locations-","dir":"Reference","previous_headings":"","what":"Method get_mesh_locations()","title":"Metric graph — metric_graph","text":"Returns list matrix mesh locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_mesh_locations(bru = FALSE, loc = NULL, normalized = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"bru 'inlabru'-friendly list returned? loc bru set TRUE, name location variable. default name 'loc'. normalized TRUE, distances distance_on_edge assumed normalized (0,1). Default TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-13","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"list matrix containing mesh locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-clear-observations-","dir":"Reference","previous_headings":"","what":"Method clear_observations()","title":"Metric graph — metric_graph","text":"Clear observations metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$clear_observations()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-14","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-add-observations-","dir":"Reference","previous_headings":"","what":"Method add_observations()","title":"Metric graph — metric_graph","text":"Add observations metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$add_observations(   Spoints = NULL,   data = NULL,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   coord_x = \"coord_x\",   coord_y = \"coord_y\",   data_coords = c(\"PtE\", \"euclidean\"),   group = NULL,   normalized = FALSE,   tolerance = max(self$edge_lengths)/2 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"Spoints SpatialPoints SpatialPointsDataFrame containing observations. may include coordinates observations , coordinates well observations. data data.frame named list containing observations. case groups, data.frames groups stacked vertically, column indicating index group. data NULL, takes priority eventual data Spoints. edge_number Column (entry list) data contains edge numbers. supplied, column name \"edge_number\" chosen. used Spoints NULL. distance_on_edge Column (entry list) data contains edge numbers. supplied, column name \"distance_on_edge\" chosen.  used Spoints NULL. coord_x Column (entry list) data contains x coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. coord_y Column (entry list) data contains y coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. data_coords used Spoints NULL. decides coordinate system use. PtE, user must provide edge_number distance_on_edge, otherwise euclidean, user must provide coord_x coord_y. group data grouped (example measured different time points), argument specifies column (entry list) group varialbe stored. normalized TRUE, distances distance_on_edge assumed normalized (0,1). Default FALSE. used Spoints NULL. tolerance Parameter control warning adding observations. distance location closest point graph greater tolerance, function display warning. helps detecting mistakes input locations adding new data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-15","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. observations stored data element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-buildc-","dir":"Reference","previous_headings":"","what":"Method buildC()","title":"Metric graph — metric_graph","text":"Build Kirchoff constraint matrix edges.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$buildC(alpha = 2, edge_constraint = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"alpha type constraint (currently supports 2) edge_constraint TRUE, add constraints vertices degree 1","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-2","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"Currently implemented circles (edges start end vertex)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-16","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-build-mesh-","dir":"Reference","previous_headings":"","what":"Method build_mesh()","title":"Metric graph — metric_graph","text":"Builds mesh object graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$build_mesh(h = NULL, n = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"h Maximum distance mesh nodes (provided n provided). n Maximum number nodes per edge (provided h provided).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-3","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"mesh list objects: PtE mesh locations excluding original vertices; V verties mesh; E edges mesh; n_e number vertices mesh per original edge graph; h_e mesh width per edge graph; ind indices vertices mesh; VtE mesh locations including original vertices.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-17","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. mesh stored mesh element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-fem-","dir":"Reference","previous_headings":"","what":"Method compute_fem()","title":"Metric graph — metric_graph","text":"Build mass stiffness matrices given mesh object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_fem()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-4","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"function builds: matrix C mass matrix elements \\(C_{ij} = <\\phi_i, \\phi_j>\\), matrix G stiffness matrix elements \\(G_{ij} = <d\\phi_i, d\\phi_j>\\), matrix B elements \\(B_{ij} = <d\\phi_i, \\phi_j>\\), vector weights \\(<\\phi_i, 1>\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-18","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. finite element matrices C, G B stored mesh element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-mesh-a-","dir":"Reference","previous_headings":"","what":"Method mesh_A()","title":"Metric graph — metric_graph","text":"Computes observation matrix mesh.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$mesh_A(PtE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Locations given (edge number graph, normalized location edge)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-5","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"n locations mesh m nodes, n x m matrix elements \\(A_{ij} = \\phi_j(s_i)\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-19","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"observation matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-vtefirst-","dir":"Reference","previous_headings":"","what":"Method VtEfirst()","title":"Metric graph — metric_graph","text":"Find one edge corresponding vertex.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$VtEfirst()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-20","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"nV x 2 matrix first element ith row edge number corresponding ith vertex second value 0 vertex start edge 1 vertex end edge.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Metric graph — metric_graph","text":"Plots metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot(   data = NULL,   group = 1,   plotly = FALSE,   vertex_size = 3,   vertex_color = \"black\",   edge_width = 0.3,   edge_color = \"black\",   data_size = 1,   mesh = FALSE,   X = NULL,   X_loc = NULL,   p = NULL,   degree = FALSE,   direction = FALSE,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data column data plot? NULL, data plotted. group groups, group plot? group number, index group stored internally. group character, group chosen name. plotly Use plot_ly 3D plot (default FALSE). option requires 'plotly' package. vertex_size Size vertices. vertex_color Color vertices. edge_width Line width edges. edge_color Color edges. data_size Size markers data. mesh Plot mesh locations? X Additional values plot. X_loc Locations additional values format (edge, normalized distance edge). p Existing objects obtained 'ggplot2' 'plotly' add graph degree Show degrees vertices? direction Show direction edges? ... Additional arguments pass ggplot() plot_ly()","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-21","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"plot_ly (plotly = TRUE) ggplot object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-connections-","dir":"Reference","previous_headings":"","what":"Method plot_connections()","title":"Metric graph — metric_graph","text":"Plots connections graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot_connections()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-22","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-function-","dir":"Reference","previous_headings":"","what":"Method plot_function()","title":"Metric graph — metric_graph","text":"Plots continuous function graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot_function(   X,   plotly = FALSE,   vertex_size = 5,   vertex_color = \"black\",   edge_width = 1,   edge_color = \"black\",   line_width = NULL,   line_color = \"rgb(0,0,200)\",   support_width = 0.5,   support_color = \"gray\",   p = NULL,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"X Either m x 3 matrix (edge number, position curve (length), value) vector values function evaluated mesh graph plotly TRUE, plot shown 3D. option requires package 'plotly'. vertex_size Size vertices. vertex_color Color vertices. edge_width Width edges. edge_color 3D plot, color edges. line_width 3D plot, line width function curve. line_color Color function curve. support_width 3D plot, width support lines. support_color 3D plot, color support lines. p Previous plot new plot added. ... Additional arguments ggplot() plot_ly()","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-23","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"Either ggplot (plotly = FALSE) plot_ly object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-movie-","dir":"Reference","previous_headings":"","what":"Method plot_movie()","title":"Metric graph — metric_graph","text":"Plots movie continuous function evolving graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot_movie(   X,   plotly = TRUE,   vertex_size = 5,   vertex_color = \"black\",   edge_width = 1,   edge_color = \"black\",   line_width = NULL,   line_color = \"rgb(0,0,200)\",   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"X m x T matrix ith column represents function ith time, evaluated mesh locations. plotly TRUE, plot shown 3D. option requires package 'plotly'. vertex_size Size vertices. vertex_color Color vertices. edge_width Width edges. edge_color 3D plot, color edges. line_width 3D plot, line width function curve. line_color Color function curve. ... Additional arguments ggplot plot_ly.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-24","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"Either ggplot (plotly=FALSE) plot_ly object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-add-mesh-observations-","dir":"Reference","previous_headings":"","what":"Method add_mesh_observations()","title":"Metric graph — metric_graph","text":"Add observations mesh object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$add_mesh_observations(data = NULL, group = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data data.frame named list containing observations. case groups, data.frames groups stacked vertically, column indicating index group. data_frame NULL, takes priority eventual data Spoints. group data_frame contains groups, one must provide column group indices stored.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-25","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. observations stored data element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-initial-graph-","dir":"Reference","previous_headings":"","what":"Method get_initial_graph()","title":"Metric graph — metric_graph","text":"Returns copy initial metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_initial_graph()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-26","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-a-","dir":"Reference","previous_headings":"","what":"Method A()","title":"Metric graph — metric_graph","text":"Get observation/prediction matrix ","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-27","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$A(group = NULL, obs_to_vert = FALSE, include_NA = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"group vector. NULL, matrix first group returned. One can use groups simply setting group variable __all. Otherwise, matrix groups vector returned. obs_to_vert observations turned vertices? include_NA locations observations NA included?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-27","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"observation prediction matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-coordinates-","dir":"Reference","previous_headings":"","what":"Method coordinates()","title":"Metric graph — metric_graph","text":"Convert locations graph Euclidean coordinates.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-28","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$coordinates(PtE = NULL, XY = NULL, normalized = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Matrix locations graph (edge number normalized position edge). XY Matrix locations Euclidean space normalized TRUE, assumed positions PtE normalized (0,1), object returned XY specified contains normalized locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-28","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"PtE specified, matrix Euclidean coordinates locations returned. XY provided, matrix closest locations graph returned.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Metric graph — metric_graph","text":"objects class cloneable method.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-29","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$clone(deep = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"deep Whether make deep clone.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Metric graph — metric_graph","text":"","code":"library(sp) line1 <- Line(rbind(c(0, 0), c(2, 0))) line2 <- Line(rbind(c(2, 0), c(1, 1))) line3 <- Line(rbind(c(1, 1), c(0, 0))) lines <-  SpatialLines(list(Lines(list(line1), ID = \"1\"),                            Lines(list(line2), ID = \"2\"),                            Lines(list(line3), ID = \"3\"))) graph <- metric_graph$new(lines) graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":null,"dir":"Reference","previous_headings":"","what":"Traffic speed data from San Jose, California — pems","title":"Traffic speed data from San Jose, California — pems","text":"Data set traffic speed observations highways city San Jose, California.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Traffic speed data from San Jose, California — pems","text":"","code":"pems"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"pems","dir":"Reference","previous_headings":"","what":"pems","title":"Traffic speed data from San Jose, California — pems","text":"list three elements: lines SpatialLines object containing road segments. PtE Locations observations road segments data.frame 325 rows 2 columns. first column indicates edge number second column indicates distance edge position. Y Observations traffic speed. Consists vector 325 observations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Traffic speed data from San Jose, California — pems","text":"https://www.openstreetmap.org https://github.com/spbu-math-cs/Graph-Gaussian-Processes/blob/main/examples/data/PEMS.zip","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Traffic speed data from San Jose, California — pems","text":"Chen, C., K. Petty, . Skabardonis, P. Varaiya, Z. Jia (2001). Freeway performance measurement system: mining loop detector data. Transportation Research Record 1748(1), 96–102. OpenStreetMap contributors (2017). Planet dump retrieved https://planet.osm.org. https://www.openstreetmap.org.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"Auxiliary function obtain plots predictions field using 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"","code":"# S3 method for graph_bru_pred plot(x, y = NULL, vertex_size = 0, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"x predicted object obtained predict method. y used. vertex_size Size vertices. ... Additional parameters passed plot function.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"'ggplot2' object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":null,"dir":"Reference","previous_headings":"","what":"Leave-one-out crossvalidation for graph_lme models assuming observations at\nthe vertices of metric graphs — posterior_crossvalidation","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at\nthe vertices of metric graphs — posterior_crossvalidation","text":"Leave-one-crossvalidation graph_lme models assuming observations vertices metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at\nthe vertices of metric graphs — posterior_crossvalidation","text":"","code":"posterior_crossvalidation(object)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at\nthe vertices of metric graphs — posterior_crossvalidation","text":"object fitted model using graph_lme() function.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at\nthe vertices of metric graphs — posterior_crossvalidation","text":"Vector posterior expectations variances well mean absolute error (MAE), root mean squared errors (RMSE), three negatively oriented proper scoring rules: log-score, CRPS, scaled CRPS.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"Prediction mixed effects regression model metric graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"","code":"# S3 method for graph_lme predict(   object,   data = NULL,   mesh = FALSE,   mesh_h = 0.01,   repl = NULL,   compute_variances = FALSE,   posterior_samples = FALSE,   n_samples = 100,   only_latent = FALSE,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   normalized = FALSE,   return_as_list = FALSE,   return_original_order = TRUE,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"object fitted object graph_lme() function. data data.frame list containing covariates, edge number distance edge locations obtain prediction. mesh Obtain predictions mesh nodes? graph must mesh, either only_latent set TRUE model covariates. mesh_h graph mesh, one created value 'h'. repl replicates obtain prediction. NULL predictions obtained replicates. Default NULL. compute_variances Set also TRUE compute kriging variances. posterior_samples TRUE, posterior samples returned. n_samples Number samples returned. used sampling TRUE. only_latent posterior samples predictions given latent model? edge_number Name variable contains edge number, default edge_number. distance_on_edge Name variable contains distance edge, default distance_on_edge. normalized distances edges normalized? return_as_list means predictions posterior samples returned list, replicate element? return_original_order results return original (input) order order inside graph? ... used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"list elements mean, contains means predictions, variance (compute_variance TRUE), contains variances predictions, samples (posterior_samples TRUE), contains posterior samples.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"Auxiliar function obtain predictions field using 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"","code":"# S3 method for inla_metric_graph_spde predict(   object,   cmp,   bru_fit,   data = NULL,   formula = NULL,   data_coords = c(\"PtE\", \"euclidean\"),   normalized = TRUE,   n.samples = 100,   seed = 0L,   probs = c(0.025, 0.5, 0.975),   return_original_order = TRUE,   num.threads = NULL,   include = NULL,   exclude = NULL,   drop = FALSE,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"object inla_metric_graph_spde object built graph_spde() function. cmp 'inlabru' component used fit model. bru_fit fitted model using 'inlabru' 'INLA'. data data.frame covariates needed prediction. locations must normalized PtE. formula formula right hand side defines R expression evaluate generated sample. NULL, latent hyperparameter states returned named list elements. See Details information. data_coords decides coordinate system use. PtE, user must provide locations data frame first column edge number second column distance edge, otherwise euclidean, user must provide data frame first column x Euclidean coordinates second column y Euclidean coordinates. normalized TRUE, distances distance edge assumed normalized (0,1). Default TRUE. used data_coords euclidean. n.samples Integer setting number samples draw order calculate posterior statistics. default rather low provides quick approximate result. seed Random number generator seed passed inla.posterior.sample() probs numeric vector probabilities values standard unit interval passed stats::quantile return_original_order predictions returned original order? num.threads Specification desired number threads parallel computations. Default NULL, leaves 'INLA'. seed != 0, overridden \"1:1\" include Character vector component labels needed predictor expression; Default: NULL (include components explicitly excluded) exclude Character vector component labels used predictor expression. exclusion list applied list determined include parameter; Default: NULL (remove components inclusion list) drop logical; keep=FALSE, data SpatialDataFrame, prediciton summary number rows data, output SpatialDataFrame object. Default FALSE. ... Additional arguments passed inla.posterior.sample().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"list predictions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"Auxiliar function obtain predictions field using 'inlabru' 'rSPDE'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"","code":"# S3 method for rspde_metric_graph predict(   object,   cmp,   bru_fit,   data = NULL,   formula = NULL,   data_coords = c(\"PtE\", \"euclidean\"),   normalized = TRUE,   n.samples = 100,   seed = 0L,   probs = c(0.025, 0.5, 0.975),   num.threads = NULL,   include = NULL,   exclude = NULL,   drop = FALSE,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"object rspde_metric_graph object built rspde.metric_graph() function. cmp 'inlabru' component used fit model. bru_fit fitted model using 'inlabru' 'INLA'. data data.frame covariates needed prediction. locations must normalized PtE. formula formula right hand side defines R expression evaluate generated sample. NULL, latent hyperparameter states returned named list elements. See Details information. data_coords decides coordinate system use. PtE, user must provide locations data frame first column edge number second column distance edge, otherwise euclidean, user must provide data frame first column x Euclidean coordinates second column y Euclidean coordinates. normalized TRUE, distances distance edge assumed normalized (0,1). Default TRUE. used data_coords euclidean. n.samples Integer setting number samples draw order calculate posterior statistics. default rather low provides quick approximate result. seed Random number generator seed passed inla.posterior.sample probs numeric vector probabilities values standard unit interval passed stats::quantile. num.threads Specification desired number threads parallel computations. Default NULL, leaves 'INLA'. seed != 0, overridden \"1:1\" include Character vector component labels needed predictor expression; Default: NULL (include components explicitly excluded) exclude Character vector component labels used predictor expression. exclusion list applied list determined include parameter; Default: NULL (remove components inclusion list) drop logical; keep=FALSE, data SpatialDataFrame, prediciton summary number rows data, output SpatialDataFrame object. Default FALSE. ... Additional arguments passed inla.posterior.sample.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"list predictions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Samples a Whittle-Matérn field on a metric graph — sample_spde","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"Obtains samples Whittle-Matérn field metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"","code":"sample_spde(   kappa,   tau,   range,   sigma,   sigma_e = 0,   alpha = 1,   graph,   PtE = NULL,   type = \"manual\",   posterior = FALSE,   nsim = 1,   method = c(\"conditional\", \"Q\"),   BC = 1 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"kappa Range parameter. tau Precision parameter. range Practical correlation range parameter. sigma Marginal standard deviation parameter. sigma_e Standard deviation measurement noise. alpha Smoothness parameter. graph metric_graph object. PtE Matrix locations (edge, normalized distance edge) samples generated. type \"manual\" set, sampling done locations specified PtE. Set \"mesh\" simulation mesh nodes, \"obs\" simulation observation locations. posterior Sample conditionally observations? nsim Number samples generated. method method use sampling? options \"conditional\" \"Q\". , \"Q\" stable takes longer. BC Boundary conditions degree 1 vertices. BC = 0 gives Neumann boundary conditions BC = 1 gives stationary boundary conditions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"Matrix vector samples.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"Samples Gaussian Whittle-Matérn field metric graph, either prior conditionally observations $$y_i = u(t_i) + \\sigma_e e_i$$ graph,  \\(e_i\\) independent standard Gaussian variables. parameters field can either specified terms tau kappa practical correlation range marginal standard deviation.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":null,"dir":"Reference","previous_headings":"","what":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"Simulation starting value u0","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"","code":"simulate_spacetime(graph, t, kappa, rho, gamma, alpha, beta, sigma, u0, BC = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"graph metric_graph object. t Vector time points. kappa Spatial range parameter. rho Drift parameter. gamma Temporal range parameter. alpha Smoothness parameter (integer) spatial operator. beta Smoothness parameter (integer) Q-Wiener process. sigma Variance parameter. u0 Starting value. BC boundary condition use (0,1). , 0 adjustment boundary 1 results making boundary condition stationary.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"Precision matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Covariance function for Whittle-Matérn fields — spde_covariance","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"Computes covariance function Whittle-Matérn field.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"","code":"spde_covariance(P, kappa, tau, range, sigma, alpha, graph)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"P Location (edge number normalized location edge) location evaluate covariance function . kappa Parameter kappa SPDE. tau Parameter tau SPDE. range Range parameter. sigma Standard deviation parameter. alpha Smoothness parameter (1 2). graph metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"Vector covariance function evaluate mesh locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"Compute covariance function \\(\\rho(P,s_i)\\) P provided location \\(s_i\\) locations mesh graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"Extract field parameter values distributions metric graph spde effect 'INLA' result object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"","code":"spde_metric_graph_result(   inla,   name,   metric_graph_spde,   compute.summary = TRUE,   n_samples = 5000,   n_density = 1024 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"inla 'INLA' object obtained call inla(). name character string name 'rSPDE' effect model. metric_graph_spde inla_metric_graph_spde object used random effect model. compute.summary summary computed? n_samples number samples used parameterization matern. n_density number equally spaced points estimate density.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"model fitted matern parameterization (default), returns list containing: marginals.range Marginal densities range parameter. marginals.log.range Marginal densities log(range). marginals.sigma Marginal densities std. deviation. marginals.log.sigma Marginal densities log(std. deviation). marginals.values Marginal densities field values. summary.log.range Summary statistics log(range). summary.log.sigma Summary statistics log(std. deviation). summary.values Summary statistics field values. compute.summary TRUE, list also contain summary.kappa Summary statistics kappa. summary.tau Summary statistics tau. model fitted spde parameterization, returns list containing: marginals.kappa Marginal densities kappa. marginals.log.kappa Marginal densities log(kappa). marginals.log.tau Marginal densities log(tau). marginals.tau Marginal densities tau. marginals.values Marginal densities field values. summary.log.kappa Summary statistics log(kappa). summary.log.tau Summary statistics log(tau). summary.values Summary statistics field values. compute.summary TRUE, list also contain summary.kappa Summary statistics kappa. summary.tau Summary statistics tau.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix for Whittle-Matérn fields — spde_precision","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"Computes precision matrix vertices Whittle-Matérn field.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"","code":"spde_precision(kappa, tau, alpha, graph, BC = 1, build = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"kappa Range parameter. tau Precision parameter. alpha Smoothness parameter (1 2). graph metric_graph object. BC Set boundary conditions degree=1 vertices. BC =0 gives Neumann boundary conditions BC=1 gives stationary boundary conditions. build TRUE, precision matrix returned. Otherwise list list(,j,x, nv) returned.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"Precision matrix list.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for graph_lme Objects — summary.graph_lme","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"Function providing summary results related metric graph mixed effects regression models.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"","code":"# S3 method for graph_lme summary(object, all_times = FALSE, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"object object class graph_lme containing results fitted model. all_times Show computed times. ... used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"object class summary_graph_lme containing information graph_lme object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.metric_graph_spde_result","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.metric_graph_spde_result","text":"Summary posteriors 'rSPDE' field parameters original scales.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.metric_graph_spde_result","text":"","code":"# S3 method for metric_graph_spde_result summary(object, digits = 6, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.metric_graph_spde_result","text":"object rspde.result object. digits Integer, used number formatting signif() ... Currently used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.metric_graph_spde_result","text":"data.frame containing summary.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-112","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.1.2","title":"MetricGraph 1.1.2","text":"Adjusts ensure compatibility future releases Matrix package.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-111","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.1.1","title":"MetricGraph 1.1.1","text":"CRAN release: 2023-06-01 Adjusts documentation CRAN.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-110","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.1.0","title":"MetricGraph 1.1.0","text":"Improved documentation. Reorganized functions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-100","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.0.0","title":"MetricGraph 1.0.0","text":"First version package.","code":""}]
