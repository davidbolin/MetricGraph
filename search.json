[{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MetricGraph: Random Fields on Metric Graphs","text":"lately much interest statistical modeling data compact metric graphs street river networks based Gaussian random fields. R package MetricGraph contains functions working data random fields compact metric graphs. main functionality contained metric_graph class, used specifying metric graphs, adding data , visualization, basic functions needed working data random fields metric graphs. package also implements three types Gaussian processes metric graphs: Whittle–Matérn fields introduced Bolin, Simas, Wallin (2024) Bolin, Simas, Wallin (2023), Gaussian processes isotropic covariance functions Anderes, Møller, Rasmussen (2020), Gaussian models based graph Laplacian Borovitskiy et al. (2021). Basic statistical tasks likelihood evaluation prediction implemented three types models MetricGraph. , package also contains interfaces R-INLA Lindgren Rue (2015), package available http://R-INLA. org/download/ inlabru Bachl et al. (2019) facilitates using packages full Bayesian inference general Latent Gaussian Models (LGMs) includes Whittle–Matérn fields metric graphs. package available install via repository https://github.com/davidbolin/MetricGraph. following sections describe main functionality package summarizes required theory. Section 2 introduces metric graphs metric_graph class, Section 3 shows work random fields metric graphs, Section 4 introduces inlabru interface package application real data. complete introduction functionality package, refer Vignettes available package homepage https://davidbolin.github.io/MetricGraph/. particular, contains introduction INLA interface, implementation Whittle–Matérn fields general smoothness, details examples methods package.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"the-metric_graph-class","dir":"Articles","previous_headings":"","what":"The metric_graph class","title":"MetricGraph: Random Fields on Metric Graphs","text":"compact metric graph \\(\\Gamma\\) consists set finitely many vertices \\(\\mathcal{V}=\\{v_i\\}\\) finite set \\(\\mathcal{E}=\\{e_j\\}\\) edges connecting vertices. edge \\(e\\) defined pair vertices \\((v_i,v_k)\\) finite length \\(l_e \\(0,\\infty)\\). edge graph curve parametrized arc-length, location \\(s\\\\Gamma\\) position edge, can thus represented touple \\((e,t)\\) \\(t\\[0,l_e]\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"basic-constructions","dir":"Articles","previous_headings":"The metric_graph class","what":"Basic constructions","title":"MetricGraph: Random Fields on Metric Graphs","text":"metric graph represented MetricGraph package class metric_graph. object class can constructed two ways. first specify vertex matrix V edge matrix E, assumed edges straight lines. second, flexible, option specify object SpatialLines object using sp package (Bivand, Pebesma, Gomez-Rubio 2013). illustrate , use osmdata package download data OpenStreetMap. following code, extract streets campus King Abdullah University Science Technology (KAUST) SpatialLines object: can now create metric graph follows. command set argument longlat = TRUE since coordinates vertices given Longitude Latitude.  can note warning graph connected, let us create graph_components object contains connected components graphs extract largest connected component work  graph object now contains important features graph, vertex matrix graph$V, number vertices graph$nV, edge matrix graph$E, number edges graph$nE, vector edge lengths graph$get_edge_lengths() given unit km (since specified longlat = TRUE construction). Thus, can obtain range edge lengths unit m : also remove vertices degree 2 using prune_vertices() method:","code":"call <- opq(bbox = c(39.0884, 22.33, 39.115, 22.3056)) call <- add_osm_feature(call, key = \"highway\",value=c(\"motorway\",                                                       \"primary\",\"secondary\",                                                       \"tertiary\",                                                       \"residential\")) data <- osmdata_sp(call) lines <- SpatialLines(data$osm_lines@lines) graph <- metric_graph$new(lines, longlat = TRUE) graph$plot(vertex_size = 0.5) graphs <- graph_components$new(edges = lines, longlat = TRUE) graph <- graphs$get_largest() graph$plot(vertex_size = 0) range(graph$get_edge_lengths(unit=\"m\")) ## Units: [m] ## [1]    5.650044 2141.415006 graph$prune_vertices() graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"understanding-coordinates-on-graphs","dir":"Articles","previous_headings":"The metric_graph class","what":"Understanding coordinates on graphs","title":"MetricGraph: Random Fields on Metric Graphs","text":"locations vertices specified Euclidean coordinates. However, specifying position graph, practical work Euclidean coordinates since locations Euclidean space locations graph. instead better specify location graph touple \\((, t)\\), \\(\\) denotes number edge \\(t\\) location edge. location \\(t\\) can either specified distance start edge (takes values 0 length edge) normalized distance start edge (takes values 0 1). function coordinates can used convert coordinates Euclidean space locations graph. example location normalized distance 0.2 start second edge : function can also used find closest location graph location Euclidean space: case, normalized argument decides whether returned value given normalized distance .","code":"graph$coordinates(PtE = matrix(c(2, 0.2), 1,2), normalized = TRUE) ##          [,1]     [,2] ## [1,] 39.11751 22.31934 graph$coordinates(XY = matrix(c(39.117, 22.319), 1,2)) ##      [,1]      [,2] ## [1,]    2 0.2517662"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"adding-data-to-the-graph","dir":"Articles","previous_headings":"The metric_graph class","what":"Adding data to the graph","title":"MetricGraph: Random Fields on Metric Graphs","text":"Given constructed metric graph, can now add data . details data manipulation metric graphs, see Data manipulation metric graphs. example, let us sample locations edges random add data graph:  One note one needs specify normalized = TRUE function specify locations normalized distance edges. command set, distances interpreted normalized. add_observations() function accepts multiple types inputs. One scenario can common applications data SpatialPoints objects, one can add observations SpatialPointsDataFrame. illustrate , let us sample locations random graph, use function coordinates transform Longitude Latitude coordinates, use create SpatialPointsDataFrame object add graph:  want replace data object, can use clear_observations() remove current data.","code":"n.obs <- 10 data <- data.frame(edge_number = sample(1:graph$nE, n.obs),                    distance_on_edge = runif(n.obs),                    y = rnorm(n.obs)) graph$add_observations(data = data, normalized = TRUE) ## Adding observations... ## The unit for edge lengths is km ## The current tolerance for removing distant observations is (in km): 1.07070750299905 graph$plot(data = \"y\", vertex_size = 0) obs.loc <- cbind(sample(1:graph$nE, n.obs), runif(n.obs)) obs.lonlat <- graph$coordinates(PtE = obs.loc, normalized = TRUE) obs <- rnorm(n.obs) points <- SpatialPointsDataFrame(coords = obs.lonlat,                                  data = data.frame(y = obs)) graph$add_observations(points) ## Adding observations... ## The unit for edge lengths is km ## The current tolerance for removing distant observations is (in km): 1.07070750299905 ## Converting data to PtE ## This step may take long. If this step is taking too long consider pruning the vertices to possibly obtain some speed up. ## [1] y        .coord_x .coord_y ## <0 rows> (or 0-length row.names) graph$plot(data = \"y\", vertex_size = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"working-with-functions-on-metric-graphs","dir":"Articles","previous_headings":"The metric_graph class","what":"Working with functions on metric graphs","title":"MetricGraph: Random Fields on Metric Graphs","text":"working data metric graphs, one often wants display functions graph. best way visualize functions graph evaluate fine mesh graph use plot_function. illustrate procedure, let us construct mesh graph:  command build_mesh, argument h decides largest spacing nodes mesh. chose 100m bit coarse. let us reduce value h 10m rebuild mesh: Suppose now want display function \\(f(s) = \\text{Longitude}(s) - \\text{Latitude}(s)\\) graph. first evaluate vertices mesh use function plot_function display :  Alternatively, can set plotly = TRUE plot command get 3D visualization function using plotly (Sievert 2020) package. first argument plot_function vector, function assumes values vector values function evaluated vertices mesh. alternative, one can also provide first argument matrix consisting triplets \\((, t, f(, t))\\), \\(\\) denotes edge number, \\(t\\) location edge, \\(f(, t)\\) value point.","code":"graph$build_mesh(h = 100/1000) graph$plot(mesh=TRUE) graph$build_mesh(h = 10/1000) lon <- graph$mesh$V[, 1] lat <- graph$mesh$V[, 2] f <- lon - lat graph$plot_function(X = f, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"random-fields-on-metric-graphs","dir":"Articles","previous_headings":"","what":"Random fields on metric graphs","title":"MetricGraph: Random Fields on Metric Graphs","text":"defined metric graph, now ready specify Gaussian processes . section, briefly cover three main types Gaussian processes supported. begin main class models, Whittle–Matérn fields, consider Gaussian processes isotropic covariance functions, finally look discrete models based graph Laplacian.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"whittlematérn-fields","dir":"Articles","previous_headings":"Random fields on metric graphs","what":"Whittle–Matérn fields","title":"MetricGraph: Random Fields on Metric Graphs","text":"Gaussian Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha/2} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"sampling","dir":"Articles","previous_headings":"Random fields on metric graphs > Whittle–Matérn fields","what":"Sampling","title":"MetricGraph: Random Fields on Metric Graphs","text":"example, let us simulate field \\(u\\) graph using \\(\\alpha = 1\\). , draw locations random, sample field locations plot result  can also sample field mesh graph follows:  Since \\(\\alpha=1\\), sample paths continuous differentiable. visualize correlation structure field, can compute plot covariances point points graph follows:  obtain field differentiable sample paths, can change \\(\\alpha=2\\) code .","code":"sigma <- 1.3 range <- 0.15 # range parameter sigma_e <- 0.1  n.obs <- 200 obs.loc <- cbind(sample(1:graph$nE, n.obs, replace=TRUE), runif(n.obs))  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = obs.loc) graph$clear_observations() graph$add_observations(data = data.frame(edge_number = obs.loc[, 1],                                          distance_on_edge = obs.loc[, 2],                                          u = u),                        normalized = TRUE) ## Adding observations... ## The unit for edge lengths is km ## The current tolerance for removing distant observations is (in km): 1.07070750299905 graph$plot(data = \"u\", vertex_size = 0) u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, type = \"mesh\") graph$plot_function(X = u, vertex_size = 0, edge_width = 0.5) C <- spde_covariance(c(200, 0.1), range = range, sigma = sigma, alpha = 1,                             graph = graph) graph$plot_function(X = C, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"inference","dir":"Articles","previous_headings":"Random fields on metric graphs > Whittle–Matérn fields","what":"Inference","title":"MetricGraph: Random Fields on Metric Graphs","text":"following examples consider models without replicates. Please, see Gaussian random fields metric graphs vignette examples replicates. Suppose data form \\[ y_i = \\beta_1\\text{lon}(s_i) +  \\beta_1\\text{lat}(s_i) +  u(s_i) + \\varepsilon_i, \\quad =1,\\ldots,n \\] \\(s_i\\\\Gamma\\) observation locations, lon lat longitude latitude locations, \\(\\beta_1,\\beta_2\\) regression coefficients, \\(\\varepsilon_i\\) independent centered Gaussian variables \\(N(0,\\sigma_e^2)\\) representing measurement noise. Let us create observations, clear current data graph, finally add data graph:  goal now fit linear mixed-effects model data assuming Whittle-Mat'ern latent model \\(\\alpha=1\\). end, can use graph_lme() function. specify model, fit linear regression model. , let us first fit simple linear regression model illustrate: can get summary: Let us now fit linear mixed-effects model Whittle-Mat'ern latent model \\(\\alpha=1\\). end, can either specify model argument 'alpha1' following list: list(type = 'WhittleMatern', alpha = 1). list makes easier understand model chosen random effect, however, makes longer, less convenient, write. Let us use simplified form: Let us get summary result: can obtain additional information using glance(): now compare true values random effects: Given estimated parameters, can now kriging estimate field locations graph. example, now obtain predictions regular mesh previously constructed. First, obtain covariates mesh locations. Now, can compute predictions \\(y\\). First, let us compute posterior mean field observation locations plot residuals posterior means field:  can also obtain predictions using augment() function: Let us first plot predictions field, fitted values:  Let us now plot fitted values along observed values:  Let us now obtain predictions field mesh equally spaced nodes graph. First, let us create mesh data.frame: Now, let us obtain predictions. can obtain estimates latent field taking re_mean element pred list obtained calling prediction():  Finally, let us obtain predictions observed values mesh. case use mean component pred list:  procedure can done \\(\\alpha = 2\\). One can also estimate \\(\\alpha\\) data described vignette Whittle–Matérn fields general smoothness.","code":"sigma <- 2 range <- 0.2 # range parameter sigma_e <- 0.1  n.obs.1 <- 400 # all edges n.obs.2 <- 100 # long edges  n.obs <- n.obs.1 + n.obs.2  obs.loc <- cbind(sample(1:graph$nE, n.obs.1, replace=TRUE), runif(n.obs.1))  # Let us now add some locations on long edges: long.edges <- graph$edge_lengths > 0.5  obs.loc <- rbind(obs.loc, cbind(sample(which(long.edges), n.obs.2, replace=TRUE), runif(n.obs.2)))  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = obs.loc)  beta0 = -1 beta1 = 1 beta2 = 2 lonlat <- graph$coordinates(PtE = obs.loc) scaled_lonlat <- scale(lonlat) y <- beta0 + beta1 * scaled_lonlat[, 1] + beta2 * scaled_lonlat[, 2] + u + sigma_e*rnorm(n.obs)  data <- data.frame(edge_number = obs.loc[, 1],                    distance_on_edge = obs.loc[, 2],                    lon = scaled_lonlat[, 1],                    lat = scaled_lonlat[, 2],                    y = y)  graph$clear_observations() graph$plot(X = y, X_loc = obs.loc, vertex_size = 0) graph$add_observations(data = data, normalized = TRUE) ## Adding observations... ## The unit for edge lengths is km ## The current tolerance for removing distant observations is (in km): 1.07070750299905 res_lm <- graph_lme(y ~ lon + lat, graph = graph) summary(res_lm) ##  ## Linear regression model ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph) ##  ## Fixed effects: ##             Estimate Std. Error t value Pr(>|t|)     ## (Intercept) -1.13093    0.06936  -16.31   <2e-16 *** ## lon          0.93551    0.07075   13.22   <2e-16 *** ## lat          2.04390    0.07075   28.89   <2e-16 *** ##  ## No random effects. ##  ## Measurement error: ## std. dev  ## 1.550846  ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -927.3651 res <- graph_lme(y ~ lon + lat, graph = graph, model = 'WM1') summary(res) ##  ## Latent model - Whittle-Matern with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph, model = \"WM1\") ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)  -1.1014    0.1181  -9.324  < 2e-16 *** ## lon           0.9511    0.1201   7.922 2.34e-15 *** ## lat           1.9748    0.1232  16.035  < 2e-16 *** ##  ## Random effects: ##        Estimate Std.error z-value ## tau    0.114099  0.005449  20.941 ## kappa 11.506072  1.742238   6.604 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma  1.82701   0.09598  19.036 ## range  0.17382   0.02583   6.729 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.07595   0.04519   1.681 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -794.3335  ## Number of function calls by 'optim' = 26 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  44.28949 secs glance(res) ## # A tibble: 1 × 9 ##    nobs  sigma logLik   AIC   BIC deviance df.residual model         alpha ##   <int>  <dbl>  <dbl> <dbl> <dbl>    <dbl>       <dbl> <chr>         <dbl> ## 1   500 0.0760  -794. 1601. 1626.    1589.         494 WhittleMatern     1 sigma_e_est <- res$coeff$measurement_error[[1]] sigma_est <- res$matern_coeff$random_effects[1] range_est <- res$matern_coeff$random_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##             sigma_e   sigma     range ## Truth    0.10000000 2.00000 0.2000000 ## Estimate 0.07595015 1.82701 0.1738213 pred_u <- predict(res, newdata = data, normalized = TRUE) pred_u$resid_field <- pred_u$re_mean - u pred_u <- graph$process_data(data = pred_u, normalized=TRUE) pred_u %>% graph$plot(data = \"resid_field\", vertex_size = 0) pred_aug <- augment(res, newdata = data, normalized = TRUE)  pred_aug %>% graph$plot(data = \".random\", vertex_size = 0) pred_aug %>% graph$plot(data = \".fitted\", vertex_size = 0) graph$build_mesh(h = 50/1000) lonlat_mesh <- graph$coordinates(PtE = graph$mesh$VtE) scaled_lonlat_mesh <- scale(lonlat_mesh,                              center = attr(scaled_lonlat, \"scaled:center\"),                             attr(scaled_lonlat, \"scaled:scale\")) data_mesh_pred <- data.frame(lon = scaled_lonlat_mesh[,1],                               lat = scaled_lonlat_mesh[,2],                               edge_number = graph$mesh$VtE[,1],                               distance_on_edge = graph$mesh$VtE[,2]) # Let us remove duplicated vertices (that were created due to being too close) data_mesh_pred <- data_mesh_pred[!duplicated(graph$mesh$V),] pred <- predict(res, newdata=data_mesh_pred, normalized=TRUE) u_est <- pred$re_mean graph$plot_function(X = u_est, vertex_size = 0, edge_width = 0.5) y_est <- pred$mean graph$plot_function(X = y_est, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"isotropic-gaussian-fields","dir":"Articles","previous_headings":"Random fields on metric graphs","what":"Isotropic Gaussian fields","title":"MetricGraph: Random Fields on Metric Graphs","text":"metric graphs Euclidean edges, Anderes, Møller, Rasmussen (2020) showed one can define valid Gaussian processes various isotropic covariance functions distances points measured -called resistance metric \\(d(\\cdot,\\cdot)\\). One example valid covariance function isotropic exponential covariance function \\[ r(d(s,t)) = \\sigma^2\\exp(-\\kappa d(s,t)). \\] covariance similar Whittle–Mat'ern fields \\(\\alpha = 1\\). two, recommend using Whittle–Matérn model since Markov properties makes inference much faster. , covariance well-defined compact metric graph, whereas isotropic exponential guaranteed positive definite graph Euclidean edges. See Bolin, Simas, Wallin (2023) comparisons. However, let us now illustrate use data generated . work covariance function, cumbersome thing compute metric. metric_graph class built support , can obtain distances observation locations However, goal fit model using covariance function, need user compute . done internally one uses graph_lme() function. need set model argument graph_lme() list type \"isoCov\" (need add additional arguments, exponential covariance default). Let us fit linear regression model random effect given Gaussian field isotropic exponential covariance function (alternatively, one can also write model = 'isoExp'): Observe received warning saying check graph Euclidean edges. due fact isotropic covariance models known work graphs Euclidean edges. Let us check graph Euclidean edges. end, need use check_euclidean() method: Now, simply call graph print characteristics check information: Observe graph Euclidean edges. means model isotropic exponential covariance guaranteed work graph. case, can try fit anyway. Observe now receive different warning, since now know fact graph Euclidean edges. case, set model isoexp conveniency. can also glance fitted model: Let us now compute posterior mean field observation locations plot residuals field posterior means field:  perform kriging prediction locations, one can use predict() method along data.frame containing locations one wants obtain predictions corresponding covariate values locations. example use data_mesh_pred previous example. Let us estimate observed values mesh locations:","code":"graph$compute_resdist() res_exp <- graph_lme(y ~ lon + lat, graph = graph, model = list(type = \"isoCov\")) ## Warning in graph_lme(y ~ lon + lat, graph = graph, model = list(type = ## \"isoCov\")): No check for Euclidean edges have been perfomed on this graph. The ## isotropic covariance models are only known to work for graphs with Euclidean ## edges. You can check if the graph has Euclidean edges by running the ## `check_euclidean()` method. See the vignette ## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html ## for further details. graph$check_euclidean() graph ## A metric graph with  248  vertices and  397  edges. ##  ## Vertices: ##   Degree 1: 12;  Degree 2: 1;  Degree 3: 164;  Degree 4: 67;  Degree 5: 4;  ##   With incompatible directions:  1  ##  ## Edges:  ##   Lengths:  ##       Min: 0.005650044  ; Max: 2.141415  ; Total: 64.48864  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  degrees  ; Lengths unit:  km  ##  ## Longitude and Latitude coordinates:  TRUE ##   Which spatial package:  sp  ##   CRS:  +proj=longlat +datum=WGS84 +no_defs ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: TRUE ##   Is a tree: FALSE ##   Distance consistent: unknown ## To check if the graph satisfies the distance consistency, run the `check_distance_consistency()` method. ##   Has Euclidean edges: FALSE res_exp <- graph_lme(y ~ lon + lat, graph = graph, model = \"isoexp\") ## Warning in graph_lme(y ~ lon + lat, graph = graph, model = \"isoexp\"): This ## graph DOES NOT have Euclidean edges. The isotropic covariance models are NOT ## guaranteed to work for this graph! See the vignette ## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html ## for further details. summary(res_exp) ##  ## Latent model - Covariance-based model ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph, model = \"isoexp\") ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)  -1.1399    0.1846  -6.175 6.61e-10 *** ## lon           0.9183    0.1423   6.454 1.09e-10 *** ## lat           2.0044    0.1644  12.194  < 2e-16 *** ##  ## Random effects: ##       Estimate Std.error z-value ## tau    1.71966   0.09721  17.690 ## kappa 14.04626   2.41997   5.804 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.06769   0.04953   1.367 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -801.5418  ## Number of function calls by 'optim' = 40 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  14.72003 secs glance(res_exp) ## # A tibble: 1 × 9 ##    nobs  sigma logLik   AIC   BIC deviance df.residual model  cov_function   ##   <int>  <dbl>  <dbl> <dbl> <dbl>    <dbl>       <dbl> <chr>  <chr>          ## 1   500 0.0677  -802. 1615. 1640.    1603.         494 isoCov exp_covariance pred_exp <- predict(res_exp, newdata = data, normalized = TRUE) graph$plot(X = pred_exp$re_mean - u, X_loc = data[,1:2], vertex_size = 0) pred_exp_y <- predict(res_exp, newdata = data_mesh_pred,                      normalized=TRUE) y_est_exp <- pred_exp_y$mean graph$plot_function(X = y_est_exp, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"models-based-on-the-graph-laplacian","dir":"Articles","previous_headings":"Random fields on metric graphs","what":"Models based on the Graph Laplacian","title":"MetricGraph: Random Fields on Metric Graphs","text":"final set Gaussian models supported MetricGraph Matérn type processes based graph Laplacian introduced Borovitskiy et al. (2021). multivariate Gaussian distributions, defined vertices equation \\[ (\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha/2}\\mathbf{u} = \\mathbf{W} \\] \\(\\mathbf{W}\\sim N(0,\\sigma^2\\mathbf{})\\) vector independent Gaussian variables \\(\\mathbf{\\Delta}_\\Gamma\\) graph Laplacian. , \\(\\mathbf{u}\\) vector values process vertices \\(\\Gamma\\), definition precision matrix \\[ \\mathbf{Q} = \\sigma^{-2}(\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha} \\] Thus, define models, “difficult” thing compute graph Laplacian. (weighted) graph Laplacian, weights specified edge lengths can computed function compute_laplacian() metric_graph object. Suppose want fit data defined model. can use graph_lme() function. Also, observe need use compute_laplacian() function, done internally. now set model argument list type \"GraphLaplacian\" (alternatively, one can also write model = 'GL1') obtain graph Laplacian model alpha=1: can also glance fitted model: can now obtain prediction observed locations using predict() method. Let us compute posterior mean field observation locations plot residuals field posterior means field:  Now, predictions outside observation locations graph Laplacian model, need modify graph. modifies model entirety. Thus, need refit model observation locations want predictions. However, use predict() method observations outside observation locations, predict() return predictions together warning one refit model obtain proper predictions. , see (incorrect way obtaining) predictions observed data:  Let us now refit model locations want obtain predictions. Let us create new data set original locations locations want obtain predictions (y=NA locations want obtain predictions): Let us clone graph add new data: Let us now fit model data: One compare estimates ones obtained model without prediction locations. Let us first compute residual latent field posterior means observation locations:  Let us now obtain predictions desired locations (correct way) observed data:","code":"res_gl <- graph_lme(y ~ lon + lat, graph = graph, model = list(type = \"GraphLaplacian\"),                              optim_method = \"Nelder-Mead\") summary(res_gl) ##  ## Latent model - graph Laplacian SPDE with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph, model = list(type = \"GraphLaplacian\"),  ##     optim_method = \"Nelder-Mead\") ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)  -1.1225    0.1145  -9.801  < 2e-16 *** ## lon           0.9618    0.1199   8.024 1.02e-15 *** ## lat           2.0373    0.1179  17.277  < 2e-16 *** ##  ## Random effects: ##       Estimate Std.error z-value ## tau   0.109437  0.006147  17.803 ## kappa 2.993409  0.383903   7.797 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma  3.73454   0.14569  25.633 ## range  0.66813   0.07945   8.409 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.05041   0.08726   0.578 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -792.0891  ## Number of function calls by 'optim' = 491 ## Optimization method used in 'optim' = Nelder-Mead ##  ## Time used to:     fit the model =  3.4299 secs glance(res_gl) ## # A tibble: 1 × 9 ##    nobs  sigma logLik   AIC   BIC deviance df.residual model          alpha ##   <int>  <dbl>  <dbl> <dbl> <dbl>    <dbl>       <dbl> <chr>          <dbl> ## 1   500 0.0504  -792. 1596. 1621.    1584.         494 GraphLaplacian     1 pred_GL <- predict(res_gl, newdata = data, normalized = TRUE) graph$plot(X = pred_GL$re_mean - u, X_loc = data[,1:2], vertex_size = 0) pred_GL_y <- predict(res_gl, newdata = data_mesh_pred,                      normalized=TRUE) ## Warning in predict.graph_lme(res_gl, newdata = data_mesh_pred, normalized = ## TRUE): There are prediction locations outside of the observation locations. ## Refit the model with all the locations you want to obtain predictions. y_est_GL <- pred_GL_y$mean graph$plot_function(X = y_est_GL, vertex_size = 0, edge_width = 0.5) data_mesh_temp <- data_mesh_pred data_mesh_temp[[\"y\"]] <- rep(NA, nrow(data_mesh_pred))  new_data <- merge(data, data_mesh_temp, all = TRUE) graph_pred <- graph$clone() graph_pred$clear_observations() graph_pred$add_observations(data = new_data, normalized = TRUE) ## Adding observations... ## The unit for edge lengths is km ## The current tolerance for removing distant observations is (in km): 1.07070750299905 res_gl_pred <- graph_lme(y ~ lon + lat, graph = graph_pred, model = list(type = \"GraphLaplacian\"),                                 optim_method = \"Nelder-Mead\") summary(res_gl_pred) ##  ## Latent model - graph Laplacian SPDE with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ lon + lat, graph = graph_pred, model = list(type = \"GraphLaplacian\"),  ##     optim_method = \"Nelder-Mead\") ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept) -1.11486   0.09908  -11.25   <2e-16 *** ## lon          0.92625   0.08130   11.39   <2e-16 *** ## lat          2.07185   0.08080   25.64   <2e-16 *** ##  ## Random effects: ##       Estimate Std.error z-value ## tau    0.16682   0.02479   6.730 ## kappa  1.74728   0.42127   4.148 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma   3.2066    0.1942  16.512 ## range   1.1446    0.2376   4.817 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev   0.9317    0.1017   9.162 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -896.1099  ## Number of function calls by 'optim' = 501 ## Optimization method used in 'optim' = Nelder-Mead ##  ## Time used to:     fit the model =  7.22635 secs pred_GL_full <- predict(res_gl_pred, newdata = data, normalized = TRUE) graph$plot(X = pred_GL_full$re_mean - u, X_loc = data[,1:2], vertex_size = 0) pred_GL_y_full <- predict(res_gl_pred, newdata = data_mesh_pred,                      normalized=TRUE) y_est_GL_full <- pred_GL_y_full$mean graph$plot_function(X = y_est_GL_full, vertex_size = 0, edge_width = 0.5)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"the-inlabru-interface","dir":"Articles","previous_headings":"","what":"The inlabru interface","title":"MetricGraph: Random Fields on Metric Graphs","text":"vignette present inlabru interface Whittle–Matérn fields. MetricGraph package also similar interface toR-INLA, described detail INLA interface Whittle–Matérn fields vignette.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"basic-setup-and-estimation","dir":"Articles","previous_headings":"The inlabru interface","what":"Basic setup and estimation","title":"MetricGraph: Random Fields on Metric Graphs","text":"use graph data . inlabru implementation requires observation locations added graph. However, note Whittle–Matérn fields (contrary models based graph Laplacian) changing model adding vertices observation locations. already created extended graph , can use . Now, load INLA inlabru packages. also need create inla model object graph_spde function. default alpha=1. Recall data already graph object (previous models ). Now, create inlabru’s component, formula-like object: formula simple since assuming mean zero, need intercept, covariates model components. However, setup exactly complicated models, exception terms formla. Now, directly fit model: advantage / difference estimates obtain bru function full Bayesian inference (assuming priors model parameters). used default priors creating graph_spde model (see help text function). advantage now obtain point estimates entire posterior distributions parameters. view estimates can use spde_metric_graph_result() function, taking summary(): showing estimate practical correlation range (\\(2/\\kappa\\)) instead \\(\\kappa\\) since easier interpret. now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:","code":"library(INLA) library(inlabru) spde_model <- graph_spde(graph) cmp <- y ~ Intercept(1) + lon + lat + field(loc, model = spde_model) spde_bru_fit <- bru(cmp, data =                graph_data_spde(spde_model, loc_name = \"loc\")[[\"data\"]]) spde_bru_result <- spde_metric_graph_result(spde_bru_fit,                      \"field\", spde_model)  summary(spde_bru_result) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.865990 0.1020060   1.679720 1.861790   2.080050 1.841690 ## range 0.179401 0.0273717   0.132664 0.176923   0.239911 0.171518 result_df_bru <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, range),     mean = c(       spde_bru_result$summary.sigma$mean,       spde_bru_result$summary.range$mean     ),     mode = c(       spde_bru_result$summary.sigma$mode,       spde_bru_result$summary.range$mode     )   )   print(result_df_bru) ##   parameter true      mean      mode ## 1   std.dev  2.0 1.8659895 1.8416887 ## 2     range  0.2 0.1794012 0.1715181 posterior_df_bru_fit <- gg_df(spde_bru_result)    library(ggplot2)    ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/MetricGraph.html","id":"kriging-with-the-inlabru-implementation","dir":"Articles","previous_headings":"The inlabru interface","what":"Kriging with the inlabru implementation","title":"MetricGraph: Random Fields on Metric Graphs","text":"Unfortunately, inlabru implementation compatible inlabru’s predict() method. nature metric graph’s object. end, provided different predict() method. now show kriging help function. begin creating data list positions want predictions. case, want predictions mesh. positions want mesh positions, data.frame previous models. function graph_bru_process_data() helps us converting data.frame inlabru friendly format dealing metric graphs: can now obtain predictions using predict() method. Observe predict() method graph models bit different inlabru’s standard predict() method. Indeed, first argument model created graph_spde() function, second inlabru’s component, remaining done standard predict() method inlabru. Let us plot predictions latent field:  Finally, let us plot predictions observed data mesh locations: Let us plot predictions:","code":"data_list <- graph_bru_process_data(data_mesh_pred, loc = \"loc\") field_pred <- predict(spde_model,                                  cmp,                                 spde_bru_fit,                                  newdata = data_list,                                 formula = ~ field) mean_field_prd <- field_pred$pred[,1] graph$plot_function(X = mean_field_prd, improve_plot = TRUE,                       vertex_size = 0, edge_width = 0.5) obs_pred <- predict(spde_model,                                  cmp,                                 spde_bru_fit,                                  newdata = data_list,                                 formula = ~ Intercept + lat + lon + field) mean_obs_prd <- obs_pred$pred[,1] graph$plot_function(X = mean_obs_prd, improve_plot = TRUE,                     vertex_size = 0, edge_width = 0.5)"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/comparison.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Comparison of different models using real data","text":"vignette contains details Application section Bolin, Simas, Wallin (2023). goal compare predictive power different models metric graphs cross-validation. precisely, consider Whittle–Matérn fields introduced Bolin, Simas, Wallin (2024) Bolin, Simas, Wallin (2023), Gaussian random field isotropic exponential covariance function Anderes, Møller, Rasmussen (2020), Matérn Gaussian processes based graph Laplacian Borovitskiy et al. (2021).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/comparison.html","id":"the-dataset","dir":"Articles","previous_headings":"","what":"The dataset","title":"Comparison of different models using real data","text":"example consider pems data contained MetricGraph package. data consists traffic speed observations highways city San Jose, California. variable y contains traffic speeds. Let us take look observations:","code":"pems_graph <- metric_graph$new(edges = pems$edges, longlat=TRUE)  pems_graph$add_observations(data = pems$data, normalized=TRUE) pems_graph$plot(data = \"y\", vertex_size = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/comparison.html","id":"the-models","dir":"Articles","previous_headings":"","what":"The models","title":"Comparison of different models using real data","text":"assume data following structure: \\[ y_i = \\mu + u(s_i) + \\varepsilon_i, \\quad =1,\\ldots,n, \\] \\(\\mu\\) constant represents mean field, \\(u(\\cdot)\\) Gaussian random field, \\(s_i\\\\Gamma\\) observation locations \\(\\varepsilon_i\\) independent centered Gaussian variables \\(N(0,\\sigma_e^2)\\) representing measurement noise. Let us fit different models, , assume several different possible latent fields \\(u(\\cdot)\\). start fitting Whittle-Matérn field alpha = 1: look summary: Now, fit Whittle-Matérn field alpha = 2: summary: now fit Whittle-Matérn fields alpha = 1 alpha=2, performing boundary correction vertices degree 1. end, set BC=1: Now, let us look summaries: Similarly, let us now fit Matérn Gaussian model based graph Laplacian alpha=1 alpha=2. , first fit models without fixed effects, use results starting values complete optimization. reason estimation otherwise slightly unstable models. look summaries: Observe default optimizer (L-BFGS-B) failed converge, thus alternative optimizer used, fitting graph Laplacian model alpha=2. Let us now fit Gaussian field isotropic exponential covariance function: look summary: Observe warning, message. message tells us check metric graph Euclidean edges. Let us check now: Now, can look graph’s characteristics contained summary: Thus, graph Euclidean edges. means, fit model, actually modify graph, add obvservations vertices. default, fitting isotropic models, graph_lme() function checks metric graph adding observations vertices Euclidean edges. can check looking euclidean element fitted model: Therefore, even adding observations vertices, metric graph still Euclidean. Let us check can fit isotropic model isotropic Matérn covariance function smoothness parameter nu=1.5 (corresponds alpha=2 Whittle-Matérn fields Matérn Gaussian models based graph Laplacian). Recall results Anderes, Møller, Rasmussen (2020), guaranteed function valid covariance function even metric graph Euclidean edges. start defining Matérn covariance corresponding alpha=2: Let us now fit model: Indeed, model fitted. Let us now quickly look likelihoods fitted models. begin creating list fitted models: Now, likelihoods:","code":"fit_alpha1 <- graph_lme(y ~ 1, graph=pems_graph,              model = list(type = \"WhittleMatern\", alpha = 1)) summary(fit_alpha1) #>  #> Latent model - Whittle-Matern with alpha = 1 #>  #> Call: #> graph_lme(formula = y ~ 1, graph = pems_graph, model = list(type = \"WhittleMatern\",  #>     alpha = 1)) #>  #> Fixed effects: #>             Estimate Std.error z-value Pr(>|z|)     #> (Intercept)   51.205     4.114   12.45   <2e-16 *** #>  #> Random effects: #>       Estimate Std.error z-value #> tau   0.104439  0.007826  13.345 #> kappa 0.108664  0.049911   2.177 #>  #> Random effects (Matern parameterization): #>       Estimate Std.error z-value #> sigma   20.539     4.358   4.713 #> range   18.405     8.438   2.181 #>  #> Measurement error: #>          Estimate Std.error z-value #> std. dev   6.8629    0.4084   16.81 #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  #>  #> Log-Likelihood:  -1221.225  #> Number of function calls by 'optim' = 28 #> Optimization method used in 'optim' = L-BFGS-B #>  #> Time used to:     fit the model =  30.31632 secs fit_alpha2 <- graph_lme(y ~ 1, graph=pems_graph,              model = list(type = \"WhittleMatern\", alpha = 2)) summary(fit_alpha2) #>  #> Latent model - Whittle-Matern with alpha = 2 #>  #> Call: #> graph_lme(formula = y ~ 1, graph = pems_graph, model = list(type = \"WhittleMatern\",  #>     alpha = 2)) #>  #> Fixed effects: #>             Estimate Std.error z-value Pr(>|z|)     #> (Intercept)   51.164     2.797   18.29   <2e-16 *** #>  #> Random effects: #>       Estimate Std.error z-value #> tau    0.08662   0.01553   5.579 #> kappa  0.44612   0.07523   5.930 #>  #> Random effects (Matern parameterization): #>       Estimate Std.error z-value #> sigma   19.372     2.532   7.651 #> range    7.765     1.281   6.063 #>  #> Measurement error: #>          Estimate Std.error z-value #> std. dev   7.2348    0.3721   19.44 #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  #>  #> Log-Likelihood:  -1207.996  #> Number of function calls by 'optim' = 29 #> Optimization method used in 'optim' = L-BFGS-B #>  #> Time used to:     fit the model =  46.87848 secs fit_alpha1_bc <- graph_lme(y ~ 1, graph=pems_graph, BC = 1,         model = list(type = \"WhittleMatern\", alpha = 1))  fit_alpha2_bc <- graph_lme(y ~ 1, graph=pems_graph, BC = 1,         model = list(type = \"WhittleMatern\", alpha = 2)) summary(fit_alpha1_bc) #>  #> Latent model - Whittle-Matern with alpha = 1 #>  #> Call: #> graph_lme(formula = y ~ 1, graph = pems_graph, model = list(type = \"WhittleMatern\",  #>     alpha = 1), BC = 1) #>  #> Fixed effects: #>             Estimate Std.error z-value Pr(>|z|)     #> (Intercept)   51.157     4.289   11.93   <2e-16 *** #>  #> Random effects: #>       Estimate Std.error z-value #> tau   0.104589  0.007829   13.36 #> kappa 0.095231  0.051193    1.86 #>  #> Random effects (Matern parameterization): #>       Estimate Std.error z-value #> sigma   21.908     5.474   4.002 #> range   21.002    11.268   1.864 #>  #> Measurement error: #>          Estimate Std.error z-value #> std. dev   6.8638    0.4083   16.81 #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  #>  #> Log-Likelihood:  -1221.377  #> Number of function calls by 'optim' = 32 #> Optimization method used in 'optim' = L-BFGS-B #>  #> Time used to:     fit the model =  35.77071 secs summary(fit_alpha2_bc) #>  #> Latent model - Whittle-Matern with alpha = 2 #>  #> Call: #> graph_lme(formula = y ~ 1, graph = pems_graph, model = list(type = \"WhittleMatern\",  #>     alpha = 2), BC = 1) #>  #> Fixed effects: #>             Estimate Std.error z-value Pr(>|z|)     #> (Intercept)   51.119     2.822   18.11   <2e-16 *** #>  #> Random effects: #>       Estimate Std.error z-value #> tau    0.08749   0.01566   5.586 #> kappa  0.43350   0.07515   5.768 #>  #> Random effects (Matern parameterization): #>       Estimate Std.error z-value #> sigma   20.022     2.731   7.331 #> range    7.991     1.355   5.895 #>  #> Measurement error: #>          Estimate Std.error z-value #> std. dev   7.2342    0.3717   19.46 #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  #>  #> Log-Likelihood:  -1208.179  #> Number of function calls by 'optim' = 27 #> Optimization method used in 'optim' = L-BFGS-B #>  #> Time used to:     fit the model =  45.16083 secs fit_GL1 <- graph_lme(y ~ -1, graph=pems_graph,              model = list(type = \"graphLaplacian\", alpha = 1), optim_method = \"Nelder-Mead\") fit_GL1 <- graph_lme(y ~ 1, graph=pems_graph,              model = list(type = \"graphLaplacian\", alpha = 1), previous_fit = fit_GL1) fit_GL2 <- graph_lme(y ~ 1, graph=pems_graph,             model = list(type = \"graphLaplacian\", alpha = 2), previous_fit = fit_GL1) summary(fit_GL1) #>  #> Latent model - graph Laplacian SPDE with alpha = 1 #>  #> Call: #> graph_lme(formula = y ~ 1, graph = pems_graph, model = list(type = \"graphLaplacian\",  #>     alpha = 1), previous_fit = fit_GL1) #>  #> Fixed effects: #>             Estimate Std.error z-value Pr(>|z|)     #> (Intercept)   50.849     4.307   11.81   <2e-16 *** #>  #> Random effects: #>       Estimate Std.error z-value #> tau   0.104550  0.007851  13.317 #> kappa 0.070245  0.033196   2.116 #>  #> Random effects (Matern parameterization): #>       Estimate Std.error z-value #> sigma    25.52      5.57   4.581 #> range    28.47     13.43   2.120 #>  #> Measurement error: #>          Estimate Std.error z-value #> std. dev   6.8650    0.4085   16.81 #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  #>  #> Log-Likelihood:  -1221.383  #> Number of function calls by 'optim' = 23 #> Optimization method used in 'optim' = L-BFGS-B #>  #> Time used to:     fit the model =  1.47831 secs summary(fit_GL2) #>  #> Latent model - graph Laplacian SPDE with alpha = 2 #>  #> Call: #> graph_lme(formula = y ~ 1, graph = pems_graph, model = list(type = \"graphLaplacian\",  #>     alpha = 2), previous_fit = fit_GL1) #>  #> Fixed effects: #>             Estimate Std.error z-value Pr(>|z|)     #> (Intercept)   50.849     2.867   17.73   <2e-16 *** #>  #> Random effects: #>       Estimate Std.error z-value #> tau    0.14862   0.02540   5.851 #> kappa  0.27395   0.04623   5.926 #>  #> Random effects (Matern parameterization): #>       Estimate Std.error z-value #> sigma   23.463     3.220   7.287 #> range   12.645     2.062   6.131 #>  #> Measurement error: #>          Estimate Std.error z-value #> std. dev   7.1252    0.3852    18.5 #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  #>  #> Log-Likelihood:  -1208.703  #> Number of function calls by 'optim' = 20 #> Optimization method used in 'optim' = L-BFGS-B #>  #> Time used to:     fit the model =  1.56645 secs fit_isoexp <- graph_lme(y ~ 1, graph=pems_graph,                  model = list(type = \"isoCov\")) #> Warning in graph_lme(y ~ 1, graph = pems_graph, model = list(type = \"isoCov\")): #> No check for Euclidean edges have been perfomed on this graph. The isotropic #> covariance models are only known to work for graphs with Euclidean edges. You #> can check if the graph has Euclidean edges by running the `check_euclidean()` #> method. See the vignette #> https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html #> for further details. summary(fit_isoexp) #>  #> Latent model - Covariance-based model #>  #> Call: #> graph_lme(formula = y ~ 1, graph = pems_graph, model = list(type = \"isoCov\")) #>  #> Fixed effects: #>             Estimate Std.error z-value Pr(>|z|) #> (Intercept)    33.18     24.37   1.362    0.173 #>  #> Random effects: #>       Estimate Std.error z-value #> tau   31.38005  16.51650    1.90 #> kappa  0.04565   0.05018    0.91 #>  #> Measurement error: #>          Estimate Std.error z-value #> std. dev   6.8742    0.4088   16.82 #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  #>  #> Log-Likelihood:  -1223.688  #> Number of function calls by 'optim' = 35 #> Optimization method used in 'optim' = L-BFGS-B #>  #> Time used to:     fit the model =  6.42512 secs pems_graph$check_euclidean() summary(pems_graph) #> A metric graph object with: #>  #> Vertices: #>   Total: 691  #>   Degree 1: 11;  Degree 2: 360;  Degree 3: 315;  Degree 4: 5;  #>   With incompatible directions:  17  #>  #> Edges:  #>   Total: 848  #>   Lengths:  #>       Min: 0.005073271  ; Max: 3.281839  ; Total: 470.7559  #>   Weights:  #>       Min: 1  ; Max: 1  #>   That are circles:  0  #>  #> Graph units:  #>   Vertices unit:  degrees  ; Lengths unit:  km  #>  #> Longitude and Latitude coordinates:  TRUE #>   Which spatial package:  sp  #>   CRS:  +proj=longlat +datum=WGS84 +no_defs #>  #> Some characteristics of the graph: #>   Connected: TRUE #>   Has loops: FALSE #>   Has multiple edges: TRUE #>   Is a tree: FALSE #>   Distance consistent: FALSE #>   Has Euclidean edges: FALSE #>  #> Computed quantities inside the graph:  #>   Laplacian:  FALSE  ; Geodesic distances:  TRUE  #>   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  #>  #> Mesh: The graph has no mesh!  #>  #> Data:  #>   Columns:  y  #>   Groups:  None  #>  #> Tolerances:  #>   vertex-vertex:  0.001  #>   vertex-edge:  0.001  #>   edge-edge:  0 fit_isoexp$euclidean #> [1] FALSE cov_mat <- function(h,theta){   tau <- theta[1]   kappa <- theta[2]   1/tau * (1 + kappa * abs(h)) * exp(- kappa * abs(h)) } fit_isomat <- graph_lme(y ~ 1, graph = pems_graph,                  model = list(type = \"isoCov\", cov_function = cov_mat),                  model_options = list(start_par_vec = fit_alpha2$coeff$random_effects)) #> Warning in graph_lme(y ~ 1, graph = pems_graph, model = list(type = \"isoCov\", : #> This graph DOES NOT have Euclidean edges. The isotropic covariance models are #> NOT guaranteed to work for this graph! See the vignette #> https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html #> for further details. #> Warning in graph_lme(y ~ 1, graph = pems_graph, model = list(type = \"isoCov\", : #> All optimization methods failed to provide a positive-definite Hessian. The #> optimization method with largest likelihood was chosen. You can try to obtain a #> positive-definite Hessian by setting 'improve_hessian' to TRUE. #> Error in chol.default(Sigma_non_na): the leading minor of order 258 is not positive fitted_models_list <- list(\"isoExp\" = fit_isoexp,                              \"GL1\" = fit_GL1,                             \"alpha=1\" = fit_alpha1,                              \"alpha=1 bc\" = fit_alpha1_bc,                             \"GL2\" = fit_GL2,                             \"alpha=2\" = fit_alpha2,                              \"alpha=2 bc\" = fit_alpha2_bc) table_lik <- sapply(fitted_models_list, logLik)  # Printing the negative likelihoods: -table_lik #>     isoExp        GL1    alpha=1 alpha=1 bc        GL2    alpha=2 alpha=2 bc  #>   1223.688   1221.383   1221.225   1221.377   1208.703   1207.996   1208.179"},{"path":"https://davidbolin.github.io/MetricGraph/articles/comparison.html","id":"comparison-by-cross-validation","dir":"Articles","previous_headings":"","what":"Comparison by cross-validation","title":"Comparison of different models using real data","text":"now use function posterior_crossvalidation() perform leave-one-cross validation based estimated parameters compare results:","code":"res <- posterior_crossvalidation(fitted_models_list, tibble=FALSE) res$scores #>            logscore     crps    scrps      mae     rmse #> isoExp     3.603170 4.733602 2.132627 6.177213 8.606109 #> GL1        3.604522 4.737170 2.133212 6.174884 8.610858 #> alpha=1    3.604623 4.737561 2.133209 6.177527 8.613469 #> alpha=1 bc 3.604420 4.736101 2.133070 6.167904 8.611471 #> GL2        3.551302 4.530791 2.106780 5.852531 8.303655 #> alpha=2    3.549369 4.521774 2.106920 5.840258 8.255849 #> alpha=2 bc 3.548986 4.520620 2.106719 5.842492 8.254993"},{"path":"https://davidbolin.github.io/MetricGraph/articles/comparison.html","id":"kriging","dir":"Articles","previous_headings":"","what":"Kriging","title":"Comparison of different models using real data","text":"now perform kriging different fitted models. Observe Matérn Gaussian model based graph Laplacian Gaussian model isotropic exponential covariance function, actually modify model predictions. See isotropic covariances metric graphs non-Euclidean edges vignette details. Therefore, even though able obtain ``predictions’’ using Matérn Gaussian models based graph Laplacian Gaussian models istropic exponential covariance function, inconsistencies model used fit data, model used obtain predictions. inconsistency present Whittle-Matérn models metric graphs. Let us begin building mesh metric graph create data.frame() mesh locations: region large, select two smaller subregions ``zoom ’’, can see predictions details. Let us create variables containing coordinates regions: Now, second region: can now obtain predictions. use augment() method obtain predictions. start obtaining predictions Whittle-Matérn models alpha=1: boundary correction: Let plot predictions corresponding observed values. First model without boundary correction. predictions obtained mesh nodes, can supply fitted values X argument plot_function() method: can now add original observations obtain plot region 1:  Now region 2:  Similarly, alpha=1 boundary correction region 1:  region 2:  Now, Whittle-Matérn models alpha=2: Let us now build plot region 1:  region 2:  Now boundary correction: plot region 1:  region 2:  now move models based graph Laplacian: plot region 1:  region 2:  alpha=2: plot region 1:  region 2:  Finally, models isotropic exponential covariance: corresponding plot region 1:  region 2:","code":"pems_graph$build_mesh(h = 0.1)  df_pred <- data.frame(edge_number = pems_graph$mesh$PtE[,1],                         distance_on_edge = pems_graph$mesh$PtE[,2]) coordx_lwr1 <- -121.905 coordx_upr1 <- -121.875 coordy_lwr1 <- 37.316 coordy_upr1 <- 37.328 coordx_lwr2<- -121.94 coordx_upr2 <- -121.88 coordy_lwr2 <- 37.35 coordy_upr2 <- 37.38 pred_alpha1 <- augment(fit_alpha1, newdata = df_pred,                         normalized = TRUE) pred_alpha1_bc <- augment(fit_alpha1_bc, newdata = df_pred,                         normalized = TRUE) library(ggplot2)  p <- pems_graph$plot_function(newdata = pred_alpha1, data = \".fitted\",                 improve_plot=TRUE, vertex_size = 0,                 edge_width = 0.5) pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr1, coordx_upr1) +                      ylim(coordy_lwr1, coordy_upr1) pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr2, coordx_upr2) +                      ylim(coordy_lwr2, coordy_upr2) p <- pems_graph$plot_function(newdata = pred_alpha1_bc, data = \".fitted\",               improve_plot=TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr1, coordx_upr1) +                      ylim(coordy_lwr1, coordy_upr1) p <- pems_graph$plot_function(newdata = pred_alpha1_bc, data = \".fitted\",               improve_plot=TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr2, coordx_upr2) +                      ylim(coordy_lwr2, coordy_upr2) pred_alpha2 <- augment(fit_alpha2, newdata = df_pred,                         normalized = TRUE) p <- pems_graph$plot_function(newdata = pred_alpha2, data = \".fitted\",                     improve_plot=TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr1, coordx_upr1) +                      ylim(coordy_lwr1, coordy_upr1) p <- pems_graph$plot_function(newdata = pred_alpha2, data = \".fitted\",                     improve_plot=TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr2, coordx_upr2) +                      ylim(coordy_lwr2, coordy_upr2) pred_alpha2_bc <- augment(fit_alpha2_bc, newdata = df_pred,                         normalized = TRUE) p <- pems_graph$plot_function(newdata = pred_alpha2_bc, data = \".fitted\",                     improve_plot=TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr1, coordx_upr1) +                      ylim(coordy_lwr1, coordy_upr1) p <- pems_graph$plot_function(newdata = pred_alpha2_bc, data = \".fitted\",                     improve_plot=TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr2, coordx_upr2) +                      ylim(coordy_lwr2, coordy_upr2) pred_GL1 <- augment(fit_GL1, newdata = df_pred,                         normalized = TRUE) p <- pems_graph$plot_function(newdata = pred_GL1, data = \".fitted\",                      improve_plot = TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr1, coordx_upr1) +                      ylim(coordy_lwr1, coordy_upr1) p <- pems_graph$plot_function(newdata = pred_GL1, data = \".fitted\",                      improve_plot = TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr2, coordx_upr2) +                      ylim(coordy_lwr2, coordy_upr2) pred_GL2 <- augment(fit_GL2, newdata = df_pred,                         normalized = TRUE) p <- pems_graph$plot_function(newdata = pred_GL2, data = \".fitted\",                      improve_plot = TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr1, coordx_upr1) +                      ylim(coordy_lwr1, coordy_upr1) p <- pems_graph$plot_function(newdata = pred_GL2, data = \".fitted\",                      improve_plot = TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr2, coordx_upr2) +                      ylim(coordy_lwr2, coordy_upr2) pred_isoexp <- augment(fit_isoexp, newdata = df_pred,                         normalized = TRUE) p <- pems_graph$plot_function(newdata = pred_isoexp, data = \".fitted\",                      improve_plot = TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr1, coordx_upr1) +                      ylim(coordy_lwr1, coordy_upr1) p <- pems_graph$plot_function(newdata = pred_isoexp, data = \".fitted\",                      improve_plot = TRUE, vertex_size = 0,                     edge_width = 0.5)  pems_graph$plot(data = \"y\", vertex_size = 0, data_size = 2,                      edge_width = 0, p = p) +                      xlim(coordx_lwr2, coordx_upr2) +                      ylim(coordy_lwr2, coordy_upr2)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/comparison.html","id":"a-quick-diagnostic-analysis","dir":"Articles","previous_headings":"","what":"A quick diagnostic analysis","title":"Comparison of different models using real data","text":"cross-validation suggests best model respect RMSE, MAE, CRPS log-score Whittle-Matérn field alpha=2 boundary corrections. Let residual given \\[e_i = y_i - \\mu - E(u(s_i)|y_1,\\ldots,y_n), \\quad =1,\\ldots, n.\\] consider standardized version residual normalize divinding standard deviation. standardized residuals given using augment function argument se_fit set TRUE. Let us now compute residuals, simple QQ plot . Now let us build QQ-plot theoretical quantiles standard Gaussian distribution:  now parametric bootstrap procedure obtain confidence bands (simulated envelopes) QQ plot. consider \\(B=100\\) bootstrap samples. start generating \\(B\\) samples. can done using simulate() method: reduce computational cost, fix latent parameters original fitted values, can done passing fitted model previous_fit argument, setting fix_coeff TRUE. compute new standardized residuals based new samples: now create lower upper bands 95% confidence, well plot median line. extracting lower, upper median values. Let us now produce QQ plot confidence bands median line. start obtaining quantile values, add bands data.frame:  observing QQ plot confidence bands, can see Gaussianity assumption reasonable; however, fit can likely improved considering non-stationary Gaussian models latent fields. However, goal vignette, comparing exact models. package implementation nonstationary Gaussian models using finite element approximations.","code":"fitted_aug <- augment(fit_alpha2_bc, se_fit = TRUE) library(ggplot2) p <- fitted_aug %>% ggplot(aes(sample = .std_resid)) +           stat_qq() p B <- 100 samples_alpha2_bc <- simulate(fit_alpha2_bc, nsim = B) simul_std_resid <- matrix(nrow = nrow(fitted_aug), ncol = B) # We clone the graph to add new data pems_graph_new <- pems_graph$clone() for(i in 1:B){   # We get the simulated response. Since we do not have replicates,    # all of them are in the first element of the list.   y_tmp <- samples_alpha2_bc$samples[[1]][,i]   # Add new observations   pems_graph_new$add_observations(data = pems_graph$mutate(y = y_tmp),                                    clear_obs = TRUE, verbose = 0)   new_fit <- graph_lme(y ~ 1, graph=pems_graph_new, BC = 1,                                  previous_fit = fit_alpha2_bc,                                 model = list(type = \"WhittleMatern\", alpha = 2),                                 fix_coeff = TRUE)   new_fitted_aug <-  augment(new_fit, se_fit = TRUE)           simul_std_resid[,i] <- new_fitted_aug[[\".std_resid\"]]             } prob <- 0.95   simul_std_resid <- t(simul_std_resid)   simul_std_resid <- t(apply(simul_std_resid, 1, sort))   simul_std_resid <- apply(simul_std_resid, 2, sort)   id1 <- max(1, round(B * (1 - prob) / 2))   id2 <- round(B * (1 + prob) / 2)   bands <- rbind(simul_std_resid[id2, ], apply(simul_std_resid, 2, stats::median), simul_std_resid[id1, ])   bands <- as.data.frame(t(bands))   colnames(bands) <- c(\"upper\", \"median\", \"lower\") tmp_quantiles <- qqnorm(fitted_aug[[\".std_resid\"]]) bands[[\"x\"]] <- sort(tmp_quantiles$x) bands[[\"y\"]] <- sort(tmp_quantiles$y) p <- bands %>% ggplot(aes(x = x, y = y)) + geom_point() +         geom_ribbon(aes(x = x, ymin = lower, ymax = upper), alpha = 0.2) +         geom_path(aes(x=x, y = median), linetype = 2) +          labs(x = \"Theoretical Quantiles\", y = \"Sample Quantiles\") p"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Whittle--Matérn fields with general smoothness","text":"vignette introduce fit Whittle–Matérn fields general smoothness based finite element rational approximations. theory approach provided Bolin et al. (2023) Bolin, Simas, Xiong (2023). implementation, make use rSPDE package rational approximations. models thus implemented using finite element approximations. approximations needed integer smoothness parameters, details exact models refer vignettes Whittle–Matérn fields metric graphs INLA inlabru interfaces details construction metric graphs, see Working metric graphs details data manipulation metric graphs, see Data manipulation metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"constructing-the-graph-and-the-mesh","dir":"Articles","previous_headings":"","what":"Constructing the graph and the mesh","title":"Whittle--Matérn fields with general smoothness","text":"begin loading rSPDE MetricGraph packages: example, consider following metric graph  construct FEM approximation Whittle–Matérn field general smoothness, must first construct mesh graph.  command build_mesh, argument h decides largest spacing nodes mesh. can seen plot, mesh coarse, let’s reduce value h rebuild mesh: now ready specify model \\[ (\\kappa^2 - \\Delta)^{\\alpha/2} \\tau u = \\mathcal{W} \\] Whittle–Matérn field \\(u\\). , use matern.operators function rSPDE package: can seen code, specify \\(\\kappa\\) via practical correlation range \\(\\sqrt{8\\nu}/\\kappa\\). Also, model parametrized \\(\\tau, \\alpha\\) instead \\(\\sigma, \\nu\\). , sigma denotes standard deviation field nu smoothness parameter, related \\(\\alpha\\) via relation \\(\\alpha = \\nu + 1/2\\). object op contains matrices needed evaluating distribution stochastic weights FEM approximation. Let us simulate field \\(u\\) mesh locations plot result: want evaluate \\(u(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights FEM basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\), elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. can done function fem_basis metric graph object. illustrate , let us simulate observation locations graph construct matrix: code, generate \\(100\\) observation locations per edge graph, drawn random. can noted assume observation locations given format \\((e, d)\\) \\(e\\) denotes edge observation \\(d\\) position edge, .e., relative distance first vertex edge. compute precision matrix covariance-based rational approximation one can use precision() method object returned matern.operators() function: illustration model, let us compute covariance function process \\(s=(2,0.1)\\), , point edge 2 distance edge 0.1, mesh points. end, can use helper function cov_function_mesh contained op object:","code":"library(rSPDE)   library(MetricGraph) edge1 <- rbind(c(0,0),c(1,0))   edge2 <- rbind(c(0,0),c(0,1))   edge3 <- rbind(c(0,1),c(-1,1))   theta <- seq(from=pi,to=3*pi/2,length.out = 20)   edge4 <- cbind(sin(theta),1+ cos(theta))   edges = list(edge1, edge2, edge3, edge4)   graph <- metric_graph$new(edges = edges)   graph$plot() graph$build_mesh(h = 0.5)   graph$plot(mesh=TRUE) graph$build_mesh(h = 0.01) sigma <- 1.3   range <- 0.15   nu <- 0.8     rspde.order <- 2   op <- matern.operators(nu = nu, range = range, sigma = sigma,                           parameterization = \"matern\",                          m = rspde.order, graph = graph) u <- simulate(op) graph$plot_function(X = u, plotly = TRUE) obs.per.edge <- 100 obs.loc <- NULL for(i in 1:graph$nE) {   obs.loc <- rbind(obs.loc,                    cbind(rep(i,obs.per.edge), runif(obs.per.edge))) } n.obs <- obs.per.edge*graph$nE A <- graph$fem_basis(obs.loc) Q <- precision(op) c_cov <- op$cov_function_mesh(matrix(c(2,0.1),1,2))   graph$plot_function(c_cov, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-the-model-for-inference","dir":"Articles","previous_headings":"","what":"Using the model for inference","title":"Whittle--Matérn fields with general smoothness","text":"built-support computing log-likelihood functions performing kriging prediction rSPDE package can use graph model. illustrate , use simulation create noisy observations process. generate observations \\(Y_i = 1 + 2x_{i1} - 3 x_{i2} + u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise, \\(x_1\\) \\(x_2\\) covariates generated relative positions observations graph. Let us now fit model. end use graph_lme() function (, finite element models, acts wrapper rspde_lme() function rSPDE package). end, let us now assemble data.frame() observations, observation locations covariates: Let us now add data graph object plot :  can now fit model. end, use graph_lme() function set model 'WM’. Let us obtain summary model: can also obtain additional information using function glance(): Let us compare values parameters latent model true ones:","code":"sigma.e <- 0.1      x1 <- obs.loc[,1]     x2 <- obs.loc[,2]      Y <- 1 + 2*x1 - 3*x2 + as.vector(A %*% u + sigma.e * rnorm(n.obs)) df_data <- data.frame(y = Y, edge_number = obs.loc[,1],                         distance_on_edge = obs.loc[,2],                         x1 = x1, x2 = x2) graph$add_observations(data = df_data, normalized = TRUE) ## Adding observations... graph$plot(data = \"y\") fit <- graph_lme(y ~ x1 + x2, graph = graph, model = \"WM\") summary(fit) ##  ## Latent model - Whittle-Matern ##  ## Call: ## graph_lme(formula = y ~ x1 + x2, graph = graph, model = \"WM\") ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)   0.4563    0.7173   0.636  0.52472     ## x1            2.1100    0.2012  10.485  < 2e-16 *** ## x2           -2.3886    0.7174  -3.330  0.00087 *** ##  ## Random effects: ##        Estimate Std.error z-value ## alpha  1.259264  0.022792  55.251 ## tau    0.056383  0.005978   9.432 ## kappa 15.737382  2.455055   6.410 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## nu     0.75926   0.02279  33.313 ## sigma  1.34595   0.13555   9.929 ## range  0.15661   0.02327   6.730 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev 0.097303  0.006313   15.41 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -126.9802  ## Number of function calls by 'optim' = 156 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  28.87483 secs glance(fit) ## # A tibble: 1 × 9 ##    nobs  sigma logLik   AIC   BIC deviance df.residual model               alpha ##   <int>  <dbl>  <dbl> <dbl> <dbl>    <dbl>       <dbl> <chr>               <dbl> ## 1   400 0.0973  -127.  268.  296.     254.         393 Covariance-Based M…  1.26 print(data.frame(sigma = c(sigma, fit$matern_coeff$random_effects[2]),                     range = c(range, fit$matern_coeff$random_effects[3]),                    nu = c(nu, fit$matern_coeff$random_effects[1]),                    row.names = c(\"Truth\", \"Estimates\"))) ##              sigma     range        nu ## Truth     1.300000 0.1500000 0.8000000 ## Estimates 1.345954 0.1566062 0.7592644"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"kriging","dir":"Articles","previous_headings":"Using the model for inference","what":"Kriging","title":"Whittle--Matérn fields with general smoothness","text":"Given estimated parameters, let us compute kriging predictor field given observations mesh nodes. perform kriging predict() method. end, need provide data.frame containing prediction locations, well values covariates prediction locations. estimate shown following figure  can also use augment() function easily plot predictions. Let us build 3d plot now add observed values top predictions:","code":"df_pred <- data.frame(edge_number = graph$mesh$VtE[,1],                         distance_on_edge = graph$mesh$VtE[,2],                         x1 = graph$mesh$VtE[,1],                         x2 = graph$mesh$VtE[,2])    u.krig <- predict(fit, newdata = df_pred, normalized = TRUE) graph$plot_function(as.vector(u.krig$mean)) p <- augment(fit, newdata = df_pred, normalized = TRUE) %>%            graph$plot_function(data = \".fitted\", plotly = TRUE)  graph$plot(data = \"y\", p = p, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"fitting-a-model-with-replicates","dir":"Articles","previous_headings":"","what":"Fitting a model with replicates","title":"Whittle--Matérn fields with general smoothness","text":"Let us now illustrate simulate data set replicates fit model data. simulate latent model replicates, set nsim argument number replicates. Now, let us generate observed values \\(Y\\): Note \\(Y\\) matrix 20 columns, column containing one replicate. need turn y vector create auxiliary vector repl indexing replicates y: Let us clear previous observations add new data graph: can now fit model way using rspde_lme() function. Note can optimize parallel setting parallel TRUE. specify replicate consider, which_repl argument, replicates considered. Observe received warning saying Hessian positive-definite, ended creating NaNs standard errors. Indeed, let us see summary fit: Let us, , follow suggestion warning refit model setting improve_hessian TRUE. obtain precise estimate Hessian, can possibly fix issue: see receive warning now, Std. errors computed accordingly: Let us also take glance fit: Let us compare values parameters latent model true ones: Let us kriging. use prediction locations previous example. Let us get prediction replicate 10, add original observations top :","code":"n.rep <- 30   u.rep <- simulate(op, nsim = n.rep) sigma.e <- 0.3   Y.rep <- A %*% u.rep + sigma.e * matrix(rnorm(n.obs * n.rep), ncol = n.rep) y_vec <- as.vector(Y.rep) repl <- rep(1:n.rep, each = n.obs)                         df_data_repl <- data.frame(y = y_vec,                               edge_number = rep(obs.loc[,1], n.rep),                               distance_on_edge = rep(obs.loc[,2], n.rep),                                repl = repl) graph$add_observations(data = df_data_repl, normalized = TRUE,                              group = \"repl\", clear_obs = TRUE) ## Adding observations... fit_repl <- graph_lme(y ~ -1, graph = graph, model = \"WM\", parallel = TRUE) summary(fit_repl) ##  ## Latent model - Whittle-Matern ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = \"WM\", parallel = TRUE) ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## alpha   1.2787       NaN     NaN ## tau     0.0548       NaN     NaN ## kappa  15.3935    0.4347   35.41 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## nu    0.778739       NaN     NaN ## sigma 1.324550  0.025395   52.16 ## range 0.162145  0.004925   32.92 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev 0.300945  0.002943   102.2 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -9741.751  ## Number of function calls by 'optim' = 62 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  35.55593 secs  ##   set up the parallelization = 2.8182 secs fit_repl <- graph_lme(y ~ -1, graph = graph, model = \"WM\",                        parallel = TRUE, improve_hessian = TRUE) summary(fit_repl) ##  ## Latent model - Whittle-Matern ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = \"WM\", parallel = TRUE,  ##     improve_hessian = TRUE) ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## alpha  1.27874   0.16963   7.538 ## tau    0.05480   0.04066   1.348 ## kappa 15.39349   4.32698   3.558 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## nu    0.778739  0.169628   4.591 ## sigma 1.324550  0.025395  52.157 ## range 0.162145  0.004925  32.924 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev 0.300945  0.006309    47.7 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -9741.751  ## Number of function calls by 'optim' = 62 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  31.21826 secs  ##   compute the Hessian = 9.92615 secs  ##   set up the parallelization = 2.86512 secs glance(fit_repl) ## # A tibble: 1 × 9 ##    nobs sigma logLik    AIC    BIC deviance df.residual model              alpha ##   <int> <dbl>  <dbl>  <dbl>  <dbl>    <dbl>       <dbl> <chr>              <dbl> ## 1 12000 0.301 -9742. 19492. 19521.   19484.       11996 Covariance-Based …  1.28 print(data.frame(sigma = c(sigma, fit_repl$matern_coeff$random_effects[2]),                     range = c(range, fit_repl$matern_coeff$random_effects[3]),                    nu = c(nu, fit_repl$matern_coeff$random_effects[1]),                    row.names = c(\"Truth\", \"Estimates\"))) ##             sigma     range        nu ## Truth     1.30000 0.1500000 0.8000000 ## Estimates 1.32455 0.1621451 0.7787391 p <- augment(fit_repl, which_repl = 10, newdata = df_pred, normalized = TRUE) %>%            graph$plot_function(data = \".fitted\", plotly = TRUE)  graph$plot(data = \"y\", group = 10, plotly = TRUE, p = p)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-the-r-inla-implementation","dir":"Articles","previous_headings":"","what":"Using the R-INLA implementation","title":"Whittle--Matérn fields with general smoothness","text":"also R-INLA implementation rational SPDE approach metric graphs. begin defining model using rspde.metric_graph() function. function contains arguments function rspde.matern(). refer reader R-INLA implementation rational SPDE approach vignette details. begin clearing previous observations adding observations (case without replicates) graph: Let us create model object: default, order rational approximation 2. can now create auxiliary quantities needed graph_data_rspde() function: remaining standard: create formula object, stack object, fit model using inla() function. , first create formula object: Now create inla.stack object. end, observe data_rspde contains dataset data component, index index component -called matrix basis component. now create stack using components: Finally, can fit model: can use functions rspde fitted models inla. instance, can see results original scale creating result object: Let us compare true values: can also plot posterior marginal densities help gg_df() function:","code":"graph$clear_observations() graph$add_observations(data = df_data, normalized = TRUE) ## Adding observations... library(INLA)   rspde_model <- rspde.metric_graph(graph) data_rspde <- graph_data_rspde(rspde_model, name = \"field\") f.s <- y ~ -1 + Intercept + x1 + x2 + f(field, model = rspde_model) stk.dat <- inla.stack(     data = data_rspde[[\"data\"]][\"y\"], A = list(data_rspde[[\"basis\"]],1), tag = \"est\",     effects =       list(c(         data_rspde[[\"index\"]],         list(Intercept = 1)), list(x1 = data_rspde[[\"data\"]][\"x1\"] ,                                       x2 = data_rspde[[\"data\"]][\"x2\"])       )     ) rspde_fit <- inla(f.s, data = inla.stack.data(stk.dat),     control.inla = list(int.strategy = \"eb\"),     control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE)   ) result_fit <- rspde.result(rspde_fit, \"field\", rspde_model)   summary(result_fit) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.429730 0.1662580   1.131730 1.419830   1.783990 1.400450 ## range   0.172464 0.0428246   0.102324 0.167847   0.269643 0.158898 ## nu      0.764311 0.1105860   0.560284 0.759707   0.992634 0.747786 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_fit$summary.std.dev$mean,       result_fit$summary.range$mean,       result_fit$summary.nu$mean     ),     mode = c(       result_fit$summary.std.dev$mode,       result_fit$summary.range$mode,       result_fit$summary.nu$mode     )   )   print(result_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.4297290 1.4004536 ## 2     range 0.15 0.1724636 0.1588976 ## 3        nu 0.80 0.7643108 0.7477859 posterior_df_fit <- gg_df(result_fit)    library(ggplot2)    ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"kriging-with-the-r-inla-implementation","dir":"Articles","previous_headings":"Using the R-INLA implementation","what":"Kriging with the R-INLA implementation","title":"Whittle--Matérn fields with general smoothness","text":"kriging mesh locations: Let us now add observations prediction: Let us now create new model , , compute auxiliary components prediction locations. end, set argument only_pred TRUE, return data.frame containing NA data. Let us build prediction stack using components data_rspde_prd gather estimation stack. Let us obtain predictions: Let us now extract indices predicted nodes store means: Finally, let us plot predicted values. end use plot_function() graph method.","code":"pred_loc <- graph$mesh$VtE graph$add_observations(data = data.frame(y=rep(NA,nrow(pred_loc)),                                  x1 = graph$mesh$VtE[,1],                                 x2 = graph$mesh$VtE[,2],                                 edge_number = pred_loc[,1],                                  distance_on_edge = pred_loc[,2]),                                  normalized = TRUE) ## Adding observations... rspde_model_prd <- rspde.metric_graph(graph)    data_rspde_prd <- graph_data_rspde(rspde_model_prd, only_pred = TRUE) ef.prd <-      list(c(data_rspde_prd[[\"index\"]], list(Intercept = 1)),            list(x1 = data_rspde_prd[[\"data\"]][[\"x1\"]],                 x2 = data_rspde_prd[[\"data\"]][[\"x2\"]]))   stk.prd <- inla.stack(     data = data.frame(y = data_rspde_prd[[\"data\"]][[\"y\"]]),     A = list(data_rspde_prd[[\"basis\"]],1), tag = \"prd\",     effects = ef.prd   )   stk.all <- inla.stack(stk.dat, stk.prd) rspde_fitprd <- inla(f.s,   data = inla.stack.data(stk.all),   control.predictor = list(     A = inla.stack.A(stk.all),     compute = TRUE, link = 1   ),   control.compute = list(     return.marginals = FALSE,     return.marginals.predictor = FALSE   ),   control.inla = list(int.strategy = \"eb\") ) id.prd <- inla.stack.index(stk.all, \"prd\")$data m.prd <- rspde_fitprd$summary.fitted.values$mean[id.prd] graph$plot_function(m.prd, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-r-inla-implementation-to-fit-models-with-replicates","dir":"Articles","previous_headings":"","what":"Using R-INLA implementation to fit models with replicates","title":"Whittle--Matérn fields with general smoothness","text":"Let us begin cloning graph clearing observations cloned graph: now add data replicates graph: Let us create new rspde model object: fit model replicates need create auxiliary quantities graph_data_rspde() function, set repl argument function graph_data_spde .since want use replicates: Let us now create corresponding inla.stack object: Observe need response variable y vector. can now create formula object, remembering since gave name argument field, creating index, need pass field.repl formula: can, finally, fit model: can obtain estimates original scale rspde.result() function: Let us compare true values parameters: can also plot posterior marginal densities help gg_df() function:","code":"graph_rep <- graph$clone() graph_rep$clear_observations() graph_rep$add_observations(data = data.frame(y=as.vector(Y.rep),                            edge_number = rep(obs.loc[,1], n.rep),                            distance_on_edge = rep(obs.loc[,2], n.rep),                           repl = rep(1:n.rep, each = n.obs)),                            group = \"repl\",                           normalized = TRUE) ## Adding observations... rspde_model_rep <- rspde.metric_graph(graph_rep) data_rspde_rep <- graph_data_rspde(rspde_model_rep, name = \"field\", repl = \".all\") st.dat.rep <- inla.stack(   data = data_rspde_rep[[\"data\"]],   A = data_rspde_rep[[\"basis\"]],   effects = data_rspde_rep[[\"index\"]] ) f.rep <-   y ~ -1 + f(field,     model = rspde_model_rep,     replicate = field.repl   ) rspde_fit_rep <-   inla(f.rep,     data = inla.stack.data(st.dat.rep),     family = \"gaussian\",     control.predictor =       list(A = inla.stack.A(st.dat.rep))   ) result_fit_rep <- rspde.result(rspde_fit_rep, \"field\", rspde_model_rep)   summary(result_fit_rep) ##             mean         sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.325060 0.02488670   1.276470 1.324990   1.374220 1.325080 ## range   0.161965 0.00720163   0.147072 0.162377   0.175118 0.163975 ## nu      0.783876 0.03459160   0.725593 0.780283   0.859818 0.768370 result_rep_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_fit_rep$summary.std.dev$mean,       result_fit_rep$summary.range$mean,       result_fit_rep$summary.nu$mean     ),     mode = c(       result_fit_rep$summary.std.dev$mode,       result_fit_rep$summary.range$mode,       result_fit_rep$summary.nu$mode     )   )   print(result_rep_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.3250615 1.3250797 ## 2     range 0.15 0.1619645 0.1639755 ## 3        nu 0.80 0.7838758 0.7683703 posterior_df_fit_rep <- gg_df(result_fit_rep)    ggplot(posterior_df_fit_rep) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-inlabru-implementation","dir":"Articles","previous_headings":"","what":"Using inlabru implementation","title":"Whittle--Matérn fields with general smoothness","text":"inlabru package allows us fit models kriging straighforward manner, without handle matrices, indices inla.stack objects. Therefore, suggest reader use implementation using implementation fit real data. Let us clear graph, since contains NA observations used prediction, add observations , create new rSPDE model object: Let us now load inlabru package create component (inlabru’s formula-like object). Since using data graph, inlabru also obtain locations graph, thus, need provide locations. However, need name locations using inlabru’s predict method. Therefore, can choose name location name used graph’s data. case use name loc: Let us now build auxiliary data used graph_data_rspde() function, pass name location variable formula loc_name argument, case \"loc\": Now, can directly fit model, using data element data_rspde_bru: Let us now obtain estimates parameters original scale using rspde.result() function: Let us compare true values parameters: can also plot posterior marginal densities help gg_df() function:","code":"graph$clear_observations() graph$add_observations(data = df_data,                            normalized = TRUE) ## Adding observations... rspde_model <- rspde.metric_graph(graph) library(inlabru)     cmp <-     y ~ -1 + Intercept(1) + x1 + x2 + field(loc,                            model = rspde_model) data_rspde_bru <- graph_data_rspde(rspde_model, loc_name = \"loc\") rspde_bru_fit <-     bru(cmp,         data=data_rspde_bru[[\"data\"]],       options=list(       family = \"gaussian\")     ) result_bru_fit <- rspde.result(rspde_bru_fit, \"field\", rspde_model)   summary(result_bru_fit) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.435770 0.1854500  1.1114900  1.42146   1.838510 1.389880 ## range   0.177120 0.0505328  0.0991482  0.16990   0.296383 0.155938 ## nu      0.757476 0.1168080  0.5383490  0.75432   0.994756 0.748065 result_bru_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_bru_fit$summary.std.dev$mean,       result_bru_fit$summary.range$mean,       result_bru_fit$summary.nu$mean     ),     mode = c(       result_bru_fit$summary.std.dev$mode,       result_bru_fit$summary.range$mode,       result_bru_fit$summary.nu$mode     )   )   print(result_bru_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.4357725 1.3898835 ## 2     range 0.15 0.1771196 0.1559381 ## 3        nu 0.80 0.7574758 0.7480654 posterior_df_bru_fit <- gg_df(result_bru_fit)    ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"kriging-with-the-inlabru-implementation","dir":"Articles","previous_headings":"Using inlabru implementation","what":"Kriging with the inlabru implementation","title":"Whittle--Matérn fields with general smoothness","text":"easy kriging inlabru implementation. simply need provide prediction locations predict() method. example use mesh locations. end use get_mesh_locations() method. also set bru=TRUE loc=\"loc\" obtain data list suitable used inlabru. Now, can simply provide locations predict method along fitted object rspde_bru_fit: Finally, let us plot predicted values. end use plot() method y_pred:  can also create 3d plot, together true data:","code":"data_prd_list <- graph$get_mesh_locations(bru = TRUE,                                             loc = \"loc\")   data_prd_list[[\"x1\"]] <- data_prd_list$loc[,1]   data_prd_list[[\"x2\"]] <- data_prd_list$loc[,2] y_pred <- predict(rspde_model, cmp, rspde_bru_fit, newdata=data_prd_list, ~Intercept + x1 + x2 + field) plot(y_pred) p <- graph$plot(data = \"y\", plotly=TRUE) plot(y_pred, plotly = TRUE, p = p)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"using-inlabru-to-fit-models-with-replicates","dir":"Articles","previous_headings":"","what":"Using inlabru to fit models with replicates","title":"Whittle--Matérn fields with general smoothness","text":"can also use inlabru implementation fit models replicates. consider data generated , number replicates 30. implementation use rspde_model_rep object. can now create component, passing vector indices replicates replicate argument. obtain auxiliary data, pass repl argument use function graph_data_rspde(), set ., since want replicates. , also pass loc_name argument. can now define bru component formula, passing repl replicate argument: Now, ready fit model: can obtain estimates original scale rspde.result() function: Let us compare true values parameters: can also plot posterior marginal densities help gg_df() function:  Let us now prediction observations replicate 10. start building data list prediction locations: Let us now obtain predictions replicate: can now plot predictions along observed values replicate 10:","code":"data_rspde_rep <- graph_data_rspde(rspde_model_rep, repl = \".all\", loc_name = \"loc\") cmp_rep <-     y ~ -1 + field(loc, model = rspde_model_rep,                               replicate = repl) rspde_bru_fit_rep <-     bru(cmp_rep,         data=data_rspde_rep[[\"data\"]],       options=list(       family = \"gaussian\")     ) result_bru_fit_rep <- rspde.result(rspde_bru_fit_rep, \"field\", rspde_model_rep)   summary(result_bru_fit_rep) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 1.324550 0.0251785   1.275160 1.324590   1.374040 1.325010 ## range   0.161892 0.0074412   0.146522 0.162312   0.175501 0.163953 ## nu      0.783286 0.0346391   0.724564 0.779799   0.859094 0.768199 result_bru_rep_df <- data.frame(     parameter = c(\"std.dev\", \"range\", \"nu\"),     true = c(sigma, range, nu),     mean = c(       result_bru_fit_rep$summary.std.dev$mean,       result_bru_fit_rep$summary.range$mean,       result_bru_fit_rep$summary.nu$mean     ),     mode = c(       result_bru_fit_rep$summary.std.dev$mode,       result_bru_fit_rep$summary.range$mode,       result_bru_fit_rep$summary.nu$mode     )   )   print(result_bru_rep_df) ##   parameter true      mean      mode ## 1   std.dev 1.30 1.3245485 1.3250134 ## 2     range 0.15 0.1618924 0.1639533 ## 3        nu 0.80 0.7832856 0.7681990 posterior_df_bru_fit_rep <- gg_df(result_bru_fit_rep)    ggplot(posterior_df_bru_fit_rep) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\") data_prd_list_repl <- graph$get_mesh_locations(bru = TRUE,                                             loc = \"loc\")   data_prd_list_repl[[\"repl\"]] <- rep(10, nrow(data_prd_list$loc)) y_pred <- predict(rspde_model_rep, cmp_rep, rspde_bru_fit_rep,                        newdata=data_prd_list_repl, ~field_eval(loc, replicate = repl)) p <- plot(y_pred, plotly=TRUE) graph_rep$plot(data = \"y\", group = 10, plotly=TRUE, p = p)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"an-example-with-a-non-stationary-model","dir":"Articles","previous_headings":"","what":"An example with a non-stationary model","title":"Whittle--Matérn fields with general smoothness","text":"goal now show one can fit model non-stationary \\(\\sigma\\) (std. deviation) non-stationary \\(\\rho\\) (range parameter). One can also use parameterization terms non-stationary SPDE parameters \\(\\kappa\\) \\(\\tau\\). follow structure INLA. However, INLA allows one specify B.tau B.kappa matrices, , INLA, one wants parameterize terms range standard deviation one needs manually. provide option directly provide matrices B.sigma B.range. usage matrices B.tau B.kappa identical corresponding ones inla.spde2.matern() function. matrices B.sigma B.range work way, parameterize stardard deviation range, respectively. columns B matrices correspond parameter. first column parameter estimated, constant column. , instance, one wants share parameter sigma range (tau kappa), one simply let corresponding column nonzero B.sigma B.range (B.tau B.kappa).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"creating-the-graph-and-adding-data","dir":"Articles","previous_headings":"An example with a non-stationary model","what":"Creating the graph and adding data","title":"Whittle--Matérn fields with general smoothness","text":"example consider pems data contained MetricGraph package. data consists traffic speed observations highways city San Jose, California. variable y contains traffic speeds. summary graph: Observe non-Euclidean graph. Let us create non-stationary covariates, position edge, capture traffic speed taken close intersections. make function symmetric around 0.5 subtracting 0.5 points larger 0.5. , covariate zero close intersections. now build non-stationary matrices used: Let us also obtain covariate observations: Let add covariate data:","code":"pems_graph <- metric_graph$new(edges = pems$edges, longlat=TRUE)  pems_graph$add_observations(data = pems$data, normalized=TRUE)  pems_graph$prune_vertices()  pems_graph$build_mesh(h=0.1) summary(pems_graph) ## A metric graph object with: ##  ## Vertices: ##   Total: 347  ##   Degree 1: 11;  Degree 2: 16;  Degree 3: 315;  Degree 4: 5;  ##   With incompatible directions:  17  ##  ## Edges:  ##   Total: 504  ##   Lengths:  ##       Min: 0.01040218  ; Max: 7.677232  ; Total: 470.7559  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  degrees  ; Lengths unit:  km  ##  ## Longitude and Latitude coordinates:  TRUE ##   Which spatial package:  sp  ##   CRS:  +proj=longlat +datum=WGS84 +no_defs ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: TRUE ##   Is a tree: FALSE ##   Distance consistent: FALSE ##   Has Euclidean edges: FALSE ##  ## Computed quantities inside the graph:  ##   Laplacian:  FALSE  ; Geodesic distances:  TRUE  ##   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  ##  ## Mesh:  ##   Max h_e:  0.09998277  ; Min n_e:  0  ##  ## Data:  ##   Columns:  y  ##   Groups:  None  ##  ## Tolerances:  ##   vertex-vertex:  0.001  ##   vertex-edge:  0.001  ##   edge-edge:  0 cov_pos <- 2 * ifelse(pems_graph$mesh$VtE[,2] > 0.5,                      1-pems_graph$mesh$VtE[,2],                      pems_graph$mesh$VtE[,2]) B.sigma = cbind(0, 1, 0, cov_pos, 0)  B.range = cbind(0, 0, 1,  0, cov_pos) cov_obs <- pems$data[[\"distance_on_edge\"]] cov_obs <- 2 * ifelse(cov_obs > 0.5,                        1 - cov_obs,                       cov_obs) pems_graph$add_observations(data = pems_graph$mutate(cov_obs = cov_obs),                             clear_obs = TRUE) ## Adding observations... ## The unit for edge lengths is km ## The current tolerance for removing distant observations is (in km): 3.83861599015656"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"fitting-the-model-with-graph_lme","dir":"Articles","previous_headings":"An example with a non-stationary model","what":"Fitting the model with graph_lme","title":"Whittle--Matérn fields with general smoothness","text":"now position fit model using graph_lme() function. also add cov_obs covariate model. Let us now obtain summary fitted model: Let us plot range parameter along mesh, can see varying:  Similarly, sigma:  goal now plot estimated marginal standard deviation model. end, start creating non-stationary Matérn operator using rSPDE package: Now, compute estimated marginal standard deviation: can now plot:","code":"fit <- graph_lme(y ~ cov_obs, graph = pems_graph, model = list(type = \"WhittleMatern\",                      B.sigma = B.sigma, B.range = B.range, fem = TRUE)) summary(fit) ##  ## Latent model - Generalized Whittle-Matern ##  ## Call: ## graph_lme(formula = y ~ cov_obs, graph = pems_graph, model = list(type = \"WhittleMatern\",  ##     B.sigma = B.sigma, B.range = B.range, fem = TRUE)) ##  ## Fixed effects: ##             Estimate Std.error z-value Pr(>|z|)     ## (Intercept)   50.735     3.124  16.242  < 2e-16 *** ## cov_obs       -5.036     1.861  -2.707  0.00679 **  ##  ## Random effects: ##         Estimate Std.error z-value ## alpha    1.85737   0.02267  81.918 ## Theta 1  2.28293   0.26953   8.470 ## Theta 2  1.69186   0.28838   5.867 ## Theta 3  0.87681   0.69456   1.262 ## Theta 4  0.81609   0.70067   1.165 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  7.40462   0.05518   134.2 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -1214.849  ## Number of function calls by 'optim' = 501 ## Optimization method used in 'optim' = Nelder-Mead ##  ## Time used to:     fit the model =  28.20906 secs est_range <- exp(B.range[,-1]%*%fit$coeff$random_effects[2:5]) pems_graph$plot_function(X = est_range, vertex_size = 0) est_sigma <- exp(B.sigma[,-1]%*%fit$coeff$random_effects[2:5]) pems_graph$plot_function(X = est_sigma, vertex_size = 0) rspde_object_ns <- rSPDE::spde.matern.operators(graph = pems_graph,                                                 parameterization = \"matern\",                                                 B.sigma = B.sigma,                                                 B.range = B.range,                                                 theta = fit$coeff$random_effects[2:5],                                                 nu = fit$coeff$random_effects[1] - 0.5) est_cov_matrix <- rspde_object_ns$covariance_mesh() est_std_dev <- sqrt(Matrix::diag(est_cov_matrix)) pems_graph$plot_function(X = est_std_dev, vertex_size = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/fem_models.html","id":"fitting-the-inlabru-rspde-model","dir":"Articles","previous_headings":"An example with a non-stationary model","what":"Fitting the inlabru rSPDE model","title":"Whittle--Matérn fields with general smoothness","text":"Let us fit model using inlabru now. start defing rSPDE model rspde.metric_graph() function: Let us now create data.frame() vector replicates indexes: Let us create component fit. can get summary: can obtain outputs respect parameters original scale using function rspde.result(): can also plot posterior densities. end use gg_df() function, creates ggplot2 user-friendly data frames:","code":"rspde_model_nonstat <- rspde.metric_graph(pems_graph,   B.sigma = B.sigma,   B.range = B.range,   parameterization = \"matern\") data_rspde_bru_ns <- graph_data_rspde(rspde_model_nonstat, loc_name = \"loc\") cmp_nonstat <-   y ~ -1 + Intercept(1) + cov_obs + field(loc,     model = rspde_model_nonstat   )   rspde_fit_nonstat <-   bru(cmp_nonstat,     data = data_rspde_bru_ns[[\"data\"]],     family = \"gaussian\",     options = list(verbose = FALSE)   ) summary(rspde_fit_nonstat) ## inlabru version: 2.11.1 ## INLA version: 24.06.27 ## Components: ## Intercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L) ## cov_obs: main = linear(cov_obs), group = exchangeable(1L), replicate = iid(1L) ## field: main = cgeneric(loc), group = exchangeable(1L), replicate = iid(1L) ## Likelihoods: ##   Family: 'gaussian' ##     Data class: 'metric_graph_data', 'list' ##     Predictor: y ~ . ## Time used: ##     Pre = 0.202, Running = 37.8, Post = 0.884, Total = 38.8  ## Fixed effects: ##             mean    sd 0.025quant 0.5quant 0.975quant   mode kld ## Intercept 50.745 2.997     44.752   50.759     56.658 50.757   0 ## cov_obs    0.319 1.764     -3.144    0.320      3.779  0.320   0 ##  ## Random effects: ##   Name     Model ##     field CGeneric ##  ## Model hyperparameters: ##                                           mean    sd 0.025quant 0.5quant ## Precision for the Gaussian observations  0.020 0.002      0.016    0.020 ## Theta1 for field                         3.280 0.407      2.486    3.278 ## Theta2 for field                         2.134 0.327      1.495    2.132 ## Theta3 for field                        -0.235 0.759     -1.738   -0.233 ## Theta4 for field                        -0.027 0.547     -1.110   -0.025 ## Theta5 for field                         1.036 0.567     -0.021    1.018 ##                                         0.975quant   mode ## Precision for the Gaussian observations      0.024  0.020 ## Theta1 for field                             4.087  3.268 ## Theta2 for field                             2.784  2.123 ## Theta3 for field                             1.251 -0.221 ## Theta4 for field                             1.045 -0.016 ## Theta5 for field                             2.206  0.933 ##  ## Deviance Information Criterion (DIC) ...............: 2303.01 ## Deviance Information Criterion (DIC, saturated) ....: 429.77 ## Effective number of parameters .....................: 102.59 ##  ## Watanabe-Akaike information criterion (WAIC) ...: 2297.13 ## Effective number of parameters .................: 79.34 ##  ## Marginal log-Likelihood:  -1241.72  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_nonstat <- rspde.result(rspde_fit_nonstat, \"field\", rspde_model_nonstat) summary(result_fit_nonstat) ##                     mean       sd 0.025quant   0.5quant 0.975quant       mode ## Theta1.matern  3.2798100 0.406562   2.485930  3.2775900    4.08671  3.2682800 ## Theta2.matern  2.1336500 0.327381   1.495140  2.1316000    2.78416  2.1230100 ## Theta3.matern -0.2354940 0.758967  -1.737740 -0.2327220    1.25058 -0.2211800 ## Theta4.matern -0.0265804 0.547445  -1.110150 -0.0245824    1.04533 -0.0162638 ## nu             1.4491100 0.210595   0.993581  1.4668500    1.79948  1.5132500 posterior_df_fit <- gg_df(result_fit_nonstat)  ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +  facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"vignette present R-INLA interface Whittle–Matérn fields. underlying theory approach provided Bolin, Simas, Wallin (2024) Bolin, Simas, Wallin (2023). introduction metric_graph class, please see Working metric graphs vignette. handling data manipulation metric graphs, see Data manipulation metric graphs simplification R-INLA interface, see inlabru interface Whittle–Matérn fields vignette. Gaussian random fields metric graphs vignette, introduce models metric graphs contained package, well , perform statistical tasks models, without R-INLA inlabru interfaces. present R-INLA interface Whittle-Matérn fields providing step--step illustration. Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"a-toy-dataset","dir":"Articles","previous_headings":"","what":"A toy dataset","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"Let us begin loading MetricGraph package creating metric graph: Let us add 50 random locations edge observations: now sample observation locations plot latent field:  Let us now generate observed responses, call y. also plot observed responses metric graph.","code":"library(MetricGraph)  edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 20) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph <- metric_graph$new(edges = edges) obs_per_edge <- 50 obs_loc <- NULL for(i in 1:(graph$nE)) {   obs_loc <- rbind(obs_loc,                    cbind(rep(i,obs_per_edge),                     runif(obs_per_edge))) } sigma <- 2 alpha <- 1 nu <- alpha - 0.5 r <- 0.15 # r stands for range   u <- sample_spde(range = r, sigma = sigma, alpha = alpha,                  graph = graph, PtE = obs_loc) graph$plot(X = u, X_loc = obs_loc) n_obs <- length(u) sigma.e <- 0.1  y <- u + sigma.e * rnorm(n_obs) graph$plot(X = y, X_loc = obs_loc)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"r-inla-implementation","dir":"Articles","previous_headings":"","what":"R-INLA implementation","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"now position fit model R-INLA implementation. end, need add observations graph, add_observations() method.  Now, load R-INLA package create inla model object graph_spde function. default alpha=1. Now, need create data object graph_data_spde() function, need provide name random effect, call field: remaining standard R-INLA. create formula object inla.stack object inla.stack() function. data needs graph (using add_observations() method) supplied stack components data_spde list obtained graph_data_spde() function: Now, use inla.stack.data() function: Finally, fit model: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:","code":"df_graph <- data.frame(y = y, edge_number = obs_loc[,1],                         distance_on_edge = obs_loc[,2]) # Adding observations graph$add_observations(data=df_graph, normalized=TRUE) graph$plot(data=\"y\") library(INLA) spde_model <- graph_spde(graph) data_spde <- graph_data_spde(graph_spde = spde_model, name = \"field\") f.s <- y ~ -1 + Intercept + f(field, model = spde_model)  stk_dat <- inla.stack(data = data_spde[[\"data\"]],                          A = data_spde[[\"basis\"]],                          effects = c(       data_spde[[\"index\"]],       list(Intercept = 1)     )) data_stk <- inla.stack.data(stk_dat) spde_fit <- inla(f.s, data = data_stk, control.predictor=list(A=inla.stack.A(stk_dat))) spde_result <- spde_metric_graph_result(spde_fit, \"field\", spde_model)  summary(spde_result) ##            mean        sd 0.025quant  0.5quant 0.975quant      mode ## sigma 1.6499000 0.1329880  1.4080800 1.6430200   1.931530 1.6349300 ## range 0.0863838 0.0171036  0.0584213 0.0844029   0.125349 0.0804038 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_result$summary.sigma$mean,       spde_result$summary.range$mean     ),     mode = c(       spde_result$summary.sigma$mode,       spde_result$summary.range$mode     )   )   print(result_df) ##   parameter true       mean       mode ## 1   std.dev 2.00 1.64989637 1.63493360 ## 2     range 0.15 0.08638375 0.08040382 posterior_df_fit <- gg_df(spde_result)    library(ggplot2)    ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"kriging-with-our-inla-implementation","dir":"Articles","previous_headings":"R-INLA implementation","what":"Kriging with our INLA implementation","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"Let us begin obtaining evenly spaced mesh respect base graph: Let us plot resulting graph:  now add observations mesh locations graph fitted R-INLA model. end use add_mesh_observations() method. enter response variables NA. can get number mesh nodes counting number rows mesh$PtE attribute. now fit new model R-INLA new graph contains prediction locations. end, create new model object graph_spde() function: Now, let us create new data object prediction. Observe need set drop_all_na FALSE order remove prediction locations: create new vector response variables, concatenating y y_prd, create new formula object inla.stack object: Now, use inla.stack.data() function fit model: now extract means prediction locations: improve visualization, plot posterior means using plot() method:  Finally, can plot predictions together data:","code":"obs_per_edge_prd <- 50 graph$build_mesh(n = obs_per_edge_prd) graph$plot(mesh=TRUE) n_obs_mesh <- nrow(graph$mesh$PtE) y_prd <- rep(NA, n_obs_mesh) data_mesh <- data.frame(y = y_prd) graph$add_mesh_observations(data = data_mesh) ## Adding observations... spde_model_prd <- graph_spde(graph) data_spde_prd <- graph_data_spde(spde_model_prd, drop_all_na = FALSE, name=\"field\") f_s_prd <- y ~ -1 + Intercept + f(field, model = spde_model_prd)  stk_dat_prd <- inla.stack(data = data_spde_prd[[\"data\"]],                          A = data_spde_prd[[\"basis\"]],                          effects = c(       data_spde_prd[[\"index\"]],       list(Intercept = 1)     )) data_stk_prd <- inla.stack.data(stk_dat_prd)  spde_fit_prd <- inla(f_s_prd, data = data_stk_prd) idx_prd <- which(is.na(data_spde_prd[[\"data\"]][[\"y\"]]))  m_prd <- spde_fit_prd$summary.fitted.values$mean[idx_prd] graph$plot_function(X = m_prd, vertex_size = 0, edge_width = 2) p <- graph$plot_function(X = m_prd, vertex_size = 0, edge_width = 1) graph$plot(data=\"y\", vertex_size = 0, data_size = 2, p = p, edge_width = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"an-example-with-alpha-2","dir":"Articles","previous_headings":"R-INLA implementation","what":"An example with alpha = 2","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"now show example parameter alpha equal 2. essentially change commands . Let us first clear observations: Let us now simulate data alpha=2. now sample observation locations plot latent field:  way generate y add observations: Let us now create model object alpha=2: Now, create new data object graph_data_spde() function, need provide name random effect, call field: now proceed prepare fit model: Finally, fit model: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:","code":"graph$clear_observations() sigma <- 2 alpha <- 2 nu <- alpha - 0.5 r <- 0.15 # r stands for range   u <- sample_spde(range = r, sigma = sigma, alpha = alpha,                  graph = graph, PtE = obs_loc) graph$plot(X = u, X_loc = obs_loc) n_obs <- length(u) sigma.e <- 0.1  y <- u + sigma.e * rnorm(n_obs)  df_graph <- data.frame(y = y, edge_number = obs_loc[,1],                         distance_on_edge = obs_loc[,2])  graph$add_observations(data=df_graph, normalized=TRUE) spde_model_alpha2 <- graph_spde(graph, alpha = 2) data_spde_alpha2 <- graph_data_spde(graph_spde = spde_model_alpha2,                              name = \"field\") f.s.2 <- y ~ -1 + Intercept + f(field, model = spde_model_alpha2)  stk_dat2 <- inla.stack(data = data_spde_alpha2[[\"data\"]],                          A = data_spde_alpha2[[\"basis\"]],                          effects = c(       data_spde_alpha2[[\"index\"]],       list(Intercept = 1)     ))  data_stk2 <- inla.stack.data(stk_dat2) spde_fit_alpha2 <- inla(f.s.2, data = data_stk2,            control.predictor=list(A=inla.stack.A(stk_dat2))) spde_result_alpha2 <- spde_metric_graph_result(spde_fit_alpha2,                              \"field\", spde_model_alpha2)  summary(spde_result_alpha2) ##          mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 2.17745 0.2415750   1.745020 2.161610   2.692120 2.128750 ## range 0.15745 0.0168758   0.126931 0.156513   0.193146 0.154691 result_df_alpha2 <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_result_alpha2$summary.sigma$mean,       spde_result_alpha2$summary.range$mean     ),     mode = c(       spde_result_alpha2$summary.sigma$mode,       spde_result_alpha2$summary.range$mode     )   )   print(result_df_alpha2) ##   parameter true      mean      mode ## 1   std.dev 2.00 2.1774543 2.1287524 ## 2     range 0.15 0.1574498 0.1546909 posterior_df_fit <- gg_df(spde_result_alpha2)    library(ggplot2)    ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inla_interface.html","id":"fitting-r-inla-models-with-replicates","dir":"Articles","previous_headings":"R-INLA implementation","what":"Fitting R-INLA models with replicates","title":"INLA interface for Whittle--Matérn fields on metric graphs","text":"now illustrate use R-INLA implementation fit models replicates. simplify exposition, use base graph. , begin clearing observations. use observation locations previous cases. Let us sample 30 replicates: Let us now generate observed responses, call y_rep. sample_spde() function returns matrix replicate column. need stack columns together column indicate replicate: can now add observations setting group argument repl: definition plot() method plots first replicate. can select replicates group argument. See Working metric graphs details.  Let us plot another replicate:  Let us now create model object: Let us first consider case use replicates. , consider case use replicates. Thus, let us assume want consider replicates 1, 3, 5, 7 9. end, index object using graph_data_spde() function argument repl set replicates want, case c(1,3,5,7,9): Next, create stack object, remembering need input components data_spde: now create formula object, adding name field (case field) attached .repl replicate argument inside f() function. , create stack object inla.stack.data() function: Now, fit model: Let us see estimated values original scale: Let us compare true values: Now, let us consider case replicates. create new data object using graph_data_spde() function argument repl set .: Now stack: now create formula object way : , create stack object inla.stack.data() function: Now, fit model: Let us see estimated values original scale: Let us compare true values:","code":"graph$clear_observations() sigma_rep <- 1.5 alpha_rep <- 1 nu_rep <- alpha_rep - 0.5 r_rep <- 0.2 # r stands for range kappa_rep <- sqrt(8 * nu_rep) / r_rep  n_repl <- 30  u_rep <- sample_spde(range = r_rep, sigma = sigma_rep,                  alpha = alpha_rep,                  graph = graph, PtE = obs_loc,                  nsim = n_repl) n_obs_rep <- nrow(u_rep) sigma_e <- 0.1  y_rep <- u_rep + sigma_e * matrix(rnorm(n_obs_rep * n_repl),                                     ncol=n_repl) dl_graph <- lapply(1:ncol(y_rep), function(i){data.frame(y = y_rep[,i],                                           edge_number = obs_loc[,1],                                           distance_on_edge = obs_loc[,2],                                           repl = i)}) dl_graph <- do.call(rbind, dl_graph) graph$add_observations(data = dl_graph, normalized=TRUE,                              group = \"repl\",                             edge_number = \"edge_number\",                             distance_on_edge = \"distance_on_edge\") ## Adding observations... graph$plot(data=\"y\") graph$plot(data=\"y\", group=2) spde_model_rep <- graph_spde(graph) data_spde <- graph_data_spde(graph_spde=spde_model_rep,                       name=\"field\", repl = c(1,3,5,7,9)) stk_dat_rep <- inla.stack(data = data_spde[[\"data\"]],                          A = data_spde[[\"basis\"]],                          effects = c(       data_spde[[\"index\"]],       list(Intercept = 1)     )) f_s_rep <- y ~ -1 + Intercept +      f(field, model = spde_model_rep,          replicate = field.repl) data_stk_rep <- inla.stack.data(stk_dat_rep) spde_fit_rep <- inla(f_s_rep, data = data_stk_rep,                  control.predictor=list(A=inla.stack.A(stk_dat_rep))) spde_result_rep <- spde_metric_graph_result(spde_fit_rep,                          \"field\", spde_model_rep)  summary(spde_result_rep) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.607770 0.0829043    1.45239 1.604280   1.776690 1.596850 ## range 0.223361 0.0254770    0.17767 0.221886   0.277598 0.218889 result_df_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_rep$summary.sigma$mean,       spde_result_rep$summary.range$mean     ),     mode = c(       spde_result_rep$summary.sigma$mode,       spde_result_rep$summary.range$mode     )   )   print(result_df_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.6077726 1.5968463 ## 2     range  0.2 0.2233606 0.2188886 data_spde_rep <- graph_data_spde(graph_spde=spde_model_rep,                      name=\"field\",                      repl = \".all\") stk_dat_rep <- inla.stack(data = data_spde_rep[[\"data\"]],                          A = data_spde_rep[[\"basis\"]],                          effects = c(       data_spde_rep[[\"index\"]],       list(Intercept = 1)     )) f_s_rep <- y ~ -1 + Intercept +      f(field, model = spde_model_rep,          replicate = field.repl) data_stk_rep <- inla.stack.data(stk_dat_rep) spde_fit_rep <- inla(f_s_rep, data = data_stk_rep) spde_result_rep <- spde_metric_graph_result(spde_fit_rep,                          \"field\", spde_model_rep)  summary(spde_result_rep) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.527080 0.0329974   1.464510 1.526310   1.594060 1.526170 ## range 0.222929 0.0105994   0.202993 0.222617   0.244577 0.221933 result_df_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_rep$summary.sigma$mean,       spde_result_rep$summary.range$mean     ),     mode = c(       spde_result_rep$summary.sigma$mode,       spde_result_rep$summary.range$mode     )   )   print(result_df_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.5270770 1.5261717 ## 2     range  0.2 0.2229287 0.2219335"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"inlabru interface of Whittle--Matérn fields","text":"vignette present inlabru interface Whittle–Matérn fields. underlying theory approach provided Bolin, Simas, Wallin (2024) Bolin, Simas, Wallin (2023). introduction metric_graph class, please see Working metric graphs vignette. handling data manipulation metric graphs, see Data manipulation metric graphs R-INLA interface, see INLA interface Whittle–Matérn fields vignette. Gaussian random fields metric graphs vignette, introduce models metric graphs contained package, well , perform statistical tasks models, without R-INLA inlabru interfaces. present inlabru interface Whittle-Matérn fields providing step--step illustration. Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"a-toy-dataset","dir":"Articles","previous_headings":"","what":"A toy dataset","title":"inlabru interface of Whittle--Matérn fields","text":"Let us begin loading MetricGraph package creating metric graph: Let us add 50 random locations edge observations: now sample observation locations plot latent field:  Let us now generate observed responses, call y. also plot observed responses metric graph.","code":"library(MetricGraph)  edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 20) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph_bru <- metric_graph$new(edges = edges) obs_per_edge <- 50 obs_loc <- NULL for(i in 1:(graph_bru$nE)) {   obs_loc <- rbind(obs_loc,                    cbind(rep(i,obs_per_edge),                     runif(obs_per_edge))) } sigma <- 2 alpha <- 1 nu <- alpha - 0.5 r <- 0.15 # r stands for range  u <- sample_spde(range = r, sigma = sigma, alpha = alpha,                  graph = graph_bru, PtE = obs_loc) graph_bru$plot(X = u, X_loc = obs_loc) n_obs <- length(u) sigma.e <- 0.1  y <- u + sigma.e * rnorm(n_obs) graph_bru$plot(X = y, X_loc = obs_loc)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"inlabru-implementation","dir":"Articles","previous_headings":"","what":"inlabru implementation","title":"inlabru interface of Whittle--Matérn fields","text":"now present inlabru implementation Whittle-Matérn fields metric graphs. advantage, R-INLA implementation, requiring user provide observation matrices, indices stack objects. now position fit model inlabru implementation. , need add observations graph, add_observations() method.  Now, load INLA inlabru packages. also need create inla model object graph_spde function. default alpha=1. Now, create inlabru’s component, formula-like object. index parameter inlabru used implementation, thus, replace repl argument, tells replicates use. replicates, supply NULL. Now, create data object passed bru() function: directly fit model providing data component data_spde_bru list: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:","code":"# Creating the data frame df_graph <- data.frame(y = y, edge_number = obs_loc[,1],                       distance_on_edge = obs_loc[,2]) # Adding observations and turning them to vertices graph_bru$add_observations(data = df_graph, normalized=TRUE) ## Adding observations... graph_bru$plot(data=\"y\") library(INLA) library(inlabru) spde_model_bru <- graph_spde(graph_bru) cmp <-     y ~ -1 + Intercept(1) + field(loc,                     model = spde_model_bru) data_spde_bru <- graph_data_spde(spde_model_bru, loc_name = \"loc\") spde_bru_fit <-     bru(cmp, data=data_spde_bru[[\"data\"]]) spde_bru_result <- spde_metric_graph_result(spde_bru_fit,                      \"field\", spde_model_bru)  summary(spde_bru_result) ##            mean        sd 0.025quant 0.5quant 0.975quant      mode ## sigma 1.6498100 0.1353610  1.4017700 1.642970    1.93562 1.6157900 ## range 0.0863838 0.0171037  0.0584212 0.084403    0.12535 0.0804038 result_df_bru <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_bru_result$summary.sigma$mean,       spde_bru_result$summary.range$mean     ),     mode = c(       spde_bru_result$summary.sigma$mode,       spde_bru_result$summary.range$mode     )   )   print(result_df_bru) ##   parameter true       mean       mode ## 1   std.dev 2.00 1.64980898 1.61579260 ## 2     range 0.15 0.08638383 0.08040383 posterior_df_bru_fit <- gg_df(spde_bru_result)    library(ggplot2)    ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"kriging-with-the-inlabru-implementation","dir":"Articles","previous_headings":"inlabru implementation","what":"Kriging with the inlabru implementation","title":"inlabru interface of Whittle--Matérn fields","text":"Unfortunately, inlabru implementation compatible inlabru’s predict() method. nature metric graph’s object. end, provided different predict() method. now show kriging help function. begin creating data list positions want predictions. case, want predictions mesh. Let us begin obtaining evenly spaced mesh respect base graph: Let us plot resulting graph:  positions want mesh positions, can obtained using get_mesh_locations() method. also set bru=TRUE loc=\"loc\" obtain data list suitable used inlabru. can now obtain predictions using predict() method. Observe predict() method graph models bit different inlabru’s standard predict() method. Indeed, first argument model created graph_spde() function, second inlabru’s component, remaining done standard predict() method inlabru. Finally, can plot predictions together data:  can also obtain 3d plot setting plotly TRUE:","code":"obs_per_edge_prd <- 50 graph_bru$build_mesh(n = obs_per_edge_prd) graph_bru$plot(mesh=TRUE) data_list <- graph_bru$get_mesh_locations(bru = TRUE,                                             loc = \"loc\") field_pred <- predict(spde_model_bru,                                  cmp,                                 spde_bru_fit,                                  newdata = data_list,                                 formula = ~field) plot(field_pred) plot(field_pred, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"an-example-with-alpha-2","dir":"Articles","previous_headings":"inlabru implementation","what":"An example with alpha = 2","title":"inlabru interface of Whittle--Matérn fields","text":"now show example parameter alpha equal 2. essentially change commands . Let us first clear observations: Let us now simulate data alpha=2. now sample observation locations plot latent field:  way generate y add observations: Let us now create model object alpha=2: Now, create new data object graph_data_spde() function, need pass argument loc_name needed bru(): Now, create inlabru’s component: directly fit model providing data component data_spde_bru list: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:  Let us now prediction alpha=2. proceed , use data list data_list prediction mesh locations. Thus, obtain predictions using predict() method. Observe , , use predict method, instead default one inlabru. Finally, can plot predictions together data:  can also obtain 3d plot setting plotly TRUE:","code":"graph_bru$clear_observations() sigma <- 2 alpha <- 2 nu <- alpha - 0.5 r <- 0.15 # r stands for range   u <- sample_spde(range = r, sigma = sigma, alpha = alpha,                  graph = graph_bru, PtE = obs_loc) graph_bru$plot(X = u, X_loc = obs_loc) n_obs <- length(u) sigma.e <- 0.1  y <- u + sigma.e * rnorm(n_obs)  df_graph <- data.frame(y = y, edge_number = obs_loc[,1],                         distance_on_edge = obs_loc[,2])  graph_bru$add_observations(data=df_graph, normalized=TRUE) spde_model_alpha2 <- graph_spde(graph_bru, alpha = 2) data_spde_alpha2 <- graph_data_spde(graph_spde = spde_model_alpha2,                              loc_name = \"loc\") cmp_alpha2 <-     y ~ -1 + Intercept(1) + field(loc,                     model = spde_model_alpha2) spde_bru_fit_alpha2 <-     bru(cmp_alpha2, data=data_spde_alpha2[[\"data\"]]) spde_bru_result_alpha2 <- spde_metric_graph_result(spde_bru_fit_alpha2,                      \"field\", spde_model_alpha2)  summary(spde_bru_result_alpha2) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 2.025800 0.2301330   1.612040 2.011930   2.517710 1.986000 ## range 0.152791 0.0168416   0.122475 0.151861   0.188533 0.149931 result_df_bru <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_bru_result_alpha2$summary.sigma$mean,       spde_bru_result_alpha2$summary.range$mean     ),     mode = c(       spde_bru_result_alpha2$summary.sigma$mode,       spde_bru_result_alpha2$summary.range$mode     )   )   print(result_df_bru) ##   parameter true     mean      mode ## 1   std.dev 2.00 2.025805 1.9860028 ## 2     range 0.15 0.152791 0.1499307 posterior_df_bru_fit <- gg_df(spde_bru_result_alpha2)    library(ggplot2)    ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\") field_pred_alpha2 <- predict(spde_model_alpha2,                                  cmp_alpha2,                                 spde_bru_fit_alpha2,                                  newdata = data_list,                                 formula = ~field) plot(field_pred_alpha2) plot(field_pred_alpha2, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"fitting-inlabru-models-with-replicates","dir":"Articles","previous_headings":"inlabru implementation","what":"Fitting inlabru models with replicates","title":"inlabru interface of Whittle--Matérn fields","text":"now illustrate use inlabru implementation fit models replicates. simplify exposition, use base graph. , begin clearing observations: use observation locations previous cases. Let us sample 30 replicates: Let us now generate observed responses, call y_rep. can now add observations setting group argument repl: definition plot() method plots first replicate. can select replicates group argument. See Working metric graphs details.  Let us plot another replicate:  Let us now create model object: Let us first create model using replicates 1, 3, 5, 7 9. end, provide vector replicates want input argument field. graph_data_spde() acts helper function building vector. need , use repl component list created using graph_data_spde() Now, fit model: Let us see estimated values original scale: Let us compare true values: now show fit model considering replicates. end, simply set repl argument graph_data_spde() function .. Similarly, fit model, setting repl argument “.” inside graph_data_spde() function: Let us see estimated values original scale: Let us compare true values:","code":"graph_bru$clear_observations() sigma_rep <- 1.5 alpha_rep <- 1 nu_rep <- alpha_rep - 0.5 r_rep <- 0.2 # r stands for range  n_repl <- 30  u_rep <- sample_spde(range = r_rep, sigma = sigma_rep,                  alpha = alpha_rep,                  graph = graph_bru, PtE = obs_loc,                  nsim = n_repl) n_obs_rep <- nrow(u_rep) sigma_e <- 0.1  y_rep <- u_rep + sigma_e * matrix(rnorm(n_obs_rep * n_repl),                                     ncol=n_repl) dl_rep_graph <- lapply(1:ncol(y_rep), function(i){data.frame(y = y_rep[,i],                                           edge_number = obs_loc[,1],                                           distance_on_edge = obs_loc[,2],                                           repl = i)}) dl_rep_graph <- do.call(rbind, dl_rep_graph)  graph_bru$add_observations(data = dl_rep_graph, normalized=TRUE,                                     group = \"repl\") ## Adding observations... graph_bru$plot(data=\"y\") graph_bru$plot(data=\"y\", group=2) spde_model_bru_rep <- graph_spde(graph_bru) data_spde_bru <- graph_data_spde(spde_model_bru_rep,          loc_name = \"loc\",         repl=c(1,3,5,7,9))  repl <- data_spde_bru[[\"repl\"]] cmp_rep <-     y ~ -1 + Intercept(1) + field(loc,                          model = spde_model_bru_rep,                         replicate = repl) spde_bru_fit_rep <-     bru(cmp_rep,         data=data_spde_bru[[\"data\"]]) spde_result_bru_rep <- spde_metric_graph_result(spde_bru_fit_rep,                          \"field\", spde_model_bru_rep)  summary(spde_result_bru_rep) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.467540 0.0718724   1.333240 1.465710   1.614180 1.465070 ## range 0.190224 0.0214185   0.152123 0.188793   0.236204 0.185802 result_df_bru_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_bru_rep$summary.sigma$mean,       spde_result_bru_rep$summary.range$mean     ),     mode = c(       spde_result_bru_rep$summary.sigma$mode,       spde_result_bru_rep$summary.range$mode     )   )   print(result_df_bru_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.4675405 1.4650702 ## 2     range  0.2 0.1902242 0.1858022 data_spde_bru_rep <- graph_data_spde(spde_model_bru_rep,          loc_name = \"loc\",         repl=\".all\")  repl <- data_spde_bru_rep[[\"repl\"]]  cmp_rep <-  y ~ -1 + Intercept(1) + field(loc,                          model = spde_model_bru_rep,                         replicate = repl) spde_bru_fit_rep <-     bru(cmp_rep,         data=data_spde_bru_rep[[\"data\"]]) spde_result_bru_rep <- spde_metric_graph_result(spde_bru_fit_rep,                          \"field\", spde_model_bru_rep)  summary(spde_result_bru_rep) ##           mean         sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.488390 0.02958690   1.431740 1.488000   1.547590 1.488160 ## range 0.191829 0.00866534   0.175479 0.191575   0.209524 0.191004 result_df_bru_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_bru_rep$summary.sigma$mean,       spde_result_bru_rep$summary.range$mean     ),     mode = c(       spde_result_bru_rep$summary.sigma$mode,       spde_result_bru_rep$summary.range$mode     )   )   print(result_df_bru_rep) ##   parameter true      mean     mode ## 1   std.dev  1.5 1.4883936 1.488157 ## 2     range  0.2 0.1918293 0.191004"},{"path":"https://davidbolin.github.io/MetricGraph/articles/inlabru_interface.html","id":"an-application-with-real-data","dir":"Articles","previous_headings":"inlabru implementation","what":"An application with real data","title":"inlabru interface of Whittle--Matérn fields","text":"example consider pems data contained MetricGraph package. data illustrated (Bolin, Simas, Wallin 2023). data consists traffic speed observations highways city San Jose, California. traffic speeds stored variable y. create metric graph setting longlat = TRUE since coordinates given Longitude Latitude. also add observations metric graph object: Let us now plot data. choose data longitude -121.905 121.875, latitude 37.312 37.328:  now create model, fit, predictions, using inlabru: Let us see estimated values original scale: can now get mesh locations prediction. start creating mesh extracting indexes mesh longitude -121.905 121.875, latitude 37.312 37.328: can now create data list want prediction: Finally, can prediction plot. Observe setting improve_plot=TRUE improve quality plot, however, increases computational cost, since call compute_PtE_edges() method internally.","code":"pems_graph <- metric_graph$new(edges=pems$edges, longlat=TRUE) pems_graph$add_observations(data=pems$data, normalized=TRUE) pems_graph$prune_vertices() p <- pems_graph$filter(-121.905< .coord_x, .coord_x < -121.875,                           37.312 < .coord_y, .coord_y < 37.328) %>%                           pems_graph$plot(data=\"y\", vertex_size=0,                                           data_size=4)       p + xlim(-121.905,-121.875) + ylim(37.312,37.328) spde_model_bru_pems <- graph_spde(pems_graph)       cmp <- y ~ -1 + Intercept(1) + field(loc,                           model = spde_model_bru_pems)       data_spde_bru_pems <- graph_data_spde(spde_model_bru_pems,                         loc_name = \"loc\")       spde_bru_fit_pems <- bru(cmp, data=data_spde_bru_pems[[\"data\"]]) spde_result_bru_pems <- spde_metric_graph_result(spde_bru_fit_pems,                          \"field\", spde_model_bru_pems)  summary(spde_result_bru_pems) ##           mean       sd 0.025quant 0.5quant 0.975quant    mode ## sigma  56.6819  48.9055    15.9256  42.2256    185.827 27.5085 ## range 286.1390 867.4210    15.0924  78.1424   1891.370 24.1596 pems_graph$build_mesh(h=0.1)        # Getting mesh coordinates       mesh_coords <- pems_graph$mesh$V        # Finding coordinates such that longitude is between        # `-121.905` and `121.875`, and latitude is between `37.312` and `37.328`        idx_x <- (mesh_coords[,1] > -121.905) & (mesh_coords[,1] < -121.875)       idx_y <- (mesh_coords[,2] > 37.312) & (mesh_coords[,2] < 37.328)       idx_xy <- idx_x & idx_y pred_coords <- list()       pred_coords[[\"loc\"]] <- pems_graph$mesh$VtE[idx_xy,] field_pred_pems <- predict(spde_model_bru_pems, cmp,                          spde_bru_fit_pems,                         newdata = pred_coords,                         formula = ~ Intercept + field)       plot(field_pred_pems, edge_width = 0.5, vertex_size = 0,                      improve_plot=TRUE) +             xlim(-121.905,-121.875) + ylim(37.316,37.328)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"On isotropic covariances on metric graphs with non-Euclidean edges","text":"vignette investigate behavior isotropic covariance functions (respect resistance metric) metric graphs non-Euclidean edges. boils studying resistance metric metric graphs non-Euclidean edges. precisely, show dealing metric graphs non-Euclidean edges, addition removal vertices degree 2 can severe impact resistance metric , fortiori, covariance function. effect study one fits isotropic model metric graph non-Euclidean edges turning observations vertices, resulting model different one expect. Indeed, model might change predictions (one need add observations vertices obtain predictions). Furthermore, one add observations vertices, actual covariance function might valid @Anderes2020. Actually, @Anderes2020, models defined, define Gaussian models isotropic covariance functions metric graphs Euclidean edges. One option, therefore, simply allow one fit models consistent. However, package chose give warning, let user decide .","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html","id":"a-simple-example","dir":"Articles","previous_headings":"","what":"A simple example","title":"On isotropic covariances on metric graphs with non-Euclidean edges","text":"start creating metric graph multiple edges. metric graph Euclidean edges:  One can also check metric graph Euclidean edges calling check_euclidean() method, calling summary(): Let us now compute resistance distances vertices using compute_resdist() method: can now observe resistance distances res_dist element graph: reality, actually done metric graph, one edges , practice, ignored. Indeed, let us create metric graph Euclidean edges obtained removing one edges, compute resistance distance vertices. Thus, start creating metric graph:  Observe Euclidean edges: Let us now compute resistance distances: Now, let us compare resistance distances: Therefore, indeed, one edges ignored practice. Let us now see happens observations edges, compute resistance distances resulting metric graph (observations turned vertices). end, let us create observations add graph:  Let us now compute resistance distances original vertices. end use compute_resdist() method arguments full=TRUE compute resistance distance available locations, include_vertices=TRUE include original vertices metric graph result. Since 3 vertices, resistance distances original vertices given elements 1 3 resulting matrix: can observe resistance distances different. Thus, impact adding observations computing resistance distances non-Euclidean metric graphs severe. particular, impact covariance function severe. example, let us consider exponential covariance function sigma=1 kappa=1: shows two different models. One considering original metric graph, another, considering metric graph added observations. Therefore, one considers model isotropic covariance function metric graph non-Euclidean edges perform statistical analysis, different models considered different stages statistical analysis. precisely, one believes model considered depends original vertices metric graph, , reality, fitting model, resistance distances computed different metric graph obtained observations turned vertices new metric graph. Finally, one prediction, yet another metric graph considered, namely, metric graph prediction locations added vertices yet another metric graph. Thus, recommend using isotropic covariance models metric graphs non-Euclidean edges, even model capable fitted, several inconsistencies original model, fitted model, model used obtain predictions. important mention phenomenon occur Matérn Gaussian models based graph Laplacian. Whenever want prediction, need add observation locations vertices, thus modifying graph. means inconsistency model used fit data, model used obtain prediction.","code":"edge1 <- rbind(c(0,0),c(1,0)) theta1 <- seq(from=pi/2,to=0,length.out = 50) theta2 <- seq(from=pi,to=3*pi/2,length.out = 50) edge2 <- cbind(sin(theta1)-1,cos(theta1)) edge3 <- cbind(sin(theta2),1+ cos(theta2)) edges = list(edge1, edge2, edge3)  graph <- metric_graph$new(edges = edges)  graph$plot() graph$check_euclidean() summary(graph) #> A metric graph object with: #>  #> Vertices: #>   Total: 3  #>   Degree 1: 1;  Degree 2: 1;  Degree 3: 1;  #>   With incompatible directions:  2  #>  #> Edges:  #>   Total: 3  #>   Lengths:  #>       Min: 1  ; Max: 1.570729  ; Total: 4.141458  #>   Weights:  #>       Min: 1  ; Max: 1  #>   That are circles:  0  #>  #> Graph units:  #>   Vertices unit:  None  ; Lengths unit:  None  #>  #> Longitude and Latitude coordinates:  FALSE #>  #> Some characteristics of the graph: #>   Connected: TRUE #>   Has loops: FALSE #>   Has multiple edges: TRUE #>   Is a tree: FALSE #>   Distance consistent: TRUE #>   Has Euclidean edges: FALSE #>  #> Computed quantities inside the graph:  #>   Laplacian:  FALSE  ; Geodesic distances:  TRUE  #>   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  #>  #> Mesh: The graph has no mesh!  #>  #> Data: The graph has no data! #>  #> Tolerances:  #>   vertex-vertex:  0.001  #>   vertex-edge:  0.001  #>   edge-edge:  0 graph$compute_resdist() res_dist_graph <- graph$res_dist[[1]] edge1 <- rbind(c(0,0),c(1,0)) theta1 <- seq(from=pi/2,to=0,length.out = 50) edge2 <- cbind(sin(theta1)-1,cos(theta1)) edges2 = list(edge1, edge2)  graph2 <- metric_graph$new(edges = edges2)  graph2$plot() graph2$check_euclidean() summary(graph2) #> A metric graph object with: #>  #> Vertices: #>   Total: 3  #>   Degree 1: 2;  Degree 2: 1;  #>   With incompatible directions:  1  #>  #> Edges:  #>   Total: 2  #>   Lengths:  #>       Min: 1  ; Max: 1.570729  ; Total: 2.570729  #>   Weights:  #>       Min: 1  ; Max: 1  #>   That are circles:  0  #>  #> Graph units:  #>   Vertices unit:  None  ; Lengths unit:  None  #>  #> Longitude and Latitude coordinates:  FALSE #>  #> Some characteristics of the graph: #>   Connected: TRUE #>   Has loops: FALSE #>   Has multiple edges: FALSE #>   Is a tree: TRUE #>   Distance consistent: TRUE #>   Has Euclidean edges: TRUE #>  #> Computed quantities inside the graph:  #>   Laplacian:  FALSE  ; Geodesic distances:  TRUE  #>   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  #>  #> Mesh: The graph has no mesh!  #>  #> Data: The graph has no data! #>  #> Tolerances:  #>   vertex-vertex:  0.001  #>   vertex-edge:  0.001  #>   edge-edge:  0 graph2$compute_resdist() identical(res_dist_graph, graph2$res_dist[[1]]) #> [1] TRUE df_data <- data.frame(edge_number = c(1,2,3), distance_on_edge = c(0.5,0.5,0.5), y = c(1,2,3))  graph$add_observations(data = df_data, normalized = TRUE) #> Adding observations... graph$plot(data=\"y\") graph$compute_resdist(full=TRUE, include_vertices = TRUE) res_dist_orig <- graph$res_dist[[1]][1:3,1:3] res_dist_orig #> 3 x 3 Matrix of class \"dgeMatrix\" #>           [,1]     [,2]      [,3] #> [1,] 0.0000000 1.000000 0.7853645 #> [2,] 1.0000000 0.000000 1.7853645 #> [3,] 0.7853645 1.785365 0.0000000 exp_covariance(res_dist_graph, theta = c(1,1)) #> 3 x 3 Matrix of class \"dgeMatrix\" #>           [,1]       [,2]       [,3] #> [1,] 1.0000000 0.36787944 0.20789356 #> [2,] 0.3678794 1.00000000 0.07647977 #> [3,] 0.2078936 0.07647977 1.00000000 exp_covariance(res_dist_orig, theta = c(1,1)) #> 3 x 3 Matrix of class \"dgeMatrix\" #>           [,1]      [,2]      [,3] #> [1,] 1.0000000 0.3678794 0.4559535 #> [2,] 0.3678794 1.0000000 0.1677359 #> [3,] 0.4559535 0.1677359 1.0000000"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Working with metric graphs","text":"Networks street river networks examples metric graphs. compact metric graph \\(\\Gamma\\) consists set finitely many vertices \\(\\mathcal{V}=\\{v_i\\}\\) finite set \\(\\mathcal{E}=\\{e_j\\}\\) edges connecting vertices. edge \\(e\\) curve finite length \\(l_e\\) connects two vertices. curves parameterized arc length location \\(s\\\\Gamma\\) position edge, can thus represented touple \\((e,t)\\) \\(t\\[0,l_e]\\). Compared regular graphs, one typically defines functions vertices, metric graphs interested function defined vertices edges. vignette introduce metric_graph class MetricGraph package. class provides user friendly representation metric graphs, show use class construct visualize metric graphs, add data , work functions defined graphs. details Gaussian processes inference metric graphs, refer Vignettes Gaussian random fields metric graphs INLA interface Whittle–Matérn fields inlabru interface Whittle–Matérn fields Whittle–Matérn fields general smoothness","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"basic-constructions-and-properties","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Basic constructions and properties","title":"Working with metric graphs","text":"metric graph can constructed two ways. first specify edges graph list object, entry matrix. illustrate , first construct following edges can now create graph based edges object follows  plot function used create plot various parameters set sizes colors vertices edges, plotly argument visualize graph 3D. work, plotly library must installed. also important know 2d version plot() method returns ggplot2 object can modified . instance:  Similarly, 3d version plot() method returns plotly object can also modified. instance: can now obtain various properties graph: vertex matrix, specifies Euclidian coordinates vertices edge matrix specified edges graph (.e., vertices connected edges) obtain geodesic (shortest path) distance vertices, can use function compute_geodist: second option construct graph using two matrices V E specify locations (Euclidean space) vertices edges. case, assumed graph straight edges:  third option create graph SpatialLines object:  final option create MULTILINESTRING object:","code":"edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 50) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph <- metric_graph$new(edges = edges) graph$plot() graph$plot(plotly = TRUE, vertex_size = 5, vertex_color = \"blue\",            edge_color = \"red\", edge_width = 2) p <- graph$plot() p + ggplot2::labs(title = \"Metric graph\",           x = \"long\", y = \"lat\") p <- graph$plot(plotly = TRUE) p <- plotly::layout(p, title = \"Metric graph\",                scene = list(xaxis=               list(title = \"Long\"),yaxis=list(title = \"Lat\"))) p graph$V ##      [,1] [,2] ## [1,]    0    0 ## [2,]    1    0 ## [3,]    0    1 ## [4,]   -1    1 graph$E ##      [,1] [,2] ## [1,]    1    2 ## [2,]    1    3 ## [3,]    3    4 ## [4,]    1    4 graph$compute_geodist() graph$geo_dist ## $.vertices ##          [,1]     [,2] [,3]     [,4] ## [1,] 0.000000 1.000000    1 1.570729 ## [2,] 1.000000 0.000000    2 2.570729 ## [3,] 1.000000 2.000000    0 1.000000 ## [4,] 1.570729 2.570729    1 0.000000 V <- rbind(c(0, 0), c(1, 0), c(0, 1), c(-1, 1)) E <- rbind(c(1, 2), c(1, 3), c(3, 4), c(4, 1)) graph2 <- metric_graph$new(V = V, E = E) ## Starting graph creation... ## LongLat is set to FALSE ## The current tolerances are: ##   Vertex-Vertex 0.001 ##   Vertex-Edge 0.001 ##   Edge-Edge 0 ## Setup edges and merge close vertices ## Snap vertices to close edges ## Total construction time: 0.74 secs graph2$plot() library(sp) line1 <- Line(rbind(c(0,0),c(1,0))) line2 <- Line(rbind(c(0,0),c(0,1))) line3 <- Line(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 50) line4 <- Line(cbind(sin(theta),1+ cos(theta))) Lines = sp::SpatialLines(list(Lines(list(line1),ID=\"1\"),                               Lines(list(line2),ID=\"2\"),                               Lines(list(line3),ID=\"3\"),                               Lines(list(line4),ID=\"4\")))  graph <- metric_graph$new(edges = Lines)                     graph$plot() library(sf) line1 <- st_linestring(rbind(c(0,0),c(1,0))) line2 <- st_linestring(rbind(c(0,0),c(0,1))) line3 <- st_linestring(rbind(c(0,1),c(-1,1))) theta <- seq(from=pi,to=3*pi/2,length.out = 50) line4 <- st_linestring(cbind(sin(theta),1+ cos(theta))) multilinestring = st_multilinestring(list(line1, line2, line3, line4))  graph <- metric_graph$new(edges = multilinestring)                     graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"tolerances-for-merging-vertices-and-edges","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Tolerances for merging vertices and edges","title":"Working with metric graphs","text":"constructor graph one argument tolerance used connecting edges close Euclidean space. Specifically, tolerance argument given list three elements: vertex_vertex vertices closer number merged (default value 1e-7) vertex_edge vertex end one edge closer number another edge, vertex connected edge (default value 1e-7) edge_edge two edges point closer number, new vertex added point two edges connected (default value 0 means option used) options often needed constructing graphs based real data, example OpenStreetMap see later. illustrate options, suppose want construct graph following three edges:  added option degree=TRUE plot visualize degrees vertex. expected, one sees vertices degree 1, none three edges connected. streets street network, one might suspect two vertices \\((0,0)\\) \\((0,0.03)\\) really vertex two edges connected. can adjusted increasing vertex_vertex tolerance:  One might also want add vertex \\((0.5, 0.03)\\) vertex first edge, two edges connected. can done adjusting vertex_edge tolerance:  can see vertex \\((0.5,0)\\) indeed connected edge \\((0,0)\\) \\((1,0)\\) vertex now degree 3 since connected three edges. One can also note edges object used create graph modified internally metric_graph object connections visualized correctly sense edges actually shown connected edges. Finally, add vertex intersection edge2 edge3 can adjust edge_edge tolerance:  Now, structure metric graph change add remove vertices degree 2. ,one might want remove vertices degree 2 since can reduce computational costs. can done setting remove_deg2 argument creating graph:  Observe one vertex degree 2 removed. due fact consider direction, vertex directions incompatible removal. can see setting argument direction=TRUE plot() method:","code":"edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0.03),c(0,0.75)) edge3 <- rbind(c(-1,1),c(0.5,0.03)) edge4 <- rbind(c(0,0.75), c(0,1)) edges =  list(edge1, edge2, edge3, edge4) graph3 <- metric_graph$new(edges = edges) graph3$plot(degree = TRUE) print(graph3$nV) ## [1] 7 graph3 <- metric_graph$new(edges = edges, tolerance = list(vertex_vertex = 0.05)) graph3$plot(degree = TRUE) graph3 <- metric_graph$new(edges = edges, tolerance = list(vertex_vertex = 0.05,                                                            vertex_edge = 0.1)) graph3$plot(degree = TRUE) graph3 <- metric_graph$new(edges = edges, tolerance = list(vertex_vertex = 0.2,                                                            vertex_edge = 0.1,                                                            edge_edge = 0.001)) graph3$plot(degree = TRUE) graph3 <- metric_graph$new(edges = edges, tolerance = list(vertex_vertex = 0.2,                                                            vertex_edge = 0.1,                                                            edge_edge = 0.001),                            remove_deg2 = TRUE) graph3$plot(degree = TRUE) graph3$plot(direction = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"characteristics-of-the-graph","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Characteristics of the graph","title":"Working with metric graphs","text":"brief summary main characteristics graph can obtained compute_characteristics() method: can, , view characteristics simply printing metric_graph object: Observe know graph Euclidean edges. can check using check_euclidean() method: Let us view characteristics : can happen graph Euclidean edges without need check distance consistency. However, one wants check graph satisfies distance consistency assumption, one can run check_distance_consistency() function: , individual characteristics can accessed (running compute_characteristics() method) characteristics component graph object:","code":"graph3$compute_characteristics() graph3 ## A metric graph with  6  vertices and  6  edges. ##  ## Vertices: ##   Degree 1: 3;  Degree 2: 1;  Degree 3: 1;  Degree 4: 1;  ##   With incompatible directions:  1  ##  ## Edges:  ##   Lengths:  ##       Min: 0.3533333  ; Max: 1.190873  ; Total: 3.788107  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  None  ; Lengths unit:  None  ##  ## Longitude and Latitude coordinates:  FALSE ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: FALSE ##   Distance consistent: unknown ## To check if the graph satisfies the distance consistency, run the `check_distance_consistency()` method. ##   Has Euclidean edges: unknown ## To check if the graph has Euclidean edges, run the `check_euclidean()` method. graph3$check_euclidean() graph3 ## A metric graph with  6  vertices and  6  edges. ##  ## Vertices: ##   Degree 1: 3;  Degree 2: 1;  Degree 3: 1;  Degree 4: 1;  ##   With incompatible directions:  1  ##  ## Edges:  ##   Lengths:  ##       Min: 0.3533333  ; Max: 1.190873  ; Total: 3.788107  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  None  ; Lengths unit:  None  ##  ## Longitude and Latitude coordinates:  FALSE ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: FALSE ##   Distance consistent: TRUE ##   Has Euclidean edges: TRUE graph3$check_distance_consistency() graph3$characteristics ## $has_loops ## [1] FALSE ##  ## $connected ## [1] TRUE ##  ## $has_multiple_edges ## [1] FALSE ##  ## $is_tree ## [1] FALSE ##  ## $distance_consistency ## [1] TRUE ##  ## $euclidean ## [1] TRUE"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"summaries-of-metric-graphs","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Summaries of metric graphs","title":"Working with metric graphs","text":"can also obtain summary informations contained metric graph object using summary() method. Let us obtain summary informations graph3: Observe quantities computed summary. can see compute setting argument messages TRUE: Finally, summary() can also accessed metric graph object:","code":"summary(graph3) ## A metric graph object with: ##  ## Vertices: ##   Total: 6  ##   Degree 1: 3;  Degree 2: 1;  Degree 3: 1;  Degree 4: 1;  ##   With incompatible directions:  1  ##  ## Edges:  ##   Total: 6  ##   Lengths:  ##       Min: 0.3533333  ; Max: 1.190873  ; Total: 3.788107  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  None  ; Lengths unit:  None  ##  ## Longitude and Latitude coordinates:  FALSE ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: FALSE ##   Distance consistent: TRUE ##   Has Euclidean edges: TRUE ##  ## Computed quantities inside the graph:  ##   Laplacian:  FALSE  ; Geodesic distances:  TRUE  ##   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  ##  ## Mesh: The graph has no mesh!  ##  ## Data: The graph has no data! ##  ## Tolerances:  ##   vertex-vertex:  0.2  ##   vertex-edge:  0.1  ##   edge-edge:  0.001 summary(graph3, messages = TRUE) ## A metric graph object with: ##  ## Vertices: ##   Total: 6  ##   Degree 1: 3;  Degree 2: 1;  Degree 3: 1;  Degree 4: 1;  ##   With incompatible directions:  1  ##  ## Edges:  ##   Total: 6  ##   Lengths:  ##       Min: 0.3533333  ; Max: 1.190873  ; Total: 3.788107  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  None  ; Lengths unit:  None  ##  ## Longitude and Latitude coordinates:  FALSE ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: FALSE ##   Distance consistent: TRUE ##   Has Euclidean edges: TRUE ##  ## Computed quantities inside the graph:  ##   Laplacian:  FALSE  ; Geodesic distances:  TRUE ## To compute the Laplacian, run the 'compute_laplacian()' method. ##   Resistance distances:  FALSE  ; Finite element matrices:  FALSE ## To compute the resistance distances, run the 'compute_resdist()' method. ## To compute the finite element matrices, run the 'compute_fem()' method. ##  ## Mesh: The graph has no mesh! ## To build the mesh, run the 'build_mesh()' method. ##  ## Data: The graph has no data! ## To add observations, use the 'add_observations()' method. ##  ## Tolerances:  ##   vertex-vertex:  0.2  ##   vertex-edge:  0.1  ##   edge-edge:  0.001 graph3$summary() ## A metric graph object with: ##  ## Vertices: ##   Total: 6  ##   Degree 1: 3;  Degree 2: 1;  Degree 3: 1;  Degree 4: 1;  ##   With incompatible directions:  1  ##  ## Edges:  ##   Total: 6  ##   Lengths:  ##       Min: 0.3533333  ; Max: 1.190873  ; Total: 3.788107  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  None  ; Lengths unit:  None  ##  ## Longitude and Latitude coordinates:  FALSE ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: FALSE ##   Distance consistent: TRUE ##   Has Euclidean edges: TRUE ##  ## Computed quantities inside the graph:  ##   Laplacian:  FALSE  ; Geodesic distances:  TRUE  ##   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  ##  ## Mesh: The graph has no mesh!  ##  ## Data: The graph has no data! ##  ## Tolerances:  ##   vertex-vertex:  0.2  ##   vertex-edge:  0.1  ##   edge-edge:  0.001"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"vertices-and-edges","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Vertices and edges","title":"Working with metric graphs","text":"metric graph object edges vertices elements list. can get quick summary calling elements: can also look individual edges vertices. example, let us look vertice number 2: Similarly, let us look edge number 4: message informing us relative positions edges computed. used produce better plots using plot_function() method, see section “Improving plot obtained plot_function” . compute relative positions, run compute_PtE_edges() method: Now, take look edge number 4 :","code":"graph3$vertices ## Vertices of the metric graph ##  ## Longitude and Latitude coordinates: FALSE  ##  ## Summary:  ##      x         y Degree Indegree Outdegree Problematic ## 1  0.0 0.0000000      2        0         2        TRUE ## 2  1.0 0.0000000      1        1         0       FALSE ## 3 -1.0 1.0000000      1        0         1       FALSE ## 4  0.5 0.0300000      3        2         1       FALSE ## 5  0.0 1.0000000      1        1         0       FALSE ## 6  0.0 0.3533333      4        2         2       FALSE graph3$edges ## Edges of the metric graph ##  ## Longitude and Latitude coordinates: FALSE  ##  ## Summary:  ##  ## Edge 1 (first and last coordinates):  ##    x    y ##  0.0 0.00 ##  0.5 0.03 ## Total number of coordinates: 2  ## Edge length: 0.5008992  ## Weight: 1  ##  ## Edge 2 (first and last coordinates):  ##  x         y ##  0 0.0000000 ##  0 0.3533333 ## Total number of coordinates: 2  ## Edge length: 0.3533333  ## Weight: 1  ##  ## Edge 3 (first and last coordinates):  ##   x         y ##  -1 1.0000000 ##   0 0.3533333 ## Total number of coordinates: 2  ## Edge length: 1.190873  ## Weight: 1  ##  ## Edge 4 (first and last coordinates):  ##  x         y ##  0 0.3533333 ##  0 1.0000000 ## Total number of coordinates: 4  ## Edge length: 0.6466667  ## Weight: 1 ## # 2 more edges ## # Use `print(n=...)` to see more edges graph3$vertices[[2]] ## Vertex 2 of the metric graph ##  ## Longitude and Latitude coordinates: FALSE  ##  ## Summary:  ##  x y Degree Indegree Outdegree Problematic ##  1 0      1        1         0       FALSE graph3$edges[[4]] ## Edge 4 of the metric graph ##  ## Longitude and Latitude coordinates: FALSE  ##  ## Coordinates of the vertices of the edge:  ##  x         y ##  0 0.3533333 ##  0 1.0000000 ##  ## Coordinates of the edge: ##  x         y ##  0 0.3533333 ##  0 0.7500000 ##  0 0.7500000 ##  0 1.0000000 ## Relative positions of the coordinates on the graph edges were not computed. ## To compute them, run the `compute_PtE_edges()` method. ##  ## Total number of coordinates: 4  ## Edge length: 0.6466667  ## Weight: 1 graph3$compute_PtE_edges() graph3$edges[[4]] ## Edge 4 of the metric graph ##  ## Longitude and Latitude coordinates: FALSE  ##  ## Coordinates of the vertices of the edge:  ##  x         y ##  0 0.3533333 ##  0 1.0000000 ##  ## Coordinates of the edge: ##  x         y ##  0 0.3533333 ##  0 0.7500000 ##  0 0.7500000 ##  0 1.0000000 ##  ## Relative positions of the edge: ##  Edge number Distance on edge ##            2        1.0000000 ##            4        0.6134021 ##            4        0.6134021 ##            4        1.0000000 ##  ## Total number of coordinates: 4  ## Edge length: 0.6466667  ## Weight: 1"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"understanding-coordinates-on-graphs","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Understanding coordinates on graphs","title":"Working with metric graphs","text":"locations vertices specified Euclidean coordinates. However, specifying position graph, practical work Euclidean coordinates since locations Euclidean space locations graph. instead better specify location graph touple \\((, t)\\), \\(\\) denotes number edge \\(t\\) location edge. location \\(t\\) can either specified distance start edge (takes values 0 length edge) normalized distance start edge (takes values 0 1). function coordinates can used convert coordinates Euclidean space locations graph. example location distance 0.2 start second edge : case, since edge length 1, location point normalized distance 0.2 start edge : function can also used find closest location graph location Euclidean space: case, normalized argument decides whether returned value given normalized distance .","code":"graph$coordinates(PtE = matrix(c(2, 0.2), 1,2), normalized = FALSE) ##      [,1] [,2] ## [1,]    0  0.2 graph$coordinates(PtE = matrix(c(2, 0.2), 1,2), normalized = TRUE) ##      [,1] [,2] ## [1,]    0  0.2 graph$coordinates(XY = matrix(c(0, 0.2), 1,2)) ##      [,1] [,2] ## [1,]    2  0.2"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"methods-for-working-with-real-data","dir":"Articles","previous_headings":"Constructing metric graphs","what":"Methods for working with real data","title":"Working with metric graphs","text":"illustrate useage metric_graph real data, use osmdata package download data OpenStreetMap. following code, extract highways city Copenhagen:  things note data like . first coordinates given Longitude Latitude. , edge lengths default given degrees, may result small numbers: may cause numerical instabilities dealing random fields graph, also makes difficult interpret results (unless one good intuition distances degrees). avoid problems, better set longlat argument constructing graph: tells constructor coordinates given Longitude Latitude distances calculated km. now look edge lengths, given km: second thing note constructor gave warning graph connected. might ideal modeling may want study different connected components separately. concern, one can set argument check_connected = FALSE creating graph. case check done warning message printed. construct connected components, can create graph_components object: graph_components class contains list metric_graph objects, one connected component. case, components total, total edge lengths km plot , can use plot command class:  One reason multiple components might set tolerance merging nodes low. fact, looking edge lengths see vertices close meters. Let us increase tolerances vertices distance 100 meters (0.1km) apart merged:  choice, let us check number connected components: can retrieve graph standard metric_graph object work analysis via get_largest command: Let us take quick look vertices edges: also relevant obtain summary graph: graph Euclidean edges. Also observe units vertices lengths, also coordinate reference system used object.","code":"library(osmdata) set_overpass_url(\"https://maps.mail.ru/osm/tools/overpass/api/interpreter\") call <- opq(bbox = c(12.4,55.5,12.65,55.9)) call <- add_osm_feature(call, key = \"highway\",value=c(\"motorway\", \"primary\",                                                       \"secondary\")) data <- osmdata_sp(call)  graph5 <- metric_graph$new(SpatialLines(data$osm_lines@lines)) graph5$plot(vertex_size = 0) range(graph5$get_edge_lengths()) ## [1] 1.000842e-03 6.604472e+02 graph5 <- metric_graph$new(SpatialLines(data$osm_lines@lines), longlat = TRUE) range(graph5$get_edge_lengths()) ## Units: [km] ## [1] 1.652242e-03 7.288390e+04 graphs <- graph_components$new(SpatialLines(data$osm_lines@lines),                                                      longlat = TRUE) graphs$n ## [1] 14 graphs$lengths ## Units: [km] ##  [1] 13253.595067   179.415890   113.280573    36.634315    10.747573 ##  [6]    10.678542     9.410606     8.960023     8.722648     4.246385 ## [11]     2.845490     2.753691     1.907717     1.082217 graphs$plot(vertex_size = 0) min(graph5$get_edge_lengths(unit='m')) ## 1.652242 [m] graphs <- graph_components$new(SpatialLines(data$osm_lines@lines), longlat = TRUE,                                tolerance = list(vertex_vertex = 0.1)) graphs$plot(vertex_size = 0) graphs$n ## [1] 4 graph5 <- graphs$get_largest() graph5$vertices ## Vertices of the metric graph ##  ## Longitude and Latitude coordinates: TRUE  ## Coordinate reference system: +proj=longlat +datum=WGS84 +no_defs  ##  ## Summary:  ##   Longitude Latitude Degree Indegree Outdegree Problematic ## 1  9.604076 59.22148      1        0         1       FALSE ## 2  9.558224 59.30278      1        1         0       FALSE graph5$edges ## Edges of the metric graph ##  ## Longitude and Latitude coordinates: TRUE  ## Coordinate reference system: +proj=longlat +datum=WGS84 +no_defs  ##  ## Summary:  ##  ## Edge 1 (first and last coordinates):  ##  Longitude Latitude ##   9.604076 59.22148 ##   9.558224 59.30278 ## Total number of coordinates: 132  ## Edge length: 13253.6 km  ## Weight: 1 summary(graph5) ## A metric graph object with: ##  ## Vertices: ##   Total: 2  ##   Degree 1: 2;  ##   With incompatible directions:  0  ##  ## Edges:  ##   Total: 1  ##   Lengths:  ##       Min: 13253.6  ; Max: 13253.6  ; Total: 13253.6  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  degrees  ; Lengths unit:  km  ##  ## Longitude and Latitude coordinates:  TRUE ##   Which spatial package:  sp  ##   CRS:  +proj=longlat +datum=WGS84 +no_defs ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: TRUE ##   Distance consistent: TRUE ##   Has Euclidean edges: TRUE ##  ## Computed quantities inside the graph:  ##   Laplacian:  FALSE  ; Geodesic distances:  TRUE  ##   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  ##  ## Mesh: The graph has no mesh!  ##  ## Data: The graph has no data! ##  ## Tolerances:  ##   vertex-vertex:  0.1  ##   vertex-edge:  1e-07  ##   edge-edge:  0"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"adding-data-to-the-graph","dir":"Articles","previous_headings":"","what":"Adding data to the graph","title":"Working with metric graphs","text":"Given constructed metric graph, can now add data . details data manipulation metric graphs, see Data manipulation metric graphs. example, let us consider first graph suppose observations distance 0.5 start edge. One way specifying follows  certain situations, might easier specify relative distances edges, 0 represents start 1 end edge (instead edge length). , can simply specify normalized = TRUE adding observations. example, let us add one observation midpoint fourth edge:  alternative method specify observations spatial points objects, locations given Euclidean coordinates. case observations added closes location graph:  want replace data object, can use clear_observations() remove current data: metric_graph object can hold multiple variables data, one can also specify group argument useful specifying data grouped, example case data observed different time points. example, let us add two variables observed two separate time points: NA given variable, indicates specific variable measured location group. can now plot individual variables specifying names plot function together group number want see. default first group shown.  cases, might want add observation locations vertices graph. can done follows:  One can note command adds observation locations, groups vertices. Finally, let us obtain summary graph containing data:","code":"obs.loc <- cbind(1:4, rep(0.5, 4)) obs <- c(1,2,3,4) df_graph <- data.frame(y = obs, edge_number = obs.loc[,1],                          distance_on_edge = obs.loc[,2]) graph$add_observations(data = df_graph) ## Adding observations... graph$plot(data = \"y\", data_size = 2) obs.loc <- matrix(c(4, 0.5),1,2) obs <- c(5) df_new <- data.frame(y=obs, edge_number = obs.loc[,1],                            distance_on_edge = obs.loc[,2]) graph$add_observations(data=df_new, normalized = TRUE) ## Adding observations... graph$plot(data = \"y\") obs.loc <- rbind(c(0.7, 0), c(0, 0.2)) obs <- c(6,7) points <- SpatialPointsDataFrame(coords = obs.loc,                                  data = data.frame(y = obs)) graph$add_observations(points) ## Adding observations... ## Converting data to PtE ## [1] y        .coord_x .coord_y ## <0 rows> (or 0-length row.names) graph$plot(data = \"y\") graph$clear_observations() obs.loc <- cbind(c(1:4, 1:4), c(rep(0.5, 4), rep(0.7, 4))) df_rep <- data.frame(y = c(1, 2, NA, 3, 4, 6, 5, 7),                      x = c(NA, 8, 9, 10, 11, 12, 13, NA),                      edge_number = obs.loc[,1],                       distance_on_edge = obs.loc[,2],                      time = c(rep(1, 4), rep(2, 4))) graph$add_observations(data = df_rep, group = \"time\") ## Adding observations... graph$plot(data = \"y\", group = 2) graph$observation_to_vertex() graph$plot(data = \"x\", group = 1) summary(graph) ## A metric graph object with: ##  ## Vertices: ##   Total: 12  ##   Degree 1: 1;  Degree 2: 10;  Degree 3: 1;  ##   With incompatible directions:  2  ##  ## Edges:  ##   Total: 12  ##   Lengths:  ##       Min: 0.2  ; Max: 0.8707291  ; Total: 4.570729  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  None  ; Lengths unit:  None  ##  ## Longitude and Latitude coordinates:  FALSE ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: FALSE ##   Distance consistent: TRUE ##   Has Euclidean edges: TRUE ##  ## Computed quantities inside the graph:  ##   Laplacian:  FALSE  ; Geodesic distances:  TRUE  ##   Resistance distances:  FALSE  ; Finite element matrices:  FALSE  ##  ## Mesh: The graph has no mesh!  ##  ## Data:  ##   Columns:  y x time  ##   Groups:  time  ##  ## Tolerances:  ##   vertex-vertex:  0.001  ##   vertex-edge:  0.001  ##   edge-edge:  0"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"working-with-functions-on-metric-graphs","dir":"Articles","previous_headings":"","what":"Working with functions on metric graphs","title":"Working with metric graphs","text":"working data metric graphs, one often wants display functions graph. best way visualize functions graph evaluate fine mesh graph use plot_function. illustrate procedure, let us consider following graph:  command build_mesh, argument h decides largest spacing nodes mesh. can seen plot, mesh coarse, let’s reduce value h rebuild mesh: Suppose now want display function \\(f(x, y) = x^2 - y^2\\) graph. first evaluate vertices mesh use function plot_function display :  Alternatively, can set plotly = TRUE plot command get 3D visualization function: first argument plot_function vector, function assumes values vector values function evaluated vertices mesh. alternative, one can also provide new dataset. illustrate , let us first construct set locations evenly spaced edge. , convert data Euclidean coordinates can evaluate function . , process data finally plot result: Alternatively, can add data graph, directly plot using data argument. illustration purposes, build next plot 2d plot:","code":"V <- rbind(c(0, 0), c(1, 0), c(1, 1), c(0, 1), c(-1, 1), c(-1, 0), c(0, -1)) E <- rbind(c(1, 2), c(2, 3), c(3, 4), c(4, 5),            c(5, 6), c(6, 1), c(4, 1),c(1, 7)) graph <- metric_graph$new(V = V, E = E) graph$build_mesh(h = 0.5) graph$plot(mesh=TRUE) graph$build_mesh(h = 0.01) x <- graph$mesh$V[, 1] y <- graph$mesh$V[, 2] f <- x^2 - y^2 graph$plot_function(X = f) graph$plot_function(X = f, plotly = TRUE) n.e <- 30 PtE <- cbind(rep(1:graph$nE, each = n.e),               rep(seq(from = 0, to = 1, length.out = n.e), graph$nE))         XY <- graph$coordinates(PtE) f <- XY[, 1]^2 - XY[, 2]^2 data_f <- data.frame(f = f, \"edge_number\" = PtE[,1],              \"distance_on_edge\" = PtE[,2]) data_f <- graph$process_data(data = data_f, normalized=TRUE)             graph$plot_function(data = \"f\", newdata = data_f, plotly = TRUE) graph$add_observations(data = data_f, clear_obs = TRUE, normalized = TRUE) ## Adding observations... graph$plot_function(data = \"f\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"improving-the-plot-obtained-by-plot_function","dir":"Articles","previous_headings":"Working with functions on metric graphs","what":"Improving the plot obtained by plot_function","title":"Working with metric graphs","text":"compute relative positions edge coordinates, can improve quality plot obtained using plot_function. Observe depending size graph, might costly, since need conversion. begin recreating first graph used vignette: Now, let us compute relative positions coordinates edge using compute_PtE_edges() method: Let us create coarse mesh, improvement can easily seen.  Let us compute function function mesh: can directly plot mesh values. Let us start default, non-improved, plot:  can, , plot improved version setting improve_plot TRUE:  Alternatively, can supply data newdata argument. end, need supply data.frame. let us build : Let us now process data.frame graph’s internal data format using process_data() method: now plot function. First, let us default plot plot_function:  Let us now, create plot improve_plot=TRUE:  reason refined lot circular part interpolates values function edge coordinates, circular part coordinates. edges two coordinates, start end. Let us now obtain 3d plot. First, default version: Now, improved version:","code":"edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 50) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4)  graph <- metric_graph$new(edges = edges) graph$compute_PtE_edges() graph$build_mesh(h=0.8) graph$plot(mesh=TRUE) XY <- graph$mesh$V f <- XY[, 1]^2 - XY[, 2]^2 graph$plot_function(f) graph$plot_function(f, improve_plot = TRUE) df_f <- data.frame(edge_number = graph$mesh$VtE[,1],                     distance_on_edge = graph$mesh$VtE[,2],                     f = f) df_f <- graph$process_data(data = df_f, normalized=TRUE) graph$plot_function(data = \"f\", newdata= df_f) graph$plot_function(data = \"f\", newdata= df_f, improve_plot=TRUE) graph$plot_function(data = \"f\", newdata= df_f, plotly=TRUE) graph$plot_function(data = \"f\", newdata= df_f, plotly=TRUE,                     improve_plot = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph.html","id":"note-about-continuity","dir":"Articles","previous_headings":"Working with functions on metric graphs > Improving the plot obtained by plot_function","what":"Note about continuity","title":"Working with metric graphs","text":"However, important observe plot_function assumes continuity function default. Let us see example discontinuous function, observe effect plot_function. case, improve_plot affect action discontinuity points. example, let us consider function takes edge number (normalized). Let us also refine mesh bit, easier observe happening. Let us proceed creation data.frame processing data: now plot function default plot plot_function:  Let us now, create plot improve_plot=TRUE:  Let us now obtain 3d plot. First, default version: Now, improved version: Observe versions behavior around vertices (discontinuity points). work discontinuous functions, simplest option create mesh assume continuity: mesh, vertex split one vertex per edge connecting vertex, allows discontinuous functions.  Similarly case continuous meshes, improve_plot option:  Now, 3d plot: Alternatively, can similarly plot setting data.frame passing newdata argument: Let us now build plots. case, need set continuous argument FALSE. First 2d plot:  Now, 3d plot:","code":"graph$build_mesh(h=0.2) f <- graph$mesh$VtE[,1]/4 df_f <- data.frame(edge_number = graph$mesh$VtE[,1],                     distance_on_edge = graph$mesh$VtE[,2],                     f = f) df_f <- graph$process_data(data = df_f, normalized=TRUE) graph$plot_function(data = \"f\", newdata= df_f) graph$plot_function(data = \"f\", newdata= df_f, improve_plot=TRUE) graph$plot_function(data = \"f\", newdata= df_f, plotly=TRUE) graph$plot_function(data = \"f\", newdata= df_f, plotly=TRUE,                     improve_plot = TRUE) graph$build_mesh(h=0.8, continuous = FALSE) f <- graph$mesh$PtE[,1]/4 graph$plot_function(f) graph$plot_function(f, improve_plot = TRUE) graph$plot_function(f, plotly=TRUE, improve_plot = TRUE) df_f <- data.frame(edge_number = graph$mesh$VtE[,1],                     distance_on_edge = graph$mesh$VtE[,2],                     f = f) df_f <- graph$process_data(data = df_f, normalized=TRUE) graph$plot_function(data = \"f\", newdata= df_f,                        improve_plot = TRUE,  continuous = FALSE) graph$plot_function(data = \"f\", newdata= df_f, plotly=TRUE,                     improve_plot = TRUE, continuous = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Data manipulation on metric graphs","text":"vignette provide examples data manipulation metric graphs. precisely, show add data metric graph, retrieve data, data manipulation using tidyverse tools. Finally, show add results manipulations back metric graph. example throughout vignette, consider following metric graph:  details construction metric graphs, see Working metric graphs","code":"edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 20) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph <- metric_graph$new(edges = edges) graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"adding-and-accessing-data-on-metric-graphs","dir":"Articles","previous_headings":"","what":"Adding and accessing data on metric graphs","title":"Data manipulation on metric graphs","text":"Let us start generating data added metric graph object created, namely graph. first generate locations: Now, generate data build data.frame added metric graph: can now add data graph using add_mesh_observations() method. add data providing edge number relative distance edge. end, adding data, need supply names columns contain edge number distance edge entering edge_number distance_on_edge arguments. , since providing relative distance, need set normalized argument TRUE: can check data successfully added retrieving metric graph using get_data() method: can also visualize data using plot() method specifying column like plot:  can add data metric graph using add_observations() method . end, let us create additional dataset. time, add using spatial coordinates. case, generate 50 uniform locations x coordinate data, keep y coordinate equal zero. , generate 50 realizations standard gaussian variable y2 variable. Let us add dataset. Now, need set data_coords \"spatial\" need supply names columns x y coordinates: Let us check data successfully added: can also plot:  Observe NAs added, since df_data contain column y2 df_data2 contain column y. default, get_data() method excludes rows variables NA (location variables considered ). can also show rows contain NA observations using drop_na argument get_data() method: Observe row, since contain least one NA. Suppose now want replace metric graph data new dataset. end two options. first one use clear_observations() method, add observations: now create dataset want add. simplify, use default naming edge number distance edge, need specify add_observations() method: can now add data. Remember set normalized TRUE since providing relative distance edge: check: second way replace data metric graph set clear_obs argument TRUE. also create new dataset using default naming x y coordinates, need specify : add (remember set data_coords \"spatial\"): can check replaced:","code":"obs_per_edge <- 50 obs_loc <- NULL for(i in 1:(graph$nE)) {   obs_loc <- rbind(obs_loc,                    cbind(rep(i,obs_per_edge),                     runif(obs_per_edge))) } y <- rnorm(graph$nE * obs_per_edge)  df_data <- data.frame(y=y, edge = obs_loc[,1], pos = obs_loc[,2]) graph$add_observations(data = df_data, edge_number = \"edge\",                      distance_on_edge = \"pos\", normalized = TRUE) ## Adding observations... graph$get_data() ## # A tibble: 200 × 6 ##          y .edge_number .distance_on_edge .group .coord_x .coord_y ##      <dbl>        <dbl>             <dbl>  <dbl>    <dbl>    <dbl> ##  1 -0.0736            1            0.0134      1   0.0134        0 ##  2  2.09              1            0.0233      1   0.0233        0 ##  3  1.68              1            0.0618      1   0.0618        0 ##  4 -0.528             1            0.108       1   0.108         0 ##  5 -0.180             1            0.126       1   0.126         0 ##  6 -0.462             1            0.177       1   0.177         0 ##  7 -1.52              1            0.186       1   0.186         0 ##  8 -0.655             1            0.202       1   0.202         0 ##  9 -0.636             1            0.206       1   0.206         0 ## 10  1.34              1            0.212       1   0.212         0 ## # ℹ 190 more rows graph$plot(data = \"y\") coordx <- runif(50) coordy <- 0 y2 <- rnorm(50)  df_data2 <- data.frame(y2 = y2, coordx = coordx, coordy = coordy) graph$add_observations(data = df_data2, data_coords = \"spatial\",                              coord_x = \"coordx\", coord_y = \"coordy\") ## Adding observations... ## Converting data to PtE ## [1] y2     coordx coordy ## <0 rows> (or 0-length row.names) graph$get_data() ## # A tibble: 250 × 8 ##          y     y2 .distance_to_graph .edge_number .distance_on_edge .group ##      <dbl>  <dbl>              <dbl>        <dbl>             <dbl>  <dbl> ##  1 -0.0736 NA                     NA            1            0.0134      1 ##  2  2.09   NA                     NA            1            0.0233      1 ##  3 NA       0.278                  0            1            0.0308      1 ##  4 NA      -2.26                   0            1            0.0574      1 ##  5  1.68   NA                     NA            1            0.0618      1 ##  6 NA      -0.636                  0            1            0.0649      1 ##  7 NA       1.31                   0            1            0.0978      1 ##  8 NA      -0.334                  0            1            0.107       1 ##  9 -0.528  NA                     NA            1            0.108       1 ## 10 -0.180  NA                     NA            1            0.126       1 ## # ℹ 240 more rows ## # ℹ 2 more variables: .coord_x <dbl>, .coord_y <dbl> graph$plot(data = \"y2\") graph$get_data(drop_na = TRUE) ## # A tibble: 0 × 8 ## # ℹ 8 variables: y <dbl>, y2 <dbl>, .distance_to_graph <dbl>, ## #   .edge_number <dbl>, .distance_on_edge <dbl>, .group <dbl>, .coord_x <dbl>, ## #   .coord_y <dbl> graph$clear_observations() y3 <- rnorm(graph$nE * obs_per_edge)  df_data3 <- data.frame(y3=y3, edge_number = obs_loc[,1], distance_on_edge = obs_loc[,2]) graph$add_observations(data = df_data3, normalized = TRUE) ## Adding observations... graph$get_data() ## # A tibble: 200 × 6 ##         y3 .edge_number .distance_on_edge .group .coord_x .coord_y ##      <dbl>        <dbl>             <dbl>  <dbl>    <dbl>    <dbl> ##  1  1.90              1            0.0134      1   0.0134        0 ##  2 -0.710             1            0.0233      1   0.0233        0 ##  3  1.15              1            0.0618      1   0.0618        0 ##  4  1.12              1            0.108       1   0.108         0 ##  5 -0.715             1            0.126       1   0.126         0 ##  6 -2.13              1            0.177       1   0.177         0 ##  7  1.44              1            0.186       1   0.186         0 ##  8  1.76              1            0.202       1   0.202         0 ##  9 -0.0565            1            0.206       1   0.206         0 ## 10  1.59              1            0.212       1   0.212         0 ## # ℹ 190 more rows df_data4 <- data.frame(y4 = exp(y2), coord_x = coordx, coord_y = coordy) graph$add_observations(data = df_data4, clear_obs = TRUE,                              data_coords = \"spatial\") ## Adding observations... ## Converting data to PtE ## [1] y4      coord_x coord_y ## <0 rows> (or 0-length row.names) graph$get_data() ## # A tibble: 50 × 7 ##       y4 .distance_to_graph .edge_number .distance_on_edge .group .coord_x ##    <dbl>              <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1 1.32                   0            1            0.0308      1   0.0308 ##  2 0.104                  0            1            0.0574      1   0.0574 ##  3 0.530                  0            1            0.0649      1   0.0649 ##  4 3.72                   0            1            0.0978      1   0.0978 ##  5 0.716                  0            1            0.107       1   0.107  ##  6 2.23                   0            1            0.136       1   0.136  ##  7 1.19                   0            1            0.147       1   0.147  ##  8 0.345                  0            1            0.153       1   0.153  ##  9 0.564                  0            1            0.202       1   0.202  ## 10 2.50                   0            1            0.213       1   0.213  ## # ℹ 40 more rows ## # ℹ 1 more variable: .coord_y <dbl>"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"adding-grouped-data-to-metric-graphs","dir":"Articles","previous_headings":"","what":"Adding grouped data to metric graphs","title":"Data manipulation on metric graphs","text":"graph structure also allow add grouped data. end need specify column data grouping variable. illustrate, let us generate grouped data. use locations generated previous section. Let us now create data.frame grouped data, grouping variable repl: can now add data.frame graph using add_observations() method. need set normalized TRUE, since relative distances edge. also need set group argument repl, since repl grouping variable. Finally, also set clear_obs TRUE since want replace existing data. Let us check graph data. Observe grouping variable now .group. can obtain data given group setting group argument get_data() method: can also provide group argument vector: plot() method works similarly. can plot data specific group specifying group like plot:","code":"n.repl <- 5  y_repl <- rnorm(n.repl * graph$nE * obs_per_edge) repl <- rep(1:n.repl, each = graph$nE * obs_per_edge) df_data_repl <- data.frame(y = y_repl, repl = repl,                    edge_number = rep(obs_loc[,1], times = n.repl),                    distance_on_edge = rep(obs_loc[,2], times = n.repl)) graph$add_observations(data = df_data_repl,                          normalized = TRUE,                          clear_obs = TRUE,                          group = \"repl\") ## Adding observations... graph$get_data() ## # A tibble: 1,000 × 7 ##         y  repl .edge_number .distance_on_edge .group .coord_x .coord_y ##     <dbl> <int>        <dbl>             <dbl> <chr>     <dbl>    <dbl> ##  1  1.50      1            1            0.0134 1        0.0134        0 ##  2 -1.79      1            1            0.0233 1        0.0233        0 ##  3  0.488     1            1            0.0618 1        0.0618        0 ##  4 -0.385     1            1            0.108  1        0.108         0 ##  5  0.905     1            1            0.126  1        0.126         0 ##  6 -0.145     1            1            0.177  1        0.177         0 ##  7  2.00      1            1            0.186  1        0.186         0 ##  8 -1.16      1            1            0.202  1        0.202         0 ##  9  0.879     1            1            0.206  1        0.206         0 ## 10 -0.816     1            1            0.212  1        0.212         0 ## # ℹ 990 more rows graph$get_data(group = \"3\") ## # A tibble: 200 × 7 ##          y  repl .edge_number .distance_on_edge .group .coord_x .coord_y ##      <dbl> <int>        <dbl>             <dbl> <chr>     <dbl>    <dbl> ##  1  1.11       3            1            0.0134 3        0.0134        0 ##  2  0.774      3            1            0.0233 3        0.0233        0 ##  3  0.464      3            1            0.0618 3        0.0618        0 ##  4 -1.62       3            1            0.108  3        0.108         0 ##  5 -1.48       3            1            0.126  3        0.126         0 ##  6 -0.815      3            1            0.177  3        0.177         0 ##  7 -1.25       3            1            0.186  3        0.186         0 ##  8  0.0646     3            1            0.202  3        0.202         0 ##  9  0.129      3            1            0.206  3        0.206         0 ## 10 -0.881      3            1            0.212  3        0.212         0 ## # ℹ 190 more rows graph$get_data(group = c(\"3\",\"5\")) ## # A tibble: 400 × 7 ##          y  repl .edge_number .distance_on_edge .group .coord_x .coord_y ##      <dbl> <int>        <dbl>             <dbl> <chr>     <dbl>    <dbl> ##  1  1.11       3            1            0.0134 3        0.0134        0 ##  2  0.774      3            1            0.0233 3        0.0233        0 ##  3  0.464      3            1            0.0618 3        0.0618        0 ##  4 -1.62       3            1            0.108  3        0.108         0 ##  5 -1.48       3            1            0.126  3        0.126         0 ##  6 -0.815      3            1            0.177  3        0.177         0 ##  7 -1.25       3            1            0.186  3        0.186         0 ##  8  0.0646     3            1            0.202  3        0.202         0 ##  9  0.129      3            1            0.206  3        0.206         0 ## 10 -0.881      3            1            0.212  3        0.212         0 ## # ℹ 390 more rows graph$plot(data = \"y\", group = \"3\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"more-advanced-grouping","dir":"Articles","previous_headings":"","what":"More advanced grouping","title":"Data manipulation on metric graphs","text":"Besides able group data acoording one column data, can also group data respect several columns data. Let us generate new data set: Let us now add observations graph group c(\"repl_1\",\"repl_2\"): Let us take look grouped variables. stored .group column: Observe group variable created, default, pasting group variables together . separator. can change separator using group_sep argument: , plot data particular group, simply select group variable want plot. Let us plot y repl_1 equal 3 repl_2 equal c:","code":"n.repl <- 10  y_repl <- rnorm(n.repl * graph$nE * obs_per_edge) repl_1 <- rep(1:n.repl, each = graph$nE * obs_per_edge) repl_2 <- rep(c(\"a\",\"b\",\"c\",\"d\",\"e\"), times = 2 * graph$nE * obs_per_edge)  df_adv_grp <- data.frame(data.frame(y = y_repl,                    repl_1 = repl_1, repl_2 = repl_2,                   edge_number = rep(obs_loc[,1], times = n.repl),                    distance_on_edge = rep(obs_loc[,2], times = n.repl))) graph$add_observations(data = df_adv_grp,                          normalized = TRUE,                          clear_obs = TRUE,                          group = c(\"repl_1\", \"repl_2\")) ## Adding observations... graph$get_data() ## # A tibble: 2,000 × 8 ##         y repl_1 repl_2 .edge_number .distance_on_edge .group .coord_x .coord_y ##     <dbl>  <int> <chr>         <dbl>             <dbl> <chr>     <dbl>    <dbl> ##  1  1.15       1 a                 1             0.206 1.a       0.206        0 ##  2 -0.529      1 a                 1             0.266 1.a       0.266        0 ##  3  0.344      1 a                 1             0.386 1.a       0.386        0 ##  4  0.921      1 a                 1             0.482 1.a       0.482        0 ##  5 -0.626      1 a                 1             0.498 1.a       0.498        0 ##  6  0.760      1 a                 1             0.668 1.a       0.668        0 ##  7  0.101      1 a                 1             0.789 1.a       0.789        0 ##  8  1.31       1 a                 1             0.821 1.a       0.821        0 ##  9 -1.35       1 a                 1             0.898 1.a       0.898        0 ## 10 -1.05       1 a                 1             0.935 1.a       0.935        0 ## # ℹ 1,990 more rows graph$add_observations(data = df_adv_grp,                          normalized = TRUE,                          clear_obs = TRUE,                          group = c(\"repl_1\", \"repl_2\"),                         group_sep = \":\") ## Adding observations... graph$get_data() ## # A tibble: 2,000 × 8 ##         y repl_1 repl_2 .edge_number .distance_on_edge .group .coord_x .coord_y ##     <dbl>  <int> <chr>         <dbl>             <dbl> <chr>     <dbl>    <dbl> ##  1  1.15       1 a                 1             0.206 1:a       0.206        0 ##  2 -0.529      1 a                 1             0.266 1:a       0.266        0 ##  3  0.344      1 a                 1             0.386 1:a       0.386        0 ##  4  0.921      1 a                 1             0.482 1:a       0.482        0 ##  5 -0.626      1 a                 1             0.498 1:a       0.498        0 ##  6  0.760      1 a                 1             0.668 1:a       0.668        0 ##  7  0.101      1 a                 1             0.789 1:a       0.789        0 ##  8  1.31       1 a                 1             0.821 1:a       0.821        0 ##  9 -1.35       1 a                 1             0.898 1:a       0.898        0 ## 10 -1.05       1 a                 1             0.935 1:a       0.935        0 ## # ℹ 1,990 more rows graph$plot(data = \"y\", group = \"3:c\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"manipulating-data-from-metric-graphs-in-the-tidyverse-style","dir":"Articles","previous_headings":"","what":"Manipulating data from metric graphs in the tidyverse style","title":"Data manipulation on metric graphs","text":"section present data manipulation tools implemented metric graphs can safely used. tools based dplyr::select(), dplyr::mutate(), dplyr::filter(), dplyr::summarise() tidyr::drop_na(). Let us generate dataset widely used throughout section add metric graph object. Observe replacing existing data setting clear_obs TRUE: Let us look complete data:","code":"df_tidy <- data.frame(y=y, y2 = exp(y), y3 = y^2, y4 = sin(y),        edge_number = obs_loc[,1], distance_on_edge = obs_loc[,2])  # Ordering to simplify presentation with NA data ord_idx <- order(df_tidy[[\"edge_number\"]],                  df_tidy[[\"distance_on_edge\"]]) df_tidy <- df_tidy[ord_idx,]  # Setting some NA data df_tidy[[\"y\"]][1] <- df_tidy[[\"y2\"]][1] <- NA df_tidy[[\"y3\"]][1] <- df_tidy[[\"y4\"]][1] <- NA  df_tidy[[\"y2\"]][2] <- NA df_tidy[[\"y3\"]][3] <- NA  graph$add_observations(data = df_tidy, clear_obs = TRUE, normalized = TRUE) ## Adding observations... graph$get_data(drop_all_na = FALSE) ## # A tibble: 200 × 9 ##         y     y2      y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl>  <dbl>   <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1 NA     NA     NA      NA                1            0.0134      1   0.0134 ##  2  2.09  NA      4.36    0.870            1            0.0233      1   0.0233 ##  3  1.68   5.38  NA       0.994            1            0.0618      1   0.0618 ##  4 -0.528  0.590  0.279  -0.504            1            0.108       1   0.108  ##  5 -0.180  0.836  0.0322 -0.179            1            0.126       1   0.126  ##  6 -0.462  0.630  0.213  -0.445            1            0.177       1   0.177  ##  7 -1.52   0.219  2.31   -0.999            1            0.186       1   0.186  ##  8 -0.655  0.520  0.428  -0.609            1            0.202       1   0.202  ##  9 -0.636  0.530  0.404  -0.594            1            0.206       1   0.206  ## 10  1.34   3.83   1.80    0.974            1            0.212       1   0.212  ## # ℹ 190 more rows ## # ℹ 1 more variable: .coord_y <dbl>"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"select","dir":"Articles","previous_headings":"Manipulating data from metric graphs in the tidyverse style","what":"select","title":"Data manipulation on metric graphs","text":"verb select allows one choose columns keep remove. example, let us select columns y y2 metric graph dataset using select() method: First, observe select verb metric graph friendly since remove columns related spatial locations. Also observe first original row, contains NA removed default. return rows, can set argument .drop_all_na FALSE: , observe second row also contain NA value y2. remove rows contain NA least one variable, can set argument .drop_na TRUE: Moreover, want remove column, can simply use select() method together adding minus sign - front column want removed. example, remove y2, can : Alternatively, can combine select() function output get_data() obtain results: Observe spatial locations columns removed well. avoid removing NA variables, need set argument drop_all_na FALSE using get_data() method: can proceed similarly remove y2: Finally, observe modification dplyr::select() made user-friendly metric graphs, since keeps spatial locations. example, use standard version dplyr::select() result different:","code":"graph$select(y,y2) ## # A tibble: 199 × 7 ##         y     y2 .group .edge_number .distance_on_edge .coord_x .coord_y ##     <dbl>  <dbl>  <dbl>        <dbl>             <dbl>    <dbl>    <dbl> ##  1  2.09  NA          1            1            0.0233   0.0233        0 ##  2  1.68   5.38       1            1            0.0618   0.0618        0 ##  3 -0.528  0.590      1            1            0.108    0.108         0 ##  4 -0.180  0.836      1            1            0.126    0.126         0 ##  5 -0.462  0.630      1            1            0.177    0.177         0 ##  6 -1.52   0.219      1            1            0.186    0.186         0 ##  7 -0.655  0.520      1            1            0.202    0.202         0 ##  8 -0.636  0.530      1            1            0.206    0.206         0 ##  9  1.34   3.83       1            1            0.212    0.212         0 ## 10 -0.620  0.538      1            1            0.266    0.266         0 ## # ℹ 189 more rows graph$select(y, y2, .drop_all_na = FALSE) ## # A tibble: 200 × 7 ##         y     y2 .group .edge_number .distance_on_edge .coord_x .coord_y ##     <dbl>  <dbl>  <dbl>        <dbl>             <dbl>    <dbl>    <dbl> ##  1 NA     NA          1            1            0.0134   0.0134        0 ##  2  2.09  NA          1            1            0.0233   0.0233        0 ##  3  1.68   5.38       1            1            0.0618   0.0618        0 ##  4 -0.528  0.590      1            1            0.108    0.108         0 ##  5 -0.180  0.836      1            1            0.126    0.126         0 ##  6 -0.462  0.630      1            1            0.177    0.177         0 ##  7 -1.52   0.219      1            1            0.186    0.186         0 ##  8 -0.655  0.520      1            1            0.202    0.202         0 ##  9 -0.636  0.530      1            1            0.206    0.206         0 ## 10  1.34   3.83       1            1            0.212    0.212         0 ## # ℹ 190 more rows graph$select(y, y2, .drop_na = TRUE) ## # A tibble: 198 × 7 ##         y    y2 .group .edge_number .distance_on_edge .coord_x .coord_y ##     <dbl> <dbl>  <dbl>        <dbl>             <dbl>    <dbl>    <dbl> ##  1  1.68  5.38       1            1            0.0618   0.0618        0 ##  2 -0.528 0.590      1            1            0.108    0.108         0 ##  3 -0.180 0.836      1            1            0.126    0.126         0 ##  4 -0.462 0.630      1            1            0.177    0.177         0 ##  5 -1.52  0.219      1            1            0.186    0.186         0 ##  6 -0.655 0.520      1            1            0.202    0.202         0 ##  7 -0.636 0.530      1            1            0.206    0.206         0 ##  8  1.34  3.83       1            1            0.212    0.212         0 ##  9 -0.620 0.538      1            1            0.266    0.266         0 ## 10 -0.100 0.905      1            1            0.267    0.267         0 ## # ℹ 188 more rows graph$select(-y2) ## # A tibble: 199 × 8 ##         y      y3     y4 .edge_number .distance_on_edge .group .coord_x .coord_y ##     <dbl>   <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl>    <dbl> ##  1  2.09   4.36    0.870            1            0.0233      1   0.0233        0 ##  2  1.68  NA       0.994            1            0.0618      1   0.0618        0 ##  3 -0.528  0.279  -0.504            1            0.108       1   0.108         0 ##  4 -0.180  0.0322 -0.179            1            0.126       1   0.126         0 ##  5 -0.462  0.213  -0.445            1            0.177       1   0.177         0 ##  6 -1.52   2.31   -0.999            1            0.186       1   0.186         0 ##  7 -0.655  0.428  -0.609            1            0.202       1   0.202         0 ##  8 -0.636  0.404  -0.594            1            0.206       1   0.206         0 ##  9  1.34   1.80    0.974            1            0.212       1   0.212         0 ## 10 -0.620  0.385  -0.581            1            0.266       1   0.266         0 ## # ℹ 189 more rows graph$get_data() %>% select(y,y2) ## # A tibble: 199 × 7 ##         y     y2 .group .edge_number .distance_on_edge .coord_x .coord_y ##     <dbl>  <dbl>  <dbl>        <dbl>             <dbl>    <dbl>    <dbl> ##  1  2.09  NA          1            1            0.0233   0.0233        0 ##  2  1.68   5.38       1            1            0.0618   0.0618        0 ##  3 -0.528  0.590      1            1            0.108    0.108         0 ##  4 -0.180  0.836      1            1            0.126    0.126         0 ##  5 -0.462  0.630      1            1            0.177    0.177         0 ##  6 -1.52   0.219      1            1            0.186    0.186         0 ##  7 -0.655  0.520      1            1            0.202    0.202         0 ##  8 -0.636  0.530      1            1            0.206    0.206         0 ##  9  1.34   3.83       1            1            0.212    0.212         0 ## 10 -0.620  0.538      1            1            0.266    0.266         0 ## # ℹ 189 more rows graph$get_data(drop_all_na = FALSE) %>% select(y,y2) ## # A tibble: 200 × 7 ##         y     y2 .group .edge_number .distance_on_edge .coord_x .coord_y ##     <dbl>  <dbl>  <dbl>        <dbl>             <dbl>    <dbl>    <dbl> ##  1 NA     NA          1            1            0.0134   0.0134        0 ##  2  2.09  NA          1            1            0.0233   0.0233        0 ##  3  1.68   5.38       1            1            0.0618   0.0618        0 ##  4 -0.528  0.590      1            1            0.108    0.108         0 ##  5 -0.180  0.836      1            1            0.126    0.126         0 ##  6 -0.462  0.630      1            1            0.177    0.177         0 ##  7 -1.52   0.219      1            1            0.186    0.186         0 ##  8 -0.655  0.520      1            1            0.202    0.202         0 ##  9 -0.636  0.530      1            1            0.206    0.206         0 ## 10  1.34   3.83       1            1            0.212    0.212         0 ## # ℹ 190 more rows graph$get_data() %>% select(-y2) ## # A tibble: 199 × 8 ##         y      y3     y4 .edge_number .distance_on_edge .group .coord_x .coord_y ##     <dbl>   <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl>    <dbl> ##  1  2.09   4.36    0.870            1            0.0233      1   0.0233        0 ##  2  1.68  NA       0.994            1            0.0618      1   0.0618        0 ##  3 -0.528  0.279  -0.504            1            0.108       1   0.108         0 ##  4 -0.180  0.0322 -0.179            1            0.126       1   0.126         0 ##  5 -0.462  0.213  -0.445            1            0.177       1   0.177         0 ##  6 -1.52   2.31   -0.999            1            0.186       1   0.186         0 ##  7 -0.655  0.428  -0.609            1            0.202       1   0.202         0 ##  8 -0.636  0.404  -0.594            1            0.206       1   0.206         0 ##  9  1.34   1.80    0.974            1            0.212       1   0.212         0 ## 10 -0.620  0.385  -0.581            1            0.266       1   0.266         0 ## # ℹ 189 more rows graph$get_data() %>% dplyr:::select.data.frame(y,y2) ## # A tibble: 199 × 2 ##         y     y2 ##     <dbl>  <dbl> ##  1  2.09  NA     ##  2  1.68   5.38  ##  3 -0.528  0.590 ##  4 -0.180  0.836 ##  5 -0.462  0.630 ##  6 -1.52   0.219 ##  7 -0.655  0.520 ##  8 -0.636  0.530 ##  9  1.34   3.83  ## 10 -0.620  0.538 ## # ℹ 189 more rows"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"filter","dir":"Articles","previous_headings":"Manipulating data from metric graphs in the tidyverse style","what":"filter","title":"Data manipulation on metric graphs","text":"filter verb selects rows based conditions variables. example, let us select variables edge_number 3, distance_on_edge greater 0.5: can plot result using plot() method together newdata argument supply modified dataset:  behavior NA variables exactly select() method. example, can remove rows contain NA variables setting drop_na TRUE: conclude, can also use filter() function top result get_data() method: Let us plot:","code":"filtered_data <- graph$filter(`.edge_number` == 3, `.distance_on_edge` > 0.5) graph$plot(data = \"y\", newdata = filtered_data) graph$filter(y > 1, .drop_na = TRUE) ## # A tibble: 30 × 9 ##        y    y2    y3    y4 .edge_number .distance_on_edge .group .coord_x ##    <dbl> <dbl> <dbl> <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1  1.34  3.83  1.80 0.974            1             0.212      1    0.212 ##  2  1.18  3.24  1.38 0.923            1             0.647      1    0.647 ##  3  1.43  4.19  2.05 0.990            1             0.687      1    0.687 ##  4  1.77  5.85  3.12 0.981            1             0.898      1    0.898 ##  5  2.21  9.08  4.87 0.805            2             0.258      1    0     ##  6  1.00  2.72  1.00 0.841            2             0.316      1    0     ##  7  2.31 10.1   5.33 0.740            2             0.339      1    0     ##  8  2.08  7.97  4.31 0.875            2             0.390      1    0     ##  9  1.87  6.48  3.49 0.956            2             0.407      1    0     ## 10  1.44  4.23  2.08 0.992            2             0.455      1    0     ## # ℹ 20 more rows ## # ℹ 1 more variable: .coord_y <dbl> filtered_data2 <- graph$get_data() %>% filter(y > 1) graph$plot(data = \"y\", newdata = filtered_data2)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"mutate","dir":"Articles","previous_headings":"Manipulating data from metric graphs in the tidyverse style","what":"mutate","title":"Data manipulation on metric graphs","text":"mutate verb creates new columns, modify existing columns, functions existing columns. Let us create new column, new_y, obtained sum y y2: behavior NA data filter() select() methods. example, want keep data, can set .drop_all_na `FALSE: Let us modify variable y3 time remove NA: Finally, can also apply mutate() function result get_data() method, also pipe plot() method (also changing scale discrete):","code":"graph$mutate(new_y = y+y2) ## # A tibble: 199 × 10 ##         y     y2      y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl>  <dbl>   <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1  2.09  NA      4.36    0.870            1            0.0233      1   0.0233 ##  2  1.68   5.38  NA       0.994            1            0.0618      1   0.0618 ##  3 -0.528  0.590  0.279  -0.504            1            0.108       1   0.108  ##  4 -0.180  0.836  0.0322 -0.179            1            0.126       1   0.126  ##  5 -0.462  0.630  0.213  -0.445            1            0.177       1   0.177  ##  6 -1.52   0.219  2.31   -0.999            1            0.186       1   0.186  ##  7 -0.655  0.520  0.428  -0.609            1            0.202       1   0.202  ##  8 -0.636  0.530  0.404  -0.594            1            0.206       1   0.206  ##  9  1.34   3.83   1.80    0.974            1            0.212       1   0.212  ## 10 -0.620  0.538  0.385  -0.581            1            0.266       1   0.266  ## # ℹ 189 more rows ## # ℹ 2 more variables: .coord_y <dbl>, new_y <dbl> graph$mutate(new_y = y+y2, .drop_all_na=FALSE) ## # A tibble: 200 × 10 ##         y     y2      y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl>  <dbl>   <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1 NA     NA     NA      NA                1            0.0134      1   0.0134 ##  2  2.09  NA      4.36    0.870            1            0.0233      1   0.0233 ##  3  1.68   5.38  NA       0.994            1            0.0618      1   0.0618 ##  4 -0.528  0.590  0.279  -0.504            1            0.108       1   0.108  ##  5 -0.180  0.836  0.0322 -0.179            1            0.126       1   0.126  ##  6 -0.462  0.630  0.213  -0.445            1            0.177       1   0.177  ##  7 -1.52   0.219  2.31   -0.999            1            0.186       1   0.186  ##  8 -0.655  0.520  0.428  -0.609            1            0.202       1   0.202  ##  9 -0.636  0.530  0.404  -0.594            1            0.206       1   0.206  ## 10  1.34   3.83   1.80    0.974            1            0.212       1   0.212  ## # ℹ 190 more rows ## # ℹ 2 more variables: .coord_y <dbl>, new_y <dbl> graph$mutate(y3 = ifelse(y>1,1,-1), .drop_na = TRUE) ## # A tibble: 197 × 9 ##         y    y2    y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl> <dbl> <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1 -0.528 0.590    -1 -0.504            1             0.108      1    0.108 ##  2 -0.180 0.836    -1 -0.179            1             0.126      1    0.126 ##  3 -0.462 0.630    -1 -0.445            1             0.177      1    0.177 ##  4 -1.52  0.219    -1 -0.999            1             0.186      1    0.186 ##  5 -0.655 0.520    -1 -0.609            1             0.202      1    0.202 ##  6 -0.636 0.530    -1 -0.594            1             0.206      1    0.206 ##  7  1.34  3.83      1  0.974            1             0.212      1    0.212 ##  8 -0.620 0.538    -1 -0.581            1             0.266      1    0.266 ##  9 -0.100 0.905    -1 -0.100            1             0.267      1    0.267 ## 10 -0.324 0.723    -1 -0.319            1             0.340      1    0.340 ## # ℹ 187 more rows ## # ℹ 1 more variable: .coord_y <dbl> library(ggplot2)  graph$get_data() %>% mutate(new_y = y+y2,                          y3=as.factor(ifelse(y>1,1,-1))) %>%                          graph$plot(data = \"y3\") +                          scale_colour_discrete()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"summarise","dir":"Articles","previous_headings":"Manipulating data from metric graphs in the tidyverse style","what":"summarise","title":"Data manipulation on metric graphs","text":"summarise verb creates summaries selected columns based groupings. metric graphs, groups always include edge number (.edge_number) relative distance edge (.distance_on_edge). using argument .include_graph_groups, internal metric graph group variable, namely .group, also added summarise() group. Finally, additional groups can passed .groups argument. illustrate, use data.frame group example: can see data: Let us summarise data obtaining mean y location across groups: Let us now obtain standard deviation y location plot :","code":"graph$add_observations(data = df_data_repl,                  normalized = TRUE,                  clear_obs = TRUE,                  group = \"repl\") ## Adding observations... graph$get_data() ## # A tibble: 1,000 × 7 ##         y  repl .edge_number .distance_on_edge .group .coord_x .coord_y ##     <dbl> <int>        <dbl>             <dbl> <chr>     <dbl>    <dbl> ##  1  1.50      1            1            0.0134 1        0.0134        0 ##  2 -1.79      1            1            0.0233 1        0.0233        0 ##  3  0.488     1            1            0.0618 1        0.0618        0 ##  4 -0.385     1            1            0.108  1        0.108         0 ##  5  0.905     1            1            0.126  1        0.126         0 ##  6 -0.145     1            1            0.177  1        0.177         0 ##  7  2.00      1            1            0.186  1        0.186         0 ##  8 -1.16      1            1            0.202  1        0.202         0 ##  9  0.879     1            1            0.206  1        0.206         0 ## 10 -0.816     1            1            0.212  1        0.212         0 ## # ℹ 990 more rows graph$summarise(mean_y = mean(y)) ## # A tibble: 200 × 6 ##    .edge_number .distance_on_edge .coord_x .coord_y  mean_y .group ##           <dbl>             <dbl>    <dbl>    <dbl>   <dbl>  <dbl> ##  1            1            0.0134   0.0134        0  0.578       1 ##  2            1            0.0233   0.0233        0  0.407       1 ##  3            1            0.0618   0.0618        0  0.638       1 ##  4            1            0.108    0.108         0 -0.327       1 ##  5            1            0.126    0.126         0 -0.942       1 ##  6            1            0.177    0.177         0 -0.156       1 ##  7            1            0.186    0.186         0  0.0925      1 ##  8            1            0.202    0.202         0 -0.0548      1 ##  9            1            0.206    0.206         0  0.345       1 ## 10            1            0.212    0.212         0 -0.546       1 ## # ℹ 190 more rows graph$summarise(sd_y = sd(y)) %>% graph$plot(data = \"sd_y\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"drop_na","dir":"Articles","previous_headings":"Manipulating data from metric graphs in the tidyverse style","what":"drop_na","title":"Data manipulation on metric graphs","text":"drop_na verb removes rows contain NA selected columns. illustrate, let us add df_tidy back metric graph, replacing existing dataset: Now, let us take look dataset: example, let us remove rows y3 NA, simply apply drop_na() method passing column y3: can also remove rows either y2 y3 NA: simply run drop_na() method, equivalent run get_data() method argument drop_na set TRUE: Finally, can also directly apply drop_na() function result get_data() method:","code":"graph$add_observations(data = df_tidy, clear_obs=TRUE, normalized=TRUE) ## Adding observations... graph$get_data(drop_all_na = FALSE) ## # A tibble: 200 × 9 ##         y     y2      y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl>  <dbl>   <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1 NA     NA     NA      NA                1            0.0134      1   0.0134 ##  2  2.09  NA      4.36    0.870            1            0.0233      1   0.0233 ##  3  1.68   5.38  NA       0.994            1            0.0618      1   0.0618 ##  4 -0.528  0.590  0.279  -0.504            1            0.108       1   0.108  ##  5 -0.180  0.836  0.0322 -0.179            1            0.126       1   0.126  ##  6 -0.462  0.630  0.213  -0.445            1            0.177       1   0.177  ##  7 -1.52   0.219  2.31   -0.999            1            0.186       1   0.186  ##  8 -0.655  0.520  0.428  -0.609            1            0.202       1   0.202  ##  9 -0.636  0.530  0.404  -0.594            1            0.206       1   0.206  ## 10  1.34   3.83   1.80    0.974            1            0.212       1   0.212  ## # ℹ 190 more rows ## # ℹ 1 more variable: .coord_y <dbl> graph$drop_na(y3) ## # A tibble: 198 × 9 ##         y     y2     y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl>  <dbl>  <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1  2.09  NA     4.36    0.870            1            0.0233      1   0.0233 ##  2 -0.528  0.590 0.279  -0.504            1            0.108       1   0.108  ##  3 -0.180  0.836 0.0322 -0.179            1            0.126       1   0.126  ##  4 -0.462  0.630 0.213  -0.445            1            0.177       1   0.177  ##  5 -1.52   0.219 2.31   -0.999            1            0.186       1   0.186  ##  6 -0.655  0.520 0.428  -0.609            1            0.202       1   0.202  ##  7 -0.636  0.530 0.404  -0.594            1            0.206       1   0.206  ##  8  1.34   3.83  1.80    0.974            1            0.212       1   0.212  ##  9 -0.620  0.538 0.385  -0.581            1            0.266       1   0.266  ## 10 -0.100  0.905 0.0100 -0.100            1            0.267       1   0.267  ## # ℹ 188 more rows ## # ℹ 1 more variable: .coord_y <dbl> graph$drop_na(y2, y3) ## # A tibble: 197 × 9 ##         y    y2     y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl> <dbl>  <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1 -0.528 0.590 0.279  -0.504            1             0.108      1    0.108 ##  2 -0.180 0.836 0.0322 -0.179            1             0.126      1    0.126 ##  3 -0.462 0.630 0.213  -0.445            1             0.177      1    0.177 ##  4 -1.52  0.219 2.31   -0.999            1             0.186      1    0.186 ##  5 -0.655 0.520 0.428  -0.609            1             0.202      1    0.202 ##  6 -0.636 0.530 0.404  -0.594            1             0.206      1    0.206 ##  7  1.34  3.83  1.80    0.974            1             0.212      1    0.212 ##  8 -0.620 0.538 0.385  -0.581            1             0.266      1    0.266 ##  9 -0.100 0.905 0.0100 -0.100            1             0.267      1    0.267 ## 10 -0.324 0.723 0.105  -0.319            1             0.340      1    0.340 ## # ℹ 187 more rows ## # ℹ 1 more variable: .coord_y <dbl> identical(graph$drop_na(), graph$get_data(drop_na=TRUE)) ## [1] TRUE graph$get_data(drop_all_na = FALSE) %>% drop_na(y3) ## # A tibble: 198 × 9 ##         y     y2     y3     y4 .edge_number .distance_on_edge .group .coord_x ##     <dbl>  <dbl>  <dbl>  <dbl>        <dbl>             <dbl>  <dbl>    <dbl> ##  1  2.09  NA     4.36    0.870            1            0.0233      1   0.0233 ##  2 -0.528  0.590 0.279  -0.504            1            0.108       1   0.108  ##  3 -0.180  0.836 0.0322 -0.179            1            0.126       1   0.126  ##  4 -0.462  0.630 0.213  -0.445            1            0.177       1   0.177  ##  5 -1.52   0.219 2.31   -0.999            1            0.186       1   0.186  ##  6 -0.655  0.520 0.428  -0.609            1            0.202       1   0.202  ##  7 -0.636  0.530 0.404  -0.594            1            0.206       1   0.206  ##  8  1.34   3.83  1.80    0.974            1            0.212       1   0.212  ##  9 -0.620  0.538 0.385  -0.581            1            0.266       1   0.266  ## 10 -0.100  0.905 0.0100 -0.100            1            0.267       1   0.267  ## # ℹ 188 more rows ## # ℹ 1 more variable: .coord_y <dbl>"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"combining-multiple-verbs","dir":"Articles","previous_headings":"Manipulating data from metric graphs in the tidyverse style","what":"Combining multiple verbs","title":"Data manipulation on metric graphs","text":"resulting data applying previous verbs safe sense friendly metric graph environment. Thus, result applying one verb can used input remaining verbs. example consider df_data_repl dataset. Let us add graph (replacing existing data): now create new variable new_y exponential y, filter data edges 1 2, summarise get means new_y positions (across different groups, _.group variable) plot :","code":"graph$add_observations(data = df_data_repl,                          normalized = TRUE,                          clear_obs = TRUE,                          group = \"repl\") ## Adding observations... graph$get_data(drop_all_na = FALSE) ## # A tibble: 1,000 × 7 ##         y  repl .edge_number .distance_on_edge .group .coord_x .coord_y ##     <dbl> <int>        <dbl>             <dbl> <chr>     <dbl>    <dbl> ##  1  1.50      1            1            0.0134 1        0.0134        0 ##  2 -1.79      1            1            0.0233 1        0.0233        0 ##  3  0.488     1            1            0.0618 1        0.0618        0 ##  4 -0.385     1            1            0.108  1        0.108         0 ##  5  0.905     1            1            0.126  1        0.126         0 ##  6 -0.145     1            1            0.177  1        0.177         0 ##  7  2.00      1            1            0.186  1        0.186         0 ##  8 -1.16      1            1            0.202  1        0.202         0 ##  9  0.879     1            1            0.206  1        0.206         0 ## 10 -0.816     1            1            0.212  1        0.212         0 ## # ℹ 990 more rows graph$mutate(new_y = exp(y)) %>% filter(`.edge_number` %in% c(1,2)) %>%              summarise(mean_new_y = mean(new_y)) %>%              graph$plot(data = \"mean_new_y\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/metric_graph_data.html","id":"replacing-the-data-in-the-metric-graph-by-manipulated-data","dir":"Articles","previous_headings":"","what":"Replacing the data in the metric graph by manipulated data","title":"Data manipulation on metric graphs","text":"Let us suppose want replace internal data data obtained manipulations. simple, need pass resulting data data argument add_observations() method. important note input result verbs, mutate, select, filter, summarise drop_na, combination , need set arguments add_observations() method, one simply supply data argument dataset. example, let us consider dataset previous section. replace data, set clear_obs TRUE: can now observe result: can also save separate variable use input: can check properly added:","code":"graph$add_observations(data = graph$mutate(new_y = exp(y)) %>%                          filter(`.edge_number` %in% c(1,2)) %>%                                  summarise(mean_new_y = mean(new_y)),                                 clear_obs = TRUE) ## Adding observations... graph$get_data() ## # A tibble: 100 × 6 ##    .coord_x .coord_y mean_new_y .edge_number .distance_on_edge .group ##       <dbl>    <dbl>      <dbl>        <dbl>             <dbl> <chr>  ##  1   0.0134        0      3.15             1            0.0134 1      ##  2   0.0233        0      2.43             1            0.0233 1      ##  3   0.0618        0      1.92             1            0.0618 1      ##  4   0.108         0      0.931            1            0.108  1      ##  5   0.126         0      0.814            1            0.126  1      ##  6   0.177         0      0.968            1            0.177  1      ##  7   0.186         0      2.40             1            0.186  1      ##  8   0.202         0      1.24             1            0.202  1      ##  9   0.206         0      2.60             1            0.206  1      ## 10   0.212         0      0.643            1            0.212  1      ## # ℹ 90 more rows df_temp <- graph$mutate(even_newer_y = mean_new_y^2) graph$add_observations(data = df_temp, clear_obs = TRUE) ## Adding observations... graph$get_data() ## # A tibble: 100 × 7 ##    .coord_x .coord_y mean_new_y even_newer_y .edge_number .distance_on_edge ##       <dbl>    <dbl>      <dbl>        <dbl>        <dbl>             <dbl> ##  1   0.0134        0      3.15         9.90             1            0.0134 ##  2   0.0233        0      2.43         5.89             1            0.0233 ##  3   0.0618        0      1.92         3.69             1            0.0618 ##  4   0.108         0      0.931        0.867            1            0.108  ##  5   0.126         0      0.814        0.663            1            0.126  ##  6   0.177         0      0.968        0.937            1            0.177  ##  7   0.186         0      2.40         5.76             1            0.186  ##  8   0.202         0      1.24         1.53             1            0.202  ##  9   0.206         0      2.60         6.73             1            0.206  ## 10   0.212         0      0.643        0.413            1            0.212  ## # ℹ 90 more rows ## # ℹ 1 more variable: .group <chr>"},{"path":"https://davidbolin.github.io/MetricGraph/articles/multi_likelihood.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"An example with multiple likelihoods in INLA and inlabru","text":"vignette show fit model multiple likelihoods INLA inlabru implementations. consider following model: \\[Y_{1i} = \\beta_1 + u(s_i) + \\varepsilon_{1i},\\] \\[Y_{2i} = \\beta_2 + u(s_i) + \\varepsilon_{2i},\\] \\(s_1,\\ldots,s_n\\) locations compact metric graph \\(\\Gamma\\), \\(u(\\cdot)\\) Whittle–Matérn field alpha=1, \\(=1,\\ldots,n\\), \\(\\epsilon_{11},\\ldots, \\epsilon_{1n}\\) ..d. random variables following \\(N(0, \\sigma_1^2)\\), \\(\\epsilon_{21}, \\ldots, \\epsilon_{2n}\\) ..d. random variables following \\(N(0,\\sigma_2^2)\\), finally, take \\(n=400\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/multi_likelihood.html","id":"a-toy-dataset","dir":"Articles","previous_headings":"","what":"A toy dataset","title":"An example with multiple likelihoods in INLA and inlabru","text":"start generating dataset. Let us load MetricGraph package create metric graph: Let us add 100 random locations edge observations: now sample observation locations plot latent field:  Let us now generate observed responses likelihoods, call, respectively, y1 y2. also plot observed responses metric graph. Let us plot observations y1:  y2:","code":"library(MetricGraph)  edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 20) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph <- metric_graph$new(edges = edges) obs_per_edge <- 100 obs_loc <- NULL for(i in 1:(graph$nE)) {   obs_loc <- rbind(obs_loc,                    cbind(rep(i,obs_per_edge),                     runif(obs_per_edge))) } sigma <- 2 alpha <- 1 nu <- alpha - 0.5 r <- 0.15 # r stands for range  u <- sample_spde(range = r, sigma = sigma, alpha = alpha,                  graph = graph, PtE = obs_loc) graph$plot(X = u, X_loc = obs_loc) beta1 = 2 beta2 = -2 n_obs <- length(u) sigma1.e <- 0.2 sigma2.e <- 0.5  y1 <- beta1 + u + sigma1.e * rnorm(n_obs) y2 <- beta2 + u + sigma2.e * rnorm(n_obs) graph$plot(X = y1, X_loc = obs_loc) graph$plot(X = y2, X_loc = obs_loc)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/multi_likelihood.html","id":"fitting-models-with-multiple-likelihoods-in-r-inla","dir":"Articles","previous_headings":"","what":"Fitting models with multiple likelihoods in R-INLA","title":"An example with multiple likelihoods in INLA and inlabru","text":"now position fit model R-INLA implementation. end, need add observations graph, add_observations() method. create column data.frame indicate likelihood observed variable belongs . also intercepts columns. Let us now add observations set likelihood column group:  Now, load R-INLA package create inla model object graph_spde function. default alpha=1. Now, need create data object graph_data_spde() function, need provide name random effect, call field, need provide covariates. also need pass column contains number likelihood data remaining standard R-INLA. create formula object inla.stack objects inla.stack() function. Let us start creating formula: Let us now create inla.stack objects, one likelihood. end, simply supply data data_spde obtained using graph_data_spde: Now, use inla.stack.data(): Finally, fit model: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: Let us now look estimates measurement errors compare true ones: Finally, let us look estimates intercepts:","code":"df_graph1 <- data.frame(y = y1, intercept_1 = 1, intercept_2 = NA,                         edge_number = obs_loc[,1],                         distance_on_edge = obs_loc[,2],                         likelihood = 1) df_graph2 <- data.frame(y = y2, intercept_1 = NA,                         intercept_2 = 1,                         edge_number = obs_loc[,1],                         distance_on_edge = obs_loc[,2],                         likelihood = 2)       df_graph <- rbind(df_graph1, df_graph2) graph$add_observations(data=df_graph, normalized=TRUE, group = \"likelihood\") graph$plot(data=\"y\") library(INLA) spde_model <- graph_spde(graph) data_spde <- graph_data_spde(graph_spde = spde_model,                  name = \"field\", likelihood_col = \"likelihood\",                 resp_col = \"y\",                 covariates = c(\"intercept_1\", \"intercept_2\")) f.s <- y ~ -1 + f(intercept_1, model = \"linear\") +          f(intercept_2, model = \"linear\") +          f(field, model = spde_model) stk_dat1 <- inla.stack(data = data_spde[[1]][[\"data\"]],                          A = data_spde[[1]][[\"basis\"]],                          effects = data_spde[[1]][[\"index\"]]     ) stk_dat2 <- inla.stack(data = data_spde[[2]][[\"data\"]],                          A = data_spde[[2]][[\"basis\"]],                          effects = data_spde[[2]][[\"index\"]]     ) stk_dat <- inla.stack(stk_dat1, stk_dat2) data_stk <- inla.stack.data(stk_dat) spde_fit <- inla(f.s, family = c(\"gaussian\", \"gaussian\"),      data = data_stk, control.predictor=list(A=inla.stack.A(stk_dat))) spde_result <- spde_metric_graph_result(spde_fit, \"field\", spde_model)  summary(spde_result) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.937610 0.1793230  1.6152800 1.926400   2.316060 1.889680 ## range 0.134472 0.0270122  0.0907363 0.131179   0.196442 0.124442 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_result$summary.sigma$mean,       spde_result$summary.range$mean     ),     mode = c(       spde_result$summary.sigma$mode,       spde_result$summary.range$mode     )   )   print(result_df) ##   parameter true      mean      mode ## 1   std.dev 2.00 1.9376053 1.8896834 ## 2     range 0.15 0.1344716 0.1244416 meas_err_df <- data.frame(     parameter = c(\"sigma1.e\", \"sigma2.e\"),     true = c(sigma1.e, sigma2.e),     mean = sqrt(1/spde_fit$summary.hyperpar$mean[1:2]),     mode = sqrt(1/spde_fit$summary.hyperpar$mode[1:2])   ) print(meas_err_df) ##   parameter true      mean      mode ## 1  sigma1.e  0.2 0.2231564 0.2379985 ## 2  sigma2.e  0.5 0.4963884 0.4986200 intercept_df <- data.frame(     parameter = c(\"beta1\", \"beta2\"),     true = c(beta1, beta2),     mean = spde_fit$summary.fixed$mean,     mode = spde_fit$summary.fixed$mode   ) print(intercept_df) ##   parameter true      mean      mode ## 1     beta1    2  2.083174  2.083395 ## 2     beta2   -2 -1.919985 -1.919765"},{"path":"https://davidbolin.github.io/MetricGraph/articles/multi_likelihood.html","id":"fitting-models-with-multiple-likelihoods-in-inlabru","dir":"Articles","previous_headings":"","what":"Fitting models with multiple likelihoods in inlabru","title":"An example with multiple likelihoods in INLA and inlabru","text":"section recall objects spde_model obtained . Let us create new data object. Observe inlabru need provide covariates argument. begin loading inlabru library setting likelihoods. end, use first entry data_spde_bru supply data first likelihood, second entry supply data second likelihood. Now, create model component: , fit model: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: Let us now look estimates measurement errors compare true ones: Finally, let us look estimates intercepts:","code":"data_spde_bru <- graph_data_spde(graph_spde = spde_model,                  name = \"field\", likelihood_col = \"likelihood\",                 resp_col = \"y\", loc_name = \"loc\") library(inlabru) ## Loading required package: fmesher lik1 <- like(formula = y ~ intercept_1 + field,             data=data_spde_bru[[1]][[\"data\"]])  lik2 <- like(formula = y ~ intercept_2 + field,             data=data_spde_bru[[2]][[\"data\"]]) cmp <-  ~ -1 + intercept_1(intercept_1) +          intercept_2(intercept_2) +          field(loc, model = spde_model) spde_bru_fit <-  bru(cmp, lik1, lik2) spde_bru_result <- spde_metric_graph_result(spde_bru_fit, \"field\", spde_model)  summary(spde_bru_result) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.937710 0.1751650  1.6211700 1.926650   2.311370 1.886870 ## range 0.134497 0.0271169  0.0905475 0.131211   0.196666 0.124504 result_bru_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, r),     mean = c(       spde_bru_result$summary.sigma$mean,       spde_bru_result$summary.range$mean     ),     mode = c(       spde_bru_result$summary.sigma$mode,       spde_bru_result$summary.range$mode     )   )   print(result_bru_df) ##   parameter true      mean      mode ## 1   std.dev 2.00 1.9377084 1.8868661 ## 2     range 0.15 0.1344971 0.1245042 meas_err_bru_df <- data.frame(     parameter = c(\"sigma1.e\", \"sigma2.e\"),     true = c(sigma1.e, sigma2.e),     mean = sqrt(1/spde_bru_fit$summary.hyperpar$mean[1:2]),     mode = sqrt(1/spde_bru_fit$summary.hyperpar$mode[1:2])   ) print(meas_err_bru_df) ##   parameter true      mean      mode ## 1  sigma1.e  0.2 0.2231594 0.2379820 ## 2  sigma2.e  0.5 0.4963947 0.4985708 intercept_df <- data.frame(     parameter = c(\"beta1\", \"beta2\"),     true = c(beta1, beta2),     mean = spde_bru_fit$summary.fixed$mean,     mode = spde_bru_fit$summary.fixed$mode   ) print(intercept_df) ##   parameter true      mean      mode ## 1     beta1    2  2.083166  2.083389 ## 2     beta2   -2 -1.919993 -1.919771"},{"path":"https://davidbolin.github.io/MetricGraph/articles/multi_likelihood.html","id":"a-toy-dataset-with-multiple-likelihoods-and-replicates","dir":"Articles","previous_headings":"","what":"A toy dataset with multiple likelihoods and replicates","title":"An example with multiple likelihoods in INLA and inlabru","text":"Let us now proceed similarly, now consider case multiple likelihoods replicates. simplify exposition, use base graph. , begin clearing observations. use observation locations previous cases. Let us sample 10 replicates: Let us now generate observed responses, call y_rep.","code":"graph$clear_observations() sigma_rep <- 1.5 alpha_rep <- 1 nu_rep <- alpha_rep - 0.5 r_rep <- 0.2 # r stands for range kappa_rep <- sqrt(8 * nu_rep) / r_rep  n_repl <- 10  u_rep <- sample_spde(range = r_rep, sigma = sigma_rep,                  alpha = alpha_rep,                  graph = graph, PtE = obs_loc,                  nsim = n_repl) beta1 = 2 beta2 = -2  sigma1.e <- 0.2 sigma2.e <- 0.5  n_obs_rep <- nrow(u_rep)  y1_rep <- beta1 + u_rep + sigma1.e * matrix(rnorm(n_obs_rep * n_repl),                                     ncol=n_repl)      y2_rep <- beta2 + u_rep + sigma2.e * matrix(rnorm(n_obs_rep * n_repl),                                     ncol=n_repl)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/multi_likelihood.html","id":"fitting-the-model-with-multiple-likelihoods-and-replicates-in-r-inla","dir":"Articles","previous_headings":"","what":"Fitting the model with multiple likelihoods and replicates in R-INLA","title":"An example with multiple likelihoods in INLA and inlabru","text":"sample_spde() function returns matrix replicate column. need stack columns together column indicate replicat. , need likelihood: now join : can now add observations setting group argument c(\"repl\", \"likelihood\"): Let us now create model object: Let us first consider case use replicates. , consider case use replicates. Thus, let us assume want consider replicates 1, 3, 5, 7 9. end, index object using graph_data_spde() function argument repl set replicates want, case c(1,3,5,7,9). Observe need pass repl_col, internal grouping variable replicate variable. Next, create stack objects, remembering need input components data_spde likelihood: now create formula object, adding name field (case field) attached .repl replicate argument inside f() function. , create stack object inla.stack.data() function: Now, fit model: Let us see estimated values original scale: Let us compare true values: Let us now look estimates measurement errors compare true ones: Finally, let us look estimates intercepts:","code":"dl1_graph <- lapply(1:ncol(y1_rep), function(i){data.frame(y = y1_rep[,i],                                           edge_number = obs_loc[,1],                                           distance_on_edge = obs_loc[,2],                                           likelihood = 1,                                           intercept_1 = 1,                                           intercept_2 = NA,                                           repl = i)}) dl1_graph <- do.call(rbind, dl1_graph) dl2_graph <- lapply(1:ncol(y2_rep), function(i){data.frame(y = y2_rep[,i],                                           edge_number = obs_loc[,1],                                           distance_on_edge = obs_loc[,2],                                           likelihood = 2,                                           intercept_1 = NA,                                           intercept_2 = 1,                                           repl = i)}) dl2_graph <- do.call(rbind, dl2_graph) dl_graph <- rbind(dl1_graph, dl2_graph) graph$add_observations(data = dl_graph, normalized=TRUE,                              group = c(\"repl\", \"likelihood\"),                             edge_number = \"edge_number\",                             distance_on_edge = \"distance_on_edge\") spde_model_rep <- graph_spde(graph) data_spde_repl <- graph_data_spde(graph_spde=spde_model_rep,                       name=\"field\", repl = c(1,3,5,7,9), repl_col = \"repl\",                        likelihood_col = \"likelihood\", resp_col = \"y\",                       covariates = c(\"intercept_1\", \"intercept_2\")) stk_dat_rep1 <- inla.stack(data = data_spde_repl[[1]][[\"data\"]],                          A = data_spde_repl[[1]][[\"basis\"]],                          effects = data_spde_repl[[1]][[\"index\"]]     ) stk_dat_rep2 <- inla.stack(data = data_spde_repl[[2]][[\"data\"]],                          A = data_spde_repl[[2]][[\"basis\"]],                          effects = data_spde_repl[[2]][[\"index\"]]     )  stk_dat_rep <- inla.stack(stk_dat_rep1, stk_dat_rep2) f_s_rep <- y ~ -1 + intercept_1 + intercept_2 +      f(field, model = spde_model_rep,          replicate = field.repl) data_stk_rep <- inla.stack.data(stk_dat_rep) spde_fit_rep <- inla(f_s_rep, family = c(\"gaussian\", \"gaussian\"),                  data = data_stk_rep,                  control.predictor=list(A=inla.stack.A(stk_dat_rep))) spde_result_rep <- spde_metric_graph_result(spde_fit_rep,                          \"field\", spde_model_rep)  summary(spde_result_rep) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.490560 0.0714894   1.358820 1.488090   1.638960 1.492110 ## range 0.197454 0.0205546   0.160823 0.196092   0.241429 0.193212 result_df_rep <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_result_rep$summary.sigma$mean,       spde_result_rep$summary.range$mean     ),     mode = c(       spde_result_rep$summary.sigma$mode,       spde_result_rep$summary.range$mode     )   )   print(result_df_rep) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.4905624 1.4921103 ## 2     range  0.2 0.1974539 0.1932121 meas_err_df <- data.frame(     parameter = c(\"sigma1.e\", \"sigma2.e\"),     true = c(sigma1.e, sigma2.e),     mean = sqrt(1/spde_fit_rep$summary.hyperpar$mean[1:2]),     mode = sqrt(1/spde_fit_rep$summary.hyperpar$mode[1:2])   ) print(meas_err_df) ##   parameter true      mean      mode ## 1  sigma1.e  0.2 0.1935081 0.1946181 ## 2  sigma2.e  0.5 0.4886450 0.4891630 intercept_df <- data.frame(     parameter = c(\"beta1\", \"beta2\"),     true = c(beta1, beta2),     mean = spde_fit_rep$summary.fixed$mean,     mode = spde_fit_rep$summary.fixed$mode   ) print(intercept_df) ##   parameter true      mean      mode ## 1     beta1    2  1.846546  1.846466 ## 2     beta2   -2 -2.156743 -2.156823"},{"path":"https://davidbolin.github.io/MetricGraph/articles/multi_likelihood.html","id":"fitting-models-with-multiple-likelihoods-and-replicates-in-inlabru","dir":"Articles","previous_headings":"","what":"Fitting models with multiple likelihoods and replicates in inlabru","title":"An example with multiple likelihoods in INLA and inlabru","text":"section recall objects spde_model_rep obtained . Let us create new data object: Let us obtain repl indexes data_spde_bru_repl object: Let us now construct likelihoods: Now, create model component, using replicates index obtained : , fit model: Let us now obtain estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: Let us now look estimates measurement errors compare true ones: Finally, let us look estimbates intercepts:","code":"data_spde_bru_repl <- graph_data_spde(graph_spde = spde_model_rep,                  name=\"field\", loc_name = \"loc\",                  repl = c(1,3,5,7,9), repl_col = \"repl\",                  likelihood_col = \"likelihood\", resp_col = \"y\") repl <- data_spde_bru_repl[[\"repl\"]] lik1_repl <- like(formula = y ~ intercept_1 + field,             data=data_spde_bru_repl[[1]][[\"data\"]])  lik2_repl <- like(formula = y ~ intercept_2 + field,             data=data_spde_bru_repl[[2]][[\"data\"]]) cmp_repl <-  ~ -1 + intercept_1(intercept_1) +          intercept_2(intercept_2) +          field(loc, model = spde_model_rep, replicate = repl) spde_bru_fit_repl <-  bru(cmp_repl, lik1_repl, lik2_repl) spde_bru_result_repl <- spde_metric_graph_result(spde_bru_fit_repl, \"field\", spde_model_rep)  summary(spde_bru_result_repl) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## sigma 1.489800 0.0723742    1.35400 1.487260   1.639630 1.482470 ## range 0.197289 0.0205155    0.16059 0.196029   0.241065 0.193353 result_bru_repl_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma_rep, r_rep),     mean = c(       spde_bru_result_repl$summary.sigma$mean,       spde_bru_result_repl$summary.range$mean     ),     mode = c(       spde_bru_result_repl$summary.sigma$mode,       spde_bru_result_repl$summary.range$mode     )   )   print(result_bru_repl_df) ##   parameter true      mean      mode ## 1   std.dev  1.5 1.4898015 1.4824750 ## 2     range  0.2 0.1972894 0.1933532 meas_err_bru_repl_df <- data.frame(     parameter = c(\"sigma1.e\", \"sigma2.e\"),     true = c(sigma1.e, sigma2.e),     mean = sqrt(1/spde_bru_fit_repl$summary.hyperpar$mean[1:2]),     mode = sqrt(1/spde_bru_fit_repl$summary.hyperpar$mode[1:2])   ) print(meas_err_bru_repl_df) ##   parameter true      mean      mode ## 1  sigma1.e  0.2 0.1935666 0.1949572 ## 2  sigma2.e  0.5 0.4885651 0.4890156 intercept_repl_df <- data.frame(     parameter = c(\"beta1\", \"beta2\"),     true = c(beta1, beta2),     mean = spde_bru_fit_repl$summary.fixed$mean,     mode = spde_bru_fit_repl$summary.fixed$mode   ) print(intercept_repl_df) ##   parameter true      mean      mode ## 1     beta1    2  1.846548  1.846469 ## 2     beta2   -2 -2.156741 -2.156820"},{"path":"https://davidbolin.github.io/MetricGraph/articles/pointprocess.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Log-Gaussian Cox processes on metric graphs","text":"vignette introduce work log-Gaussian Cox processes based Whittle–Matérn fields metric graphs. simplify integration R-INLA inlabru hese models constructed using finite element approximations implemented rSPDE package. theoretical details given forthcoming article (Bolin, Simas, Wallin 2023).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/pointprocess.html","id":"constructing-the-graph-and-the-mesh","dir":"Articles","previous_headings":"","what":"Constructing the graph and the mesh","title":"Log-Gaussian Cox processes on metric graphs","text":"begin loading rSPDE, MetricGraph INLA packages: example, consider default graph package:  construct FEM approximation Whittle–Matérn field, must first construct mesh graph.  next step build mass stiffness matrices FEM basis. now ready specify sample log-Gaussian Cox process model intensity \\(\\lambda = \\exp(\\beta + u)\\) \\(\\beta\\) intercept \\(u\\) Gaussian Whittle–Matérn field specified \\[ (\\kappa^2 - \\Delta)^{\\alpha/2} \\tau u = \\mathcal{W}. \\] can use function graph_lgcp follows: object returned function list simulated Gaussian process points graph. can plot simulated intensity function  plot simulated points, can add graph plot:","code":"library(rSPDE) library(MetricGraph) library(INLA) graph <- metric_graph$new(tolerance = list(vertex_vertex = 1e-1, vertex_edge = 1e-3, edge_edge = 1e-3),                           remove_deg2 = TRUE) graph$plot() graph$build_mesh(h = 0.1) graph$plot(mesh=TRUE) graph$compute_fem() sigma <- 0.5   range <- 2   alpha <- 2   lgcp_sample <- graph_lgcp(intercept = 1, sigma = sigma,                             range = range, alpha = alpha,                             graph = graph) graph$plot_function(X = exp(lgcp_sample$u), vertex_size = 0) graph$add_observations(data = data.frame(y=rep(1,length(lgcp_sample$edge_loc)),                                          edge_number = lgcp_sample$edge_numbers,                                          distance_on_edge = lgcp_sample$edge_loc),                        normalized = TRUE) ## Adding observations... graph$plot(vertex_size = 0, data = \"y\")"},{"path":"https://davidbolin.github.io/MetricGraph/articles/pointprocess.html","id":"fitting-lgcp-models-in-r-inla","dir":"Articles","previous_headings":"","what":"Fitting LGCP models in R-INLA","title":"Log-Gaussian Cox processes on metric graphs","text":"now position fit model R-INLA implementation. working log-Gaussian Cox processes, likelihood term \\(\\int_\\Gamma \\exp(u(s)) ds\\) needs handled separately. done using mid-point rule suggested SPDE models Simpson et al. approximate \\[ \\int_\\Gamma \\exp(u(s)) ds \\approx \\sum_{=1}^p \\widetilde{}_i \\exp\\left(u(\\widetilde{s}_i)\\right). \\] Using fact \\(u(s) = \\sum_{j=1}^n \\varphi(s) u_i\\) FEM approximation, can write integral \\(\\widetilde{\\alpha}^T\\exp(\\widetilde{}u)\\) \\(\\widetilde{}_{ij} = \\varphi_j(\\widetilde{s}_i)\\) \\(\\widetilde{}\\) vector integration weights. quantities can obtained weights used exposure terms Poisson likelihiood R-INLA. , easiest way construct model add integration points zero observations graph, corresponding exposure weights. also need add exposure terms (zero) actual observation locations: now create inla model object graph_spde function. simplicity, assume \\(\\alpha\\) known fixed true value model. Next, compute auxiliary data: now create inla.stack object inla.stack() function. stage, important data added graph since supplied stack using graph_spde_data() function. can now fit model using R-INLA: Let us extract estimates original scale using spde_metric_graph_result() function, taking summary(): now compare means estimated values true values: can also plot posterior marginal densities help gg_df() function:  Finally, can plot estimated field \\(u\\):  can compared field used generate data:","code":"Atilde <- graph$fem_basis(graph$mesh$VtE) atilde <- graph$mesh$weights #clear the previous data in the graph graph$clear_observations()  #Add the data together with the exposure terms graph$add_observations(data = data.frame(y = rep(1,length(lgcp_sample$edge_loc)),                                          e = rep(0,length(lgcp_sample$edge_loc)),                                          edge_number = lgcp_sample$edge_number,                                          distance_on_edge = lgcp_sample$edge_loc),                        normalized = TRUE) ## Adding observations... #Add integration points graph$add_observations(data = data.frame(y = rep(0,length(atilde)),                                          e = atilde,                                          edge_number = graph$mesh$VtE[,1],                                          distance_on_edge = graph$mesh$VtE[,2]),                        normalized = TRUE) ## Adding observations... rspde_model <- rspde.metric_graph(graph, nu = alpha - 1/2) data_rspde <- graph_data_rspde(rspde_model, name=\"field\") stk <- inla.stack(data = data_rspde[[\"data\"]],                    A = data_rspde[[\"basis\"]],                    effects = c(data_rspde[[\"index\"]], list(Intercept = 1))) spde_fit <- inla(y ~ -1 + Intercept + f(field, model = rspde_model),                   family = \"poisson\", data = inla.stack.data(stk),                  control.predictor = list(A = inla.stack.A(stk), compute = TRUE),                  E = inla.stack.data(stk)$e) spde_result <- rspde.result(spde_fit, \"field\", rspde_model)  summary(spde_result) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.365505 0.0982023   0.197950 0.358244    0.57945 0.343971 ## range   2.081110 0.9192960   0.845334 1.894760    4.39442 1.576910 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, range),     mean = c(       spde_result$summary.std.dev$mean,       spde_result$summary.range$mean     ),     mode = c(       spde_result$summary.std.dev$mode,       spde_result$summary.range$mode     )   )   print(result_df) ##   parameter true      mean      mode ## 1   std.dev  0.5 0.3655054 0.3439713 ## 2     range  2.0 2.0811115 1.5769052 posterior_df_fit <- gg_df(spde_result)    library(ggplot2)    ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +    facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\") n.obs <- length(graph$get_data()$y) n.field <- dim(graph$mesh$VtE)[1] u_posterior <- spde_fit$summary.linear.predictor$mean[(n.obs+1):(n.obs+n.field)] graph$plot_function(X = u_posterior, vertex_size = 0) graph$plot_function(X = lgcp_sample$u, vertex_size = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/pointprocess.html","id":"an-example-with-replicates","dir":"Articles","previous_headings":"","what":"An example with replicates","title":"Log-Gaussian Cox processes on metric graphs","text":"Let us now test show example replicates. Let us first simulate replicates latent field now clear previous data add new data together exposure terms can now define fit model previously Let’s look summaries","code":"n.rep <- 30   sigma <- 0.5   range <- 2   alpha <- 2   lgcp_sample <- graph_lgcp(n = n.rep, intercept = 1, sigma = sigma,                             range = range, alpha = alpha,                             graph = graph) graph$clear_observations()   df_rep <- data.frame(y=rep(1,length(lgcp_sample[[1]]$edge_loc)),                                              e = rep(0,length(lgcp_sample[[1]]$edge_loc)),                                          edge_number = lgcp_sample[[1]]$edge_number,                                          distance_on_edge = lgcp_sample[[1]]$edge_loc,                                          rep = rep(1,length(lgcp_sample[[1]]$edge_loc)))    df_rep <- rbind(df_rep, data.frame(y = rep(0,length(atilde)),                                          e = atilde,                                          edge_number = graph$mesh$VtE[,1],                                          distance_on_edge = graph$mesh$VtE[,2],                                          rep = rep(1,length(atilde))))   for(i in 2:n.rep){     df_rep <- rbind(df_rep, data.frame(y=rep(1,length(lgcp_sample[[i]]$edge_loc)),                                              e = rep(0,length(lgcp_sample[[i]]$edge_loc)),                                          edge_number = lgcp_sample[[i]]$edge_number,                                          distance_on_edge = lgcp_sample[[i]]$edge_loc,                                          rep = rep(i,length(lgcp_sample[[i]]$edge_loc))))     df_rep <- rbind(df_rep, data.frame(y = rep(0,length(atilde)),                                          e = atilde,                                          edge_number = graph$mesh$VtE[,1],                                          distance_on_edge = graph$mesh$VtE[,2],                                          rep = rep(i,length(atilde))))                                            }        graph$add_observations(data = df_rep,                        normalized = TRUE,                         group = \"rep\") ## Adding observations... rspde_model <- rspde.metric_graph(graph, nu = alpha - 1/2)  data_rspde <- graph_data_rspde(rspde_model, name=\"field\", repl = \".all\")  stk <- inla.stack(data = data_rspde[[\"data\"]],                    A = data_rspde[[\"basis\"]],                    effects = c(data_rspde[[\"index\"]], list(Intercept = 1)))  spde_fit <- inla(y ~ -1 + Intercept + f(field, model = rspde_model, replicate = field.repl),                   family = \"poisson\", data = inla.stack.data(stk),                  control.predictor = list(A = inla.stack.A(stk), compute = TRUE),                  E = inla.stack.data(stk)$e, verbose=TRUE) spde_result <- rspde.result(spde_fit, \"field\", rspde_model) summary(spde_result) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.499984 0.0170322   0.466982 0.499854    0.53388 0.499813 ## range   2.180410 0.1630560   1.878730 2.173900    2.51881 2.160720 result_df <- data.frame(     parameter = c(\"std.dev\", \"range\"),     true = c(sigma, range),     mean = c(       spde_result$summary.std.dev$mean,       spde_result$summary.range$mean     ),     mode = c(       spde_result$summary.std.dev$mode,       spde_result$summary.range$mode     )   )   print(result_df) ##   parameter true      mean      mode ## 1   std.dev  0.5 0.4999837 0.4998126 ## 2     range  2.0 2.1804080 2.1607153"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Gaussian random fields on metric graphs","text":"vignette introduce work Gaussian random fields metric graphs. main models Whittle–Matérn fields introduced Bolin, Simas, Wallin (2024) Bolin, Simas, Wallin (2023). package also support isotropic Gaussian processes, particular Gaussian processes isotropic exponential covariance functions introduced Anderes, Møller, Rasmussen (2020). Finally, Gaussian models based graph Laplacian, introduced Borovitskiy et al. (2021) also supported, even though defined Gaussian processes metric graph, vertices. example throughout vignette, consider following metric graph:  details construction metric graphs, see Working metric graphs","code":"edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 20) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph <- metric_graph$new(edges = edges) graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"whittlematérn-fields","dir":"Articles","previous_headings":"","what":"Whittle–Matérn fields","title":"Gaussian random fields on metric graphs","text":"Whittle–Matérn fields specified solutions stochastic differential equation \\[   (\\kappa^2 - \\Delta)^{\\alpha/2} \\tau u = \\mathcal{W} \\] metric graph \\(\\Gamma\\). can work models without approximations smoothness parameter \\(\\alpha\\) integer, focus vignette. details case general smoothness parameter, see Whittle–Matérn fields general smoothness.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"sampling","dir":"Articles","previous_headings":"Whittle–Matérn fields","what":"Sampling","title":"Gaussian random fields on metric graphs","text":"example, let us simulate field \\(u\\) graph using \\(\\alpha = 1\\). , first need specify sample . first example, let us specify locations manually:  many cases, one wants sample field evenly spaced locations graph. avoid specify locations manually, can first create mesh graph  command build_mesh, argument h decides largest spacing nodes mesh. can now sample field mesh plot result function follows:  Let us construct finer mesh, simulate field, visualize simulation 3D specifying plotly argument plot function: Since \\(\\alpha=1\\), sample paths continuous differentiable. visualize correlation structure field, can compute plot covariances point points graph follows: obtain field differentiable sample paths, can change \\(\\alpha=2\\). corresponding covariance function looks follows: Let us simulate process \\(\\alpha=2\\) well:","code":"PtE <- cbind(rep(1:4, each = 4),              rep(c(0.2, 0.4, 0.6, 0.8), times = 4))  sigma <- 1.3 alpha <- 1 range <- 0.2 u <- sample_spde(kappa = kappa, sigma = sigma,                   range = range,                  graph = graph, PtE = PtE) graph$plot(X = u, X_loc = PtE) graph$build_mesh(h = 0.1) graph$plot(mesh=TRUE) u <- sample_spde(range = range, sigma = sigma, alpha = alpha,                  graph = graph, type = \"mesh\") graph$plot_function(X = u) graph$build_mesh(h = 0.01)   u <- sample_spde(range = range, sigma = sigma, alpha = alpha,                  graph = graph, type = \"mesh\") graph$plot_function(X = u, plotly = TRUE) ## Loading required namespace: plotly C <- spde_covariance(c(2, 0.2), range = range, sigma = sigma, alpha = 1,                             graph = graph) graph$plot_function(X = C, plotly = TRUE) C <- spde_covariance(c(2, 0.2), range = range, sigma = sigma, alpha = 2,                             graph = graph) graph$plot_function(X = C, plotly = TRUE) u <- sample_spde(range = range, sigma = sigma, alpha = 2,                  graph = graph, type = \"mesh\") graph$plot_function(X = u, plotly = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"inference","dir":"Articles","previous_headings":"Whittle–Matérn fields","what":"Inference","title":"Gaussian random fields on metric graphs","text":"MetricGraph package contains implementations linear mixed effects models, random effect can Whittle–Matérn fields, model observed Gaussian measurement noise. also implemented random effects SPDE fields obtained graph Laplacian well models isotropic covariances. section illustrate methods. use Whittle–Matérn fields complicated hierarchical models, recommend using interfaces INLA inlabru packages. See INLA interface Whittle–Matérn fields inlabru interface Whittle–Matérn fields details . Suppose want estimate model parameters Whittle–Matérn field \\(u(s)\\) observed Gaussian measurement noise. , assume given observations \\[ y_i = u(s_i) + \\varepsilon_i, \\quad =1,\\ldots,n \\] \\(s_i\\\\Gamma\\) observation locations \\(\\varepsilon_i\\) independent centered Gaussian variables \\(N(0,\\sigma_e^2)\\) representing measurement noise. Let us start generating data like adding metric graph. details data manipulation metric graphs, see Data manipulation metric graphs.  can now use graph_lme() function fit model. default linear regression model chosen. Since want fit model latent model given Whittle-Matérn field \\(\\alpha=1\\), set model argument either 'alpha1' list(model = 'WhittleMatern', alpha = 1) (first convenient less decriptive). choose parameterization_latent \"spde\" obtain estimated values kappa sigma. default provides estimated values range parameter sigma. can also take glance res: Let us now compare true values: Given estimated parameters, can now kriging estimate field locations graph. example, now estimate field regular mesh previously constructed. can, alternatively, use augment() function: procedure can done \\(\\alpha = 2\\). One can also estimate \\(\\alpha\\) data described vignette Whittle–Matérn fields general smoothness.","code":"range <- 0.2 sigma <- 1.3 sigma_e <- 0.1 alpha <- 1  n.obs.per.edge <- 75 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = alpha,                  graph = graph, PtE = PtE)  y <- u + sigma_e*rnorm(n.obs.per.edge * graph$nE)  df_data <- data.frame(y = y, edge_number = PtE[,1],                         distance_on_edge = PtE[,2])  graph$clear_observations() # Removing previous observations graph$add_observations(data = df_data, normalized = TRUE) ## Adding observations... graph$plot(data = \"y\") res <- graph_lme(y ~ -1, graph = graph, model = 'WM1')  summary(res) ##  ## Latent model - Whittle-Matern with alpha = 1 ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = \"WM1\") ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## tau   0.170764  0.009255  18.452 ## kappa 6.535432  1.829112   3.573 ##  ## Random effects (Matern parameterization): ##       Estimate Std.error z-value ## sigma  1.61976   0.21118   7.670 ## range  0.30602   0.08422   3.633 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.08637   0.02792   3.093 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -241.609  ## Number of function calls by 'optim' = 15 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  1.2454 secs glance(res) ## # A tibble: 1 × 9 ##    nobs  sigma logLik   AIC   BIC deviance df.residual model         alpha ##   <int>  <dbl>  <dbl> <dbl> <dbl>    <dbl>       <dbl> <chr>         <dbl> ## 1   300 0.0864  -242.  489.  500.     483.         297 WhittleMatern     1 sigma_e_est <- res$coeff$measurement_error sigma_est <- res$matern_coeff$random_effects[1] range_est <- res$matern_coeff$random_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##             sigma_e    sigma     range ## Truth    0.10000000 1.300000 0.2000000 ## Estimate 0.08636943 1.619762 0.3060242 u_est <- predict(res, data.frame(edge_number = graph$mesh$VtE[,1],                         distance_on_edge = graph$mesh$VtE[,2]), normalized = TRUE)  graph$plot_function(X = u_est$mean, plotly = TRUE) pred_aug <- augment(res, data.frame(edge_number = graph$mesh$VtE[,1],                         distance_on_edge = graph$mesh$VtE[,2]), normalized = TRUE) p <- graph$plot_function(X = pred_aug[[\".fitted\"]], plotly = TRUE) graph$plot(data = \"y\", p=p, plotly=TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"isotropic-gaussian-processes","dir":"Articles","previous_headings":"","what":"Isotropic Gaussian processes","title":"Gaussian random fields on metric graphs","text":"metric graphs Euclidean edges, Anderes, Møller, Rasmussen (2020) showed one can define valid Gaussian processes various isotropic covariance functions distances points measured -called resistance metric \\(d(\\cdot,\\cdot)\\). One example valid covariance function isotropic exponential covariance function \\[ r(d(s,t)) = \\sigma^2\\exp(-\\kappa d(s,t)). \\] use , valid covariance, metric graph, cumbersome thing compute metric. metric_graph class built support , now illustrate. Suppose want sample Gaussian process exponential covariance mesh graph considered . , need compute resistance metric mesh locations, can done follows: can now construct covariance matrix process: One can note covariance function looks quite similar Whittle–Matérn fields \\(\\alpha = 1\\). Let us plot corresponding Whittle–Matérn covariance compare: similarities two covairance functions, recomend using Whittle–Matérn since Markov properties makes inference much faster used. , covariance well-defined compact metric graph, whereas isotropic exponential guaranteed positive definite graph Euclidean edges. See Bolin, Simas, Wallin (2023) comparisons. However, let us now illustrate can fit covariance data. first clear observations previously added graph, simulate observation locations , sample processes locations, finally construct data add metric graph:  can now fit model graph_lme() function. need set model list(type=\"isoCov\"), default exponential covariance used. Alternatively, one wants directly use isotropic exponential covariance function, one can simply set model isoexp. Observe received warning saying check graph Euclidean edges. due fact isotropic covariance models known work graphs Euclidean edges. Let us check graph Euclidean edges. end, need use check_euclidean() method: Now, simply call graph print characteristics: can see graph Euclidean edges. Let us run fit , time warning appear. , time set model isoexp conveniency: Let us now compute posterior mean field observation locations:  can, alternatively, use augment() function:","code":"graph$compute_resdist_mesh() sigma <- 1 kappa <- 5 Sigma <- sigma^2*exp(-kappa*graph$mesh$res_dist) graph$plot_function(X = Sigma[20,], plotly = TRUE) P <- c(1, graph$mesh$V[20,1]) C.wm <- spde_covariance(P,range=2/kappa, sigma=sigma, graph=graph, alpha = 1) p <- graph$plot_function(X = Sigma[20,], plotly = TRUE) graph$plot_function(X = C.wm, plotly = TRUE, p = p, line_color = 'rgb(100,0,0)',                     support_width = 0) graph$clear_observations() sigma <-1.5 kappa <- 20 sigma_e <- 0.1 n.obs.per.edge <- 50  PtE <- NULL for(i in 1:graph$nE){   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) } D <- graph$compute_resdist_PtE(PtE, normalized = TRUE) # Sigma <- sigma^2*exp(-kappa*D) Sigma <- as.matrix(exp_covariance(D, c(sigma, kappa))) u <- t(chol(Matrix::forceSymmetric(Sigma)))%*%rnorm(n.obs.per.edge * graph$nE) y <- u + sigma_e*rnorm(n.obs.per.edge * graph$nE)  df_isocov <- data.frame(y = as.vector(y), edge_number = PtE[,1],                         distance_on_edge = PtE[,2])  graph$add_observations(data = df_isocov, normalized=TRUE) ## Adding observations... graph$plot(data = \"y\") res_exp <- graph_lme(y ~ -1, graph = graph, model = list(type = \"isoCov\")) ## Warning in graph_lme(y ~ -1, graph = graph, model = list(type = \"isoCov\")): No ## check for Euclidean edges have been perfomed on this graph. The isotropic ## covariance models are only known to work for graphs with Euclidean edges. You ## can check if the graph has Euclidean edges by running the `check_euclidean()` ## method. See the vignette ## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html ## for further details. graph$check_euclidean() graph ## A metric graph with  4  vertices and  4  edges. ##  ## Vertices: ##   Degree 1: 1;  Degree 2: 2;  Degree 3: 1;  ##   With incompatible directions:  2  ##  ## Edges:  ##   Lengths:  ##       Min: 1  ; Max: 1.570349  ; Total: 4.570349  ##   Weights:  ##       Min: 1  ; Max: 1  ##   That are circles:  0  ##  ## Graph units:  ##   Vertices unit:  None  ; Lengths unit:  None  ##  ## Longitude and Latitude coordinates:  FALSE ##  ## Some characteristics of the graph: ##   Connected: TRUE ##   Has loops: FALSE ##   Has multiple edges: FALSE ##   Is a tree: FALSE ##   Distance consistent: TRUE ##   Has Euclidean edges: TRUE res_exp <- graph_lme(y ~ -1, graph = graph, model = \"isoexp\") summary(res_exp) ##  ## Latent model - Covariance-based model ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = \"isoexp\") ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## tau     1.4150    0.1088   13.01 ## kappa  25.8070    5.4788    4.71 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.15026   0.08407   1.787 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -268.2396  ## Number of function calls by 'optim' = 23 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  3.46102 secs sigma_e_est <- res_exp$coeff$measurement_error sigma_est <- res_exp$coeff$random_effects[1] kappa_est <- res_exp$coeff$random_effects[2]  results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       kappa = c(kappa, kappa_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e    sigma    kappa ## Truth    0.1000000 1.500000 20.00000 ## Estimate 0.1502608 1.414987 25.80701 u_est_exp <- predict(res_exp, df_isocov, normalized = TRUE) graph$plot(X = u_est_exp$mean, X_loc = PtE) pred_aug_exp <- augment(res_exp, data.frame(edge_number = graph$mesh$VtE[,1],                         distance_on_edge = graph$mesh$VtE[,2]), normalized = TRUE) p <- graph$plot_function(X = pred_aug_exp[[\".fitted\"]], plotly = TRUE) graph$plot(data = \"y\", p=p, plotly=TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"models-based-on-the-graph-laplacian","dir":"Articles","previous_headings":"","what":"Models based on the Graph Laplacian","title":"Gaussian random fields on metric graphs","text":"final set Gaussian models supported MetricGraph Matérn type processes based graph Laplacian introduced Borovitskiy et al. (2021). multivariate Gaussian distributions, defined vertices equation \\[ (\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha/2}\\mathbf{u} = \\mathbf{W} \\] \\(\\mathbf{W}\\sim N(0,\\sigma^2\\mathbf{})\\) vector independent Gaussian variables \\(\\mathbf{\\Delta}_\\Gamma\\) graph Laplacian. , \\(\\mathbf{u}\\) vector values process vertices \\(\\Gamma\\), definition precision matrix \\[ \\mathbf{Q} = \\sigma^{-2}(\\kappa^2\\mathbf{} - \\mathbf{\\Delta}_\\Gamma)^{\\alpha} \\] Thus, define models, `difficult'' thing compute  graph Laplacian. (weighted) graph Laplacian, weights specified edge lengths can computed functioncompute_laplacian()themetric_graph` object. first generate random locations, compute Laplacian locations: Let us now generate data graph Laplacian model \\(\\alpha=1\\):  can fit model data similarly fit previous models, help function graph_lme():","code":"n.obs.per.edge <- 100 PtE <- NULL for(i in 1:graph$nE){   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), sort(runif(n.obs.per.edge)))) } ## Removing problematic locations (locations very close) to improve numerical stability prob_points <- which(abs(diff(PtE[,2])) < 1e-3) prob_points <- c(prob_points, which(PtE[,2] < 1e-3)) prob_points <- c(prob_points, which(PtE[,2] > 1 - 1e-3))  PtE <- PtE[!(1:nrow(PtE)%in%prob_points),] df_temp <- data.frame(y = 0, edge_number = PtE[,1],                         distance_on_edge = PtE[,2])                          graph$clear_observations() graph$add_observations(data = df_temp, normalized = TRUE) ## Adding observations... graph$compute_laplacian()  GL <- graph$Laplacian[[1]] library(Matrix)  tau <- 1 kappa <- 10 sigma_e <- 0.1  Q <- (kappa^2 * Diagonal(nrow(GL)) + GL) * tau^2 LQ <- chol(forceSymmetric(Q)) u <- solve(LQ, rnorm(nrow(Q)))[(attr(GL, \"nV_idx\") + 1):nrow(GL)] # The first attr(GL, \"nV_idx\") values are on the original vertices y <- u + sigma_e*rnorm(length(u))  df_GL <- data.frame(y = as.vector(y), edge_number = PtE[,1],                         distance_on_edge = PtE[,2])  graph$clear_observations() graph$add_observations(data = df_GL, normalized=TRUE) ## Adding observations... graph$plot(data = \"y\") res_GL <- graph_lme(y ~ -1, graph = graph, model = list(type = \"graphLaplacian\"))  sigma_e_est <- res_GL$coeff$measurement_error tau_est <- res_GL$coeff$random_effects[1] kappa_est <- res_GL$coeff$random_effects[2]  results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       tau = c(tau, tau_est),                       kappa = c(kappa, kappa_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e      tau     kappa ## Truth    0.1000000 1.000000 10.000000 ## Estimate 0.1125888 1.291509  7.342189"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-comparison-using-cross-validation","dir":"Articles","previous_headings":"","what":"A comparison using cross-validation","title":"Gaussian random fields on metric graphs","text":"Let us now compare different models terms predictive ability. start simulating data frome Whittle–Matérn field \\(\\alpha = 2\\), fit different models discussed, compare predictive ability leave-one-crossvalidation. change things bit, let us consider different graph:  Let us now generate observation locations random locations edge sample process:  now fit different models data: Finally, use function posterior_crossvalidation() perform leave-one-cross validation based estimated parameters compare results:","code":"V <- rbind(c(0, 0),            c(1, 0),            c(1, 1),            c(0, 1),            c(-1, 1),            c(-1, 0),            c(0, -1)) E <- rbind(c(1, 2),            c(2, 3),            c(3, 4),            c(4, 5),            c(5, 6),            c(6, 1),            c(4, 1),            c(1, 7)) graph <- metric_graph$new(V = V, E = E) graph$plot() range <- 0.15 sigma <- 2 sigma_e <- 0.3 theta <-  c(sigma_e, sigma, kappa)  n.obs.per.edge <- 15 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 2,                  graph = graph, PtE = PtE, method = \"Q\")  y <- u + sigma_e*rnorm(n.obs.per.edge * graph$nE)  df_cv <- data.frame(y = y, edge_number = PtE[,1],                       distance_on_edge = PtE[,2])  graph$add_observations(data=df_cv, normalized = TRUE) ## Adding observations... graph$plot(data = \"y\") #alpha = 1 model fit_alpha1 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"WhittleMatern\", alpha = 1))  #alpha = 2 model fit_alpha2 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"WhittleMatern\", alpha = 2))  #Isotropic exponential fit_isoexp <- graph_lme(y ~ -1, graph=graph, model = list(type = \"isoCov\")) ## Warning in graph_lme(y ~ -1, graph = graph, model = list(type = \"isoCov\")): No ## check for Euclidean edges have been perfomed on this graph. The isotropic ## covariance models are only known to work for graphs with Euclidean edges. You ## can check if the graph has Euclidean edges by running the `check_euclidean()` ## method. See the vignette ## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html ## for further details. #Graph Laplacian  fit_GL1 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"graphLaplacian\", alpha = 1))  fit_GL2 <- graph_lme(y ~ -1, graph=graph, model = list(type = \"graphLaplacian\", alpha = 2)) fitted_models_list <- list(\"alpha=1\" = fit_alpha1,                      \"alpha=2\" = fit_alpha2,                      \"isoExp\" = fit_isoexp,                      \"GL1\" = fit_GL1, \"GL2\" = fit_GL2)  posterior_crossvalidation(fitted_models_list, factor=1000)[[\"scores\"]] ## # A tibble: 5 × 6 ##   Model   logscore  crps scrps   mae  rmse ##   <chr>      <dbl> <dbl> <dbl> <dbl> <dbl> ## 1 alpha=1    1391.  637. 1046.  903. 1272. ## 2 alpha=2    1265.  584.  989.  817. 1195. ## 3 isoExp     1392.  636. 1046.  901. 1270. ## 4 GL1        1397.  644. 1049.  916. 1286. ## 5 GL2        1296.  603. 1004.  852. 1225."},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-model-with-replicates","dir":"Articles","previous_headings":"","what":"A model with replicates","title":"Gaussian random fields on metric graphs","text":"Let us illustrate now one can fit model replicates. end, consider graph previous example.  Let us now generate observation locations random locations edge sample process. Let us sample Whitlle–Matérn process metric graph alpha=1. consider 20 replicates. end, set nsim=20: plot first replicate, can simply call graph$plot(data=TRUE). plot another replicate, set argument group index replicate want plot. Let us plot first second replicates:    fit model, simply proceed identical manner case without replicates using graph_lme() function: Let us now fit model isotropic exponential covariance data: kriging, proceed identical way, providing data.frame locations want obtain predictions. Let us obtain predictions observation locations. setting return_as_list TRUE obtain list predictions, element consists predictions corresponding replicate. Let us now plot predictions first replicate using number indicates order replicate:  can also use name replicate. Let us plot predictions replicate y.15:","code":"V <- rbind(c(0, 0),            c(1, 0),            c(1, 1),            c(0, 1),            c(-1, 1),            c(-1, 0),            c(0, -1)) E <- rbind(c(1, 2),            c(2, 3),            c(3, 4),            c(4, 5),            c(5, 6),            c(6, 1),            c(4, 1),            c(1, 7)) graph <- metric_graph$new(V = V, E = E) graph$plot() library(tidyr)  range <- 0.15 sigma <- 2 sigma_e <- 0.1 theta <-  c(sigma_e, sigma, kappa)  n_repl <- 20  n.obs.per.edge <- 30 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = PtE, nsim = n_repl)  y <- u + sigma_e*matrix(rnorm(n.obs.per.edge * graph$nE * n_repl), ncol = n_repl)  df_graph <- data.frame(y=y, edge_number = PtE[,1],                       distance_on_edge = PtE[,2])  df_graph <- pivot_longer(df_graph, cols = `y.1`:`y.20`, names_to = \"repl\", values_to = \"y\")  graph$add_observations(data = df_graph, normalized = TRUE, group=\"repl\") graph$plot(data=\"y\") graph$plot(data=\"y\", group=\"y.2\") graph$plot(data=\"y\", group=2) fit_repl <- graph_lme(y ~ -1, graph = graph, model = \"WM1\")  sigma_e_est <- fit_repl$coeff$measurement_error sigma_est <- fit_repl$matern_coeff$random_effects[1] range_est <- fit_repl$matern_coeff$random_effects[2]   results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e    sigma     range ## Truth    0.1000000 2.000000 0.1500000 ## Estimate 0.1009145 2.071232 0.1648317 fit_repl_isoexp <- graph_lme(y ~ -1, graph = graph,                             model = list(type = \"isoCov\")) ## Warning in graph_lme(y ~ -1, graph = graph, model = list(type = \"isoCov\")): No ## check for Euclidean edges have been perfomed on this graph. The isotropic ## covariance models are only known to work for graphs with Euclidean edges. You ## can check if the graph has Euclidean edges by running the `check_euclidean()` ## method. See the vignette ## https://davidbolin.github.io/MetricGraph/articles/isotropic_noneuclidean.html ## for further details. summary(fit_repl_isoexp) ##  ## Latent model - Covariance-based model ##  ## Call: ## graph_lme(formula = y ~ -1, graph = graph, model = list(type = \"isoCov\")) ##  ## No fixed effects. ##  ## Random effects: ##       Estimate Std.error z-value ## tau    2.06794   0.03672   56.31 ## kappa 12.26700   0.52485   23.37 ##  ## Measurement error: ##          Estimate Std.error z-value ## std. dev  0.09992   0.01252   7.979 ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  ##  ## Log-Likelihood:  -7539.364  ## Number of function calls by 'optim' = 24 ## Optimization method used in 'optim' = L-BFGS-B ##  ## Time used to:     fit the model =  11.80163 secs df_pred <-  data.frame(edge_number = PtE[,1],                       distance_on_edge = PtE[,2])  pred_alpha1 <- predict(fit_repl, newdata = df_pred, normalized = TRUE, return_as_list = TRUE) graph$plot(X = pred_alpha1$mean[[1]], X_loc = df_pred) graph$plot(X = pred_alpha1$mean[[\"y.15\"]], X_loc = df_pred)"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-model-with-covariates","dir":"Articles","previous_headings":"","what":"A model with covariates","title":"Gaussian random fields on metric graphs","text":"example consider first graph:  Let us now generate observation locations random locations edge sample process. Let us sample Whitlle–Matérn process metric graph alpha=1. include intercept covariates. covariates can added columns data.frame passed add_observations() function. Let us now estimate parameters using graph_lme() function: kriging, can use predict() method together data.frame containing locations covariates locations want obtain predictions. Let us obtain predictions observation locations: Let us now plot predictions first replicate using number indicates order replicate:","code":"edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 20) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph <- metric_graph$new(edges = edges) graph$plot() graph$clear_observations() range <- 0.15 sigma <- 2 sigma_e <- 0.1 theta <-  c(sigma_e, sigma, kappa)  n.obs.per.edge <- 75 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = PtE)  beta <- c(2,1)  X_cov <- cbind(1, runif(nrow(PtE)))  y <- X_cov %*% beta +  u + sigma_e*rnorm(n.obs.per.edge * graph$nE) df_graph <- data.frame(y=y, x1 = X_cov[,2], edge_number = PtE[,1], distance_on_edge=PtE[,2]) graph$add_observations(data=df_graph, normalized = TRUE) ## Adding observations... fit_cov <- graph_lme(y ~ x1, graph = graph, model = \"WM1\") sigma_e_est <- fit_cov$coeff$measurement_error sigma_est <- fit_cov$matern_coeff$random_effects[1] range_est <- fit_cov$matern_coeff$random_effects[2] beta_1_est <- fit_cov$coeff$fixed_effects[1] beta_2_est <- fit_cov$coeff$fixed_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       beta_1 = c(beta[1], beta_1_est),                       beta_2 = c(beta[2], beta_2_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e   sigma     range   beta_1   beta_2 ## Truth    0.1000000 2.00000 0.1500000 2.000000 1.000000 ## Estimate 0.0936907 1.72655 0.1165532 1.955696 1.110535 pred_cov <- predict(fit_cov, newdata = df_graph, normalized = TRUE) graph$plot(X = pred_cov$mean, X_loc = df_graph[,3:4])"},{"path":"https://davidbolin.github.io/MetricGraph/articles/random_fields.html","id":"a-model-with-covariates-and-replicates","dir":"Articles","previous_headings":"","what":"A model with covariates and replicates","title":"Gaussian random fields on metric graphs","text":"Let us consider graph previous example:  Let us now generate observation locations random locations edge sample process. Let us sample Whitlle–Matérn process metric graph alpha=1 20 replicates. include intercept covariates. covariates can added data.frame passed add_observations() function. Let us now estimate parameters graph_lme() function: Finally, can kriging analogous manner previous cases. Let us obtain predictions first replicate observation locations: Let us now plot predictions first replicate using number indicates order replicate:","code":"edge1 <- rbind(c(0,0),c(1,0)) edge2 <- rbind(c(0,0),c(0,1)) edge3 <- rbind(c(0,1),c(-1,1)) theta <- seq(from=pi,to=3*pi/2,length.out = 20) edge4 <- cbind(sin(theta),1+ cos(theta)) edges = list(edge1, edge2, edge3, edge4) graph <- metric_graph$new(edges = edges) graph$plot() range <- 0.2 sigma <- 2 sigma_e <- 0.1 theta <-  c(sigma_e, sigma, kappa)  n.obs.per.edge <- 30 n_repl <- 20 PtE <- NULL for(i in 1:graph$nE){   #add locations sampled at random to each edge   PtE <- rbind(PtE, cbind(rep(i, n.obs.per.edge), runif(n.obs.per.edge))) }  u <- sample_spde(range = range, sigma = sigma, alpha = 1,                  graph = graph, PtE = PtE, nsim = n_repl)  beta <- c(2,1)  X_cov <- cbind(1, runif(nrow(PtE)))  y <- NULL for(i in 1:n_repl){   y_tmp <- X_cov %*% beta +  u[,i] + sigma_e*rnorm(n.obs.per.edge * graph$nE)   y <- cbind(y, y_tmp) }  data_list <- lapply(1:n_repl, function(i){data.frame(y = y[,i], x1 = X_cov[,2],                                           edge_number = PtE[,1],                                           distance_on_edge = PtE[,2], repl = i)})  df_graph <- do.call(rbind, data_list)  graph$add_observations(data = df_graph, normalized = TRUE, group = \"repl\") ## Adding observations... fit_cov_repl <- graph_lme(y ~ x1, graph = graph, model = \"WM1\") sigma_e_est <- fit_cov_repl$coeff$measurement_error sigma_est <- fit_cov_repl$matern_coeff$random_effects[1] range_est <- fit_cov_repl$matern_coeff$random_effects[2] beta_1_est <- fit_cov_repl$coeff$fixed_effects[1] beta_2_est <- fit_cov_repl$coeff$fixed_effects[2] results <- data.frame(sigma_e = c(sigma_e, sigma_e_est),                       sigma = c(sigma, sigma_est),                       range = c(range, range_est),                       beta_1 = c(beta[1], beta_1_est),                       beta_2 = c(beta[2], beta_2_est),                       row.names = c(\"Truth\", \"Estimate\")) print(results) ##            sigma_e    sigma     range   beta_1    beta_2 ## Truth    0.1000000 2.000000 0.2000000 2.000000 1.0000000 ## Estimate 0.1160301 1.961847 0.1962414 1.934339 0.9957897 df_pred <-  data.frame(edge_number = PtE[,1],                       distance_on_edge = PtE[,2], x1 = X_cov[,2])  pred_cov_repl <- predict(fit_cov_repl, newdata = df_pred, normalized = TRUE, return_as_list = TRUE) graph$plot(X = pred_cov_repl$mean[[1]], X_loc = df_pred[,1:2])"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Maintainer, author. Alexandre Simas. Author. Jonas Wallin. Author.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Simas , Wallin J (2023). MetricGraph: Random fields metric graphs. R package version 1.3.0.9000, https://CRAN.R-project.org/package=MetricGraph. Bolin D, Simas , Wallin J (2024). “Gaussian Whittle-Matérn fields metric graphs.” Bernoulli, 30(2), 1611–1639. doi:10.3150/23-BEJ1647. Bolin D, Kovács M, Kumar V, Simas (2023). “Regularity numerical approximation fractional elliptic differential equations compact metric graphs.” Mathematics Computation. doi:10.1090/mcom/3929, (press). Bolin D, Simas , Wallin J (2023). “Markov properties Gaussian random fields compact metric graphs.” arXiv preprint arXiv:2304.03190. doi:10.48550/arXiv.2304.03190. Bolin D, Simas , Wallin J (2023). “Statistical inference Gaussian Whittle-Matérn fields metric graphs.” arXiv preprint arXiv:2304.10372. doi:10.48550/arXiv.2304.10372.","code":"@Manual{,   title = {MetricGraph: Random fields on metric graphs},   author = {David Bolin and Alexandre B. Simas and Jonas Wallin},   year = {2023},   note = {R package version 1.3.0.9000},   url = {https://CRAN.R-project.org/package=MetricGraph}, } @Article{,   title = {Gaussian Whittle-Matérn fields on metric graphs},   author = {David Bolin and Alexandre B. Simas and Jonas Wallin},   year = {2024},   journal = {Bernoulli},   volume = {30},   number = {2},   pages = {1611--1639},   doi = {10.3150/23-BEJ1647}, } @Article{,   title = {Regularity and numerical approximation of fractional elliptic differential equations on compact metric graphs},   author = {David Bolin and Mihály Kovács and Vivek Kumar and Alexandre B. Simas},   year = {2023},   journal = {Mathematics of Computation},   doi = {10.1090/mcom/3929},   note = {(in press)}, } @Article{,   title = {Markov properties of Gaussian random fields on compact metric graphs},   author = {David Bolin and Alexandre B. Simas and Jonas Wallin},   year = {2023},   journal = {arXiv preprint arXiv:2304.03190},   doi = {10.48550/arXiv.2304.03190}, } @Article{,   title = {Statistical inference for Gaussian Whittle-Matérn fields on metric graphs},   author = {David Bolin and Alexandre B. Simas and Jonas Wallin},   year = {2023},   journal = {arXiv preprint arXiv:2304.10372},   doi = {10.48550/arXiv.2304.10372}, }"},{"path":"https://davidbolin.github.io/MetricGraph/index.html","id":"metricgraph","dir":"","previous_headings":"","what":"Random Fields on Metric Graphs","title":"Random Fields on Metric Graphs","text":"MetricGraph R package used working data random fields metric graphs, street river networks. main functionality contained metric_graph class, used specifying metric graphs, adding data , visualization, basic functions needed working data random fields metric graphs. package also implements various Gaussian fields metric graphs, particular Whittle–Matérn fields introduced references . Basic statistical tasks likelihood evaluation prediction implemented Gaussian fields MetricGraph. , package also contains interfaces R-INLA inlabru facilitates using packages full Bayesian inference general Latent Gaussian Models (LGMs) includes Whittle-Matérn fields metric graphs. get started package, please go MetricGraph: Random Fields Metric Graphs vignette. comprehensive examples, please see vignettes vignettes tab.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Random Fields on Metric Graphs","text":"D. Bolin, . Simas, J. Wallin (2024) Gaussian Whittle-Matérn fields metric graphs. Bernoulli, 30, 1611-1639. D. Bolin, M. Kovács, V. Kumar, . Simas (2023) Regularity numerical approximation fractional elliptic differential equations compact metric graphs. Mathematics Computation. press. D. Bolin, . Simas, J. Wallin (2023) Markov properties Gaussian random fields compact metric graphs. ArXiv:2304.03190 D. Bolin, . Simas, J. Wallin (2023) Statistical inference Gaussian Whittle-Matérn fields metric graphs. ArXiv:2304.10372","code":""},{"path":"https://davidbolin.github.io/MetricGraph/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Random Fields on Metric Graphs","text":"latest CRAN release package can installed directly CRAN install.packages(\"MetricGraph\"). also possible install CRAN version github using command: latest stable version can installed using command R. development version can installed using command","code":"remotes::install_github(\"davidbolin/metricgraph\", ref = \"cran\") remotes::install_github(\"davidbolin/metricgraph\", ref = \"stable\") remotes::install_github(\"davidbolin/metricgraph\", ref = \"devel\")"},{"path":"https://davidbolin.github.io/MetricGraph/reference/MetricGraph-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian processes on metric graphs — MetricGraph-package","title":"Gaussian processes on metric graphs — MetricGraph-package","text":"'MetricGraph' used creation manipulation metric graphs, street river networks. also several functions thatfacilitates operations visualizations data metric graphs, creation large class random fields stochastic partial differential equations spaces. main models Whittle-Matérn fields, specified fractional elliptic SPDE $$(\\kappa^2 - \\Delta)^{\\alpha/2} (\\tau u(s)) = W,$$ \\(\\kappa,\\tau>0\\) \\(\\alpha>1/2\\) parameters \\(W\\) Gaussian white noise. contains exact implementations model \\(\\alpha=1\\) \\(\\alpha=2\\), contains approximate implementations, via finite element method, \\(\\alpha > 0.5\\). also implements models based graph Laplacians isotropic covariance functions. Several utility functions specifying graphs, computing likelihoods, performing prediction, simulating processes, visualizing results metric graphs provided. particular, linear mixed effects models including random field components can fitted data based computationally efficient sparse matrix representations. Interfaces R packages 'INLA' 'inlabru' also provided, facilitate working Bayesian statistical models metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/MetricGraph-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gaussian processes on metric graphs — MetricGraph-package","text":"heart package R6 class [metric_graph()]. used specifying metric graphs, contains various utility functions needed specifying Gaussian processes spaces. Linear mixed effects models provided (see [graph_lme]) perform predictions (see [predict.graph_lme]). package also interfaces 'INLA' (see [graph_spde]), interface also works 'inlabru'. detailed introduction package, see 'MetricGraph' Vignettes.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/MetricGraph-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Gaussian processes on metric graphs — MetricGraph-package","text":"Maintainer: David Bolin davidbolin@gmail.com Authors: Alexandre Simas alexandre.impa@gmail.com Jonas Wallin jonas.wallin81@gmail.com","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/augment.graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Augment data with information from a graph_lme object — augment.graph_lme","title":"Augment data with information from a graph_lme object — augment.graph_lme","text":"Augment accepts model object dataset adds information observation dataset. includes predicted values .fitted column, residuals .resid column, standard errors fitted values .se.fit column. also contains New columns always begin . prefix avoid overwriting columns original dataset.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/augment.graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Augment data with information from a graph_lme object — augment.graph_lme","text":"","code":"# S3 method for graph_lme augment(   x,   newdata = NULL,   which_repl = NULL,   sd_post_re = FALSE,   se_fit = FALSE,   conf_int = FALSE,   pred_int = FALSE,   level = 0.95,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   coord_x = \"coord_x\",   coord_y = \"coord_y\",   data_coords = c(\"PtE\", \"spatial\"),   normalized = FALSE,   no_nugget = FALSE,   check_euclidean = FALSE,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/augment.graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Augment data with information from a graph_lme object — augment.graph_lme","text":"x graph_lme object. newdata data.frame list containing covariates, edge number distance edge locations obtain prediction. NULL, fitted values given original locations model fitted. which_repl replicates obtain prediction. NULL predictions obtained replicates. Default NULL. sd_post_re Logical indicating whether .sd_post_re column added augmented output containing posterior standard deviations random effects. se_fit Logical indicating whether .se_fit column added augmented output containing standard errors fitted values. TRUE, posterior standard deviations random effects also returned. conf_int Logical indicating whether confidence intervals posterior mean random effects built. pred_int Logical indicating whether prediction intervals fitted values built. TRUE, confidence intervals posterior random effects also built. level Level confidence prediction intervals constructed. edge_number Name variable contains edge number, default edge_number. distance_on_edge Name variable contains distance edge, default distance_on_edge. coord_x Column (entry list) data contains x coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. coord_y Column (entry list) data contains y coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. data_coords used Spoints NULL. decides coordinate system use. PtE, user must provide edge_number distance_on_edge, otherwise spatial, user must provide coord_x coord_y. normalized distances edges normalized? no_nugget prediction done without nugget? check_euclidean Check graph used compute resistance distance Euclidean edges? graph used compute resistance distance observation locations vertices. ... Additional arguments.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/augment.graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Augment data with information from a graph_lme object — augment.graph_lme","text":"tidyr::tibble() columns: .fitted Fitted predicted value. .relwrconf Lower bound confidence interval random effects, conf_int = TRUE .reuprconf Upper bound confidence interval random effects, conf_int = TRUE .fittedlwrpred Lower bound prediction interval, conf_int = TRUE .fitteduprpred Upper bound prediction interval, conf_int = TRUE .fixed Prediction fixed effects. .random Prediction random effects. .resid ordinary residuals, , difference observed fitted values. .std_resid standardized residuals, , ordinary residuals divided standard error fitted values (prediction standard error), se_fit = TRUE pred_int = TRUE. .se_fit Standard errors fitted values, se_fit = TRUE. .sd_post_re Standard deviation posterior mean random effects, se_fit = TRUE.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_mapper.inla_metric_graph_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","title":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","text":"Metric graph 'inlabru' mapper","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_mapper.inla_metric_graph_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","text":"","code":"# S3 method for inla_metric_graph_spde bru_get_mapper(model, ...)  # S3 method for bru_mapper_inla_metric_graph_spde ibm_n(mapper, ...)  # S3 method for bru_mapper_inla_metric_graph_spde ibm_values(mapper, ...)  # S3 method for bru_mapper_inla_metric_graph_spde ibm_jacobian(mapper, input, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/bru_mapper.inla_metric_graph_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph 'inlabru' mapper — bru_mapper.inla_metric_graph_spde","text":"model inla_metric_graph_spde construct extract mapper ... Arguments passed methods mapper bru_mapper.inla_metric_graph_spde object input values produce mapping matrix","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/drop_na.metric_graph_data.html","id":null,"dir":"Reference","previous_headings":"","what":"A version of tidyr::drop_na() function for datasets on metric graphs — drop_na.metric_graph_data","title":"A version of tidyr::drop_na() function for datasets on metric graphs — drop_na.metric_graph_data","text":"Applies tidyr::drop_na() function datasets obtained metric graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/drop_na.metric_graph_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A version of tidyr::drop_na() function for datasets on metric graphs — drop_na.metric_graph_data","text":"","code":"# S3 method for metric_graph_data drop_na(data, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/drop_na.metric_graph_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A version of tidyr::drop_na() function for datasets on metric graphs — drop_na.metric_graph_data","text":"data data list tidyr::tibble obtained metric graph object. ... Additional parameters passed tidyr::drop_na().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/drop_na.metric_graph_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A version of tidyr::drop_na() function for datasets on metric graphs — drop_na.metric_graph_data","text":"tidyr::tibble resulting selected columns.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential covariance function — exp_covariance","title":"Exponential covariance function — exp_covariance","text":"Evaluates exponential covariance function $$C(h) = \\sigma^2 \\exp\\{-kappa h\\}$$","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential covariance function — exp_covariance","text":"","code":"exp_covariance(h, theta)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential covariance function — exp_covariance","text":"h Distances evaluate covariance function . theta vector c(sigma, kappa), sigma standard deviation kappa range-like parameter.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/exp_covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential covariance function — exp_covariance","text":"vector values covariance function.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/filter.metric_graph_data.html","id":null,"dir":"Reference","previous_headings":"","what":"A version of dplyr::filter() function for datasets on metric graphs — filter.metric_graph_data","title":"A version of dplyr::filter() function for datasets on metric graphs — filter.metric_graph_data","text":"Applies dplyr::filter() function datasets obtained metric graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/filter.metric_graph_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A version of dplyr::filter() function for datasets on metric graphs — filter.metric_graph_data","text":"","code":"# S3 method for metric_graph_data filter(.data, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/filter.metric_graph_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A version of dplyr::filter() function for datasets on metric graphs — filter.metric_graph_data","text":".data data list tidyr::tibble obtained metric graph object. ... Additional parameters passed dplyr::filter().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/filter.metric_graph_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A version of dplyr::filter() function for datasets on metric graphs — filter.metric_graph_data","text":"tidyr::tibble resulting selected columns.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"Returns 'ggplot2'-friendly data-frame marginal posterior densities.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"","code":"# S3 method for metric_graph_spde_result gg_df(   result,   parameter = result$params,   transform = TRUE,   restrict_x_axis = parameter,   restrict_quantiles = list(sigma = c(0, 1), range = c(0, 1), kappa = c(0, 1), sigma =     c(0, 1)),   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"result metric_graph_spde_result object. parameter Vector. parameters get posterior density data.frame? options sigma, range kappa. transform posterior density given original scale? restrict_x_axis Variables restrict range x axis based quantiles. restrict_quantiles List quantiles restrict x axis. ... used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/gg_df.metric_graph_spde_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data frame for metric_graph_spde_result objects to be used in 'ggplot2' — gg_df.metric_graph_spde_result","text":"data.frame containing posterior densities.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/glance.graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Glance at a graph_lme object — glance.graph_lme","title":"Glance at a graph_lme object — glance.graph_lme","text":"Glance accepts graph_lme object returns tidyr::tibble() exactly one row model summaries. summaries square root estimated variance measurement error, residual degrees freedom, AIC, BIC, log-likelihood, type latent model used fit total number observations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/glance.graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Glance at a graph_lme object — glance.graph_lme","text":"","code":"# S3 method for graph_lme glance(x, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/glance.graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Glance at a graph_lme object — glance.graph_lme","text":"x graph_lme object. ... Additional arguments. Currently used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/glance.graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Glance at a graph_lme object — glance.graph_lme","text":"tidyr::tibble() exactly one row columns: nobs Number observations used. sigma square root estimated residual variance logLik log-likelihood model. AIC Akaike's Information Criterion model. BIC Bayesian Information Criterion model. deviance Deviance model. df.residual Residual degrees freedom. model.type Type latent model fitted.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data frames or data lists to be used with 'inlabru' in metric graphs — graph_bru_process_data","title":"Prepare data frames or data lists to be used with 'inlabru' in metric graphs — graph_bru_process_data","text":"Prepare data frames data lists used 'inlabru' metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data frames or data lists to be used with 'inlabru' in metric graphs — graph_bru_process_data","text":"","code":"graph_bru_process_data(   data,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   loc = \"loc\" )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data frames or data lists to be used with 'inlabru' in metric graphs — graph_bru_process_data","text":"data data.frame list containing covariates, edge number distance edge locations obtain prediction. edge_number Name variable contains edge number, default edge_number. distance_on_edge Name variable contains distance edge, default distance_on_edge. loc character. Name locations used 'inlabru' component.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_bru_process_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data frames or data lists to be used with 'inlabru' in metric graphs — graph_bru_process_data","text":"list containing processed data used user-friendly manner 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":null,"dir":"Reference","previous_headings":"","what":"Connected components of metric graph — graph_components","title":"Connected components of metric graph — graph_components","text":"Class representing connected components metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Connected components of metric graph — graph_components","text":"Object R6Class creating metric graph components.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Connected components of metric graph — graph_components","text":"list metric_graph objects (representing different connected components full graph) created vertex edge matrices, sp::SpatialLines object line representing edge. details, see vignette: vignette(\"metric_graph\", package = \"MetricGraph\")","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Connected components of metric graph — graph_components","text":"graphs List graphs representing connected components. n number graphs. sizes Number vertices graphs. lengths Total edge lengths graphs. Create metric graphs connected components","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Connected components of metric graph — graph_components","text":"graph_components$new() graph_components$get_largest() graph_components$plot() graph_components$clone()","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$new(   edges = NULL,   V = NULL,   E = NULL,   by_length = TRUE,   edge_weights = NULL,   ...,   lines = deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connected components of metric graph — graph_components","text":"edges list containing coordinates m x 2 matrices (, matrix type) m x 2 data frames (data.frame type) sequence points connected straightlines. Alternatively, can also prove object type SpatialLinesDataFrame SpatialLines (sp package) MULTILINESTRING (sf package). V n x 2 matrix Euclidean coordinates n vertices. E m x 2 matrix row represents edge. by_length Sort components total edge length? FALSE, components sorted number vertices. edge_weights Either number, numerical vector length given number edges, providing edge weights, data.frame number rows equal number edges, ... Additional arguments used specifying graphs lines Use edges instead. vertex_unit unit vertices specified. options 'degrees' (great circle distance km), 'km', 'm' 'miles'. default NULL, means unit. However, set length_unit, need set vertex_unit. length_unit unit lengths computed. options 'km', 'm' 'miles'. default vertex_unit. Observe vertex_unit NULL, length_unit can NULL. vertex_unit 'degrees', default value length_unit 'km'. longlat TRUE, assumed coordinates given. Longitude/Latitude distances computed meters. takes precedence vertex_unit length_unit, equivalent vertex_unit = 'degrees' length_unit = 'm'. tolerance Vertices closer number merged constructing graph (default = 1e-10). longlat = TRUE, tolerance given km.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Connected components of metric graph — graph_components","text":"graph_components object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"method-get-largest-","dir":"Reference","previous_headings":"","what":"Method get_largest()","title":"Connected components of metric graph — graph_components","text":"Returns largest component graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$get_largest()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Connected components of metric graph — graph_components","text":"metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Connected components of metric graph — graph_components","text":"Plots components.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$plot(edge_colors = NULL, vertex_colors = NULL, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connected components of metric graph — graph_components","text":"edge_colors 3 x nc matrix RGB values edge colors used plotting graph. vertex_colors 3 x nc matrix RGB values edge colors used plotting graph. ... Additional arguments plotting individual graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Connected components of metric graph — graph_components","text":"ggplot object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Connected components of metric graph — graph_components","text":"objects class cloneable method.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Connected components of metric graph — graph_components","text":"","code":"graph_components$clone(deep = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Connected components of metric graph — graph_components","text":"deep Whether make deep clone.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_components.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Connected components of metric graph — graph_components","text":"","code":"library(sp) edge1 <- rbind(c(0, 0), c(1, 0)) edge2 <- rbind(c(1, 0), c(2, 0)) edge3 <- rbind(c(1, 1), c(2, 1)) edges <- list(edge1, edge2, edge3)  graphs <- graph_components$new(edges) #> Starting graph creation... #> LongLat is set to FALSE #> The current tolerances are: #> \t Vertex-Vertex 0.001 #> \t Vertex-Edge 0.001 #> \t Edge-Edge 0 #> Setup edges and merge close vertices #> Snap vertices to close edges #> Total construction time: 0.78 secs #> Starting graph creation... #> LongLat is set to FALSE #> The current tolerances are: #> \t Vertex-Vertex 0.001 #> \t Vertex-Edge 0.001 #> \t Edge-Edge 0 #> Setup edges and merge close vertices #> Snap vertices to close edges #> Total construction time: 0.75 secs #> Starting graph creation... #> LongLat is set to FALSE #> The current tolerances are: #> \t Vertex-Vertex 0.001 #> \t Vertex-Edge 0.001 #> \t Edge-Edge 0 #> Setup edges and merge close vertices #> Total construction time: 0.37 secs graphs$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Data extraction for 'spde' models — graph_data_spde","title":"Data extraction for 'spde' models — graph_data_spde","text":"Extracts data metric graphs used 'INLA' 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data extraction for 'spde' models — graph_data_spde","text":"","code":"graph_data_spde(   graph_spde,   name = \"field\",   repl = NULL,   repl_col = NULL,   group = NULL,   group_col = NULL,   likelihood_col = NULL,   resp_col = NULL,   covariates = NULL,   only_pred = FALSE,   loc_name = NULL,   tibble = FALSE,   drop_na = FALSE,   drop_all_na = TRUE,   loc = deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data extraction for 'spde' models — graph_data_spde","text":"graph_spde inla_metric_graph_spde object built graph_spde() function. name character string base name effect. repl replicates? replicates, one can set repl NULL. one wants replicates, one sets repl .. repl_col Column containing replicates. replicate internal group variable, default NULL can used. group groups? groups, one can set group NULL. one wants groups, one sets group .. group_col \"column\" data contains group variable? likelihood_col single likelihood, variable NULL. case multiple likelihoods, column contains variable indicating number likelihood considered? resp_col single likelihood, variable NULL. case multiple likelihoods, column containing response variable. covariates Vector containing column names covariates. covariates, NULL. only_pred return data.frame prediction data? loc_name Character name location variable used 'inlabru' prediction. tibble data returned tidyr::tibble? drop_na rows least one NA one columns removed? DEFAULT FALSE. option turned FALSE only_pred TRUE. drop_all_na rows variables NA removed? DEFAULT TRUE. option turned FALSE only_pred TRUE. loc Use loc_name instead.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_data_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data extraction for 'spde' models — graph_data_spde","text":"'INLA' 'inlabru' friendly list data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn fields on metric graphs — graph_lgcp","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn fields on metric graphs — graph_lgcp","text":"Simulation log-Gaussian Cox processes driven Whittle-Matérn fields metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn fields on metric graphs — graph_lgcp","text":"","code":"graph_lgcp(n = 1, intercept = 0, sigma, range, alpha, graph)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn fields on metric graphs — graph_lgcp","text":"n Number samples. intercept Mean value Gaussian process. sigma Parameter marginal standard deviations. range Parameter practical correlation range. alpha Smoothness parameter (1 2). graph metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lgcp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of log-Gaussian Cox processes driven by Whittle-Matérn fields on metric graphs — graph_lgcp","text":"List Gaussian process sample simulated points.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph linear mixed effects models — graph_lme","title":"Metric graph linear mixed effects models — graph_lme","text":"Fitting linear mixed effects model metric graphs. random effects can Gaussian Whittle-Matern fields, discrete Gaussian Markov random fields based graph Laplacian, well Gaussian random fields isotropic covariance functions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph linear mixed effects models — graph_lme","text":"","code":"graph_lme(   formula,   graph,   model = list(type = \"linearModel\"),   which_repl = NULL,   optim_method = \"L-BFGS-B\",   possible_methods = \"L-BFGS-B\",   model_options = list(),   BC = 0,   previous_fit = NULL,   fix_coeff = FALSE,   parallel = FALSE,   n_cores = parallel::detectCores() - 1,   optim_controls = list(),   improve_hessian = FALSE,   hessian_args = list(),   check_euclidean = TRUE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph linear mixed effects models — graph_lme","text":"formula Formula object describing relation response variables fixed effects. graph metric_graph object. model random effects model used (also includes option random effects). can either character, whose options 'lm', linear models without random effects; 'WM1' 'WM2' Whittle-Matern models \\(\\alpha\\)=1 2, exact precision matrices, respectively; 'WM' Whittle-Matern models one also estimates smoothness parameter via finite-element method; 'isoExp' model isotropic exponential covariance; 'GL1' 'GL2' SPDE model based graph Laplacian \\(\\alpha\\) = 1 2, respectively. 'WMD1' directed Whittle-Matern  \\(\\alpha\\)=1. also option provide list containing elements type, can linearModel, WhittleMatern, graphLaplacian isoCov. linearModel corresponds linear model without random effects. WhittleMatern models, , list contains type = 'WhittleMatern', one can choose finite element approximation precision matrix adding fem = TRUE list, use exact precision matrix (setting fem = FALSE). fem FALSE, also parameter alpha, determine order SPDE, either 1 2. fem FALSE alpha specified, default value alpha=1 used. fem TRUE one specify alpha, estimated data. However, one wants alpha fixed value, user can specify either alpha nu list. See vignettes examples. Finally, type 'WhittleMatern', optional argument, rspde_order, chooses order rational approximation. default rspde_order 2. Finally, one wants fit nonstationary model, fem necessarily needs TRUE, one needs also supply matrices B.tau B.kappa B.range B.sigma. graph-Laplacian models, list must also contain parameter alpha (1 default). isoCov models, list must contain parameter cov_function, containing covariance function. function accepts string input following covariance functions: 'exp_covariance', 'WM1', 'WM2', 'GL1', 'GL2'. another covariance function, function must provided cov_function argument. default 'exp_covariance', exponential covariance. also covariance-based versions Whittle-Matern graph Laplacian models, however much slower, following (string) values 'cov_function': 'alpha1' 'alpha2' Whittle-Matern fields, 'GL1' 'GL2' graph Laplacian models. Finally, Whittle-Matern models, additional parameter version, can either 1 2, tell version likelihood used. Version 1 default. which_repl Vector list containing replicates consider model. NULL replicates considered. optim_method method used optim function. possible_methods methods try case optimization fails hessian positive definite. options 'Nelder-Mead', 'L-BFGS-B', 'BFGS', 'CG' 'SANN'. default 'L-BFGS-B' considered. model_options list containing additional options used model. Currently, possible fix parameters estimation change starting values parameters. general structure elements list fix_parname start_parname, parname stands name parameter. fix_parname NULL, model fitted parname fixed value passed. start_parname NULL, model fitted using value passed starting value parname. 'WM' models, possible elements list : fix_sigma_e, start_sigma_e, fix_nu, start_nu, fix_sigma, start_sigma, fix_range, start_range. Alternatively, one can use fix_sigma_e, start_sigma_e, fix_nu, start_nu, fix_tau, start_tau, fix_kappa, start_kappa. 'WM1', 'WM2', 'isoExp', 'GL1' 'GL2' models, possible elements list fix_sigma_e, start_sigma_e, fix_sigma, start_sigma, fix_range, start_range. Alternatively, one can use fix_sigma_e, start_sigma_e, fix_tau, start_tau, fix_kappa, start_kappa. 'isoCov' models, possible values fix_sigma_e, start_sigma_e, fix_par_vec, start_par_vec. Observe contrary models, 'isoCov' models, fix_par_vec start_par_vec given vectors size dimension vector input covariance function passed 'isoCov' model. Furthermore, 'isoCov' models, fix_par_vec logical vector, indicating parameters fixed, values kept fixed values given start_par_vec, one can also use fix_sigma_e start_sigma_e controlling std. deviation measurement error. BC WhittleMatern models, decides boundary condition use (0,1). , 0 Neumann boundary conditions 1 specifies stationary boundary conditions. previous_fit object class graph_lme. Use fitted coefficients starting values. fix_coeff using previous fit, coefficients fixed starting values? parallel logical. Indicating whether use optimParallel() . n_cores Number cores used parallel true. optim_controls Additional controls passed optim() optimParallel(). improve_hessian precise estimate hessian obtained? Turning might increase overall time. hessian_args List controls used improve_hessian TRUE. list can contain arguments passed method.args argument hessian function. See help hessian function 'numDeriv' package details. Observet accepts \"Richardson\" method now, method \"complex\" supported. check_euclidean Check graph used compute resistance distance Euclidean edges? graph used compute resistance distance observation locations vertices.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metric graph linear mixed effects models — graph_lme","text":"list containing fitted model.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"function creates 'INLA' object can used 'INLA' 'inlabru' fit Whittle-Matérn fields metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"","code":"graph_spde(   graph_object,   alpha = 1,   stationary_endpoints = \"all\",   parameterization = c(\"matern\", \"spde\"),   start_range = NULL,   prior_range = NULL,   start_kappa = NULL,   prior_kappa = NULL,   start_sigma = NULL,   prior_sigma = NULL,   start_tau = NULL,   prior_tau = NULL,   shared_lib = \"detect\",   debug = FALSE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"graph_object metric_graph object. alpha order SPDE. stationary_endpoints vertices degree 1 contain stationary boundary conditions? Set \"\" vertices degree 1, \"none\" none vertices degree 1, pass indices vertices degree 1 stationary conditions desired. parameterization parameterization used? options 'matern' (sigma range) 'spde' (sigma kappa). start_range Starting value range parameter. prior_range list containing elements meanlog sdlog, , mean standard deviation range parameter log scale. used prior.kappa non-null. start_kappa Starting value kappa. prior_kappa list containing elements meanlog sdlog, , mean standard deviation kappa log scale. start_sigma Starting value sigma. prior_sigma list containing elements meanlog sdlog, , mean standard deviation sigma log scale. start_tau Starting value tau. prior_tau list containing elements meanlog sdlog, , mean standard deviation tau log scale. shared_lib shared lib use cgeneric implementation? \"detect\", check shared lib exists locally, case use . Otherwise use 'INLA's shared library. 'INLA', use shared lib 'INLA's installation. 'rSPDE', use local installation rSPDE package (work installation CRAN). Otherwise, can directly supply path .(.dll) file. debug debug displayed?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"'INLA' object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"'INLA' implementation of Whittle-Matérn fields for metric graphs — graph_spde","text":"function used construct Matern SPDE model metric graph. latent field \\(u\\) solution SPDE $$(\\kappa^2 - \\Delta)^\\alpha u = \\sigma W,$$ \\(W\\) Gaussian white noise metric graph. model implements exactly cases \\(\\alpha = 1\\) \\(\\alpha = 2\\). finite element approximation general \\(\\alpha\\) refer reader 'rSPDE' package Whittle--Matérn fields general smoothness vignette. also alternative parameterization \\(\\rho = \\frac{\\sqrt{8(\\alpha-0.5)}}{\\kappa}\\), can interpreted range parameter. Let \\(\\kappa_0\\) \\(\\sigma_0\\) starting values \\(\\kappa\\) \\(\\sigma\\), write \\(\\sigma = \\exp\\{\\theta_1\\}\\) \\(\\kappa = \\exp\\{\\theta_2\\}\\). assume priors \\(\\theta_1\\) \\(\\theta_2\\) normally distributed mean, respectively, \\(\\log(\\sigma_0)\\) \\(\\log(\\kappa_0)\\), variance 10. Similarly, let \\(\\rho_0\\) starting value \\(\\rho\\), write \\(\\rho = \\exp\\{\\theta_2\\}\\) assume normal prior \\(\\theta_2\\), mean \\(\\log(\\rho_0)\\) variance 10.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_basis.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_basis","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_basis","text":"Constructs observation/prediction weight matrices metric graph models.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_basis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_basis","text":"","code":"graph_spde_basis(graph_spde, repl = NULL, drop_na = FALSE, drop_all_na = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_basis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_basis","text":"graph_spde inla_metric_graph_spde object built graph_spde() function. repl replicates? replicates, use replicates, one can set NULL. drop_na rows least one NA one columns removed? DEFAULT FALSE. drop_all_na rows variables NA removed? DEFAULT TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_basis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_basis","text":"observation matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_make_A","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_make_A","text":"Constructs observation/prediction weight matrices metric graph models.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_make_A","text":"","code":"graph_spde_make_A(graph_spde, repl = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_make_A","text":"graph_spde inla_metric_graph_spde object built graph_spde() function. repl replicates? replicates, use replicates, one can set NULL.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_spde_make_A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deprecated - Observation/prediction matrices for 'SPDE' models — graph_spde_make_A","text":"observation matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Starting values for random field models on metric graphs — graph_starting_values","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"Computes appropriate starting values optimization Gaussian random field models metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"","code":"graph_starting_values(   graph,   model = c(\"alpha1\", \"alpha2\", \"isoExp\", \"GL1\", \"GL2\"),   data = TRUE,   data_name = NULL,   range_par = FALSE,   nu = FALSE,   manual_data = NULL,   like_format = FALSE,   log_scale = FALSE,   model_options = list(),   rec_tau = TRUE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"graph metric_graph object. model Type model, \"alpha1\", \"alpha2\", \"isoExp\", \"GL1\", \"GL2\" supported. data data used obtain improved starting values? data_name name response variable graph$data. range_par initial value range parameter returned instead kappa? nu initial value nu returned? manual_data vector (matrix) response variables. like_format starting values returned sigma.e last element? format likelihood constructor 'rSPDE' package. log_scale initial values returned log scale? model_options List object containing model options. rec_tau starting value reciprocal tau given?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/graph_starting_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Starting values for random field models on metric graphs — graph_starting_values","text":"vector, c(start_sigma_e, start_sigma, start_kappa)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/logo_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Create lines for package name — logo_lines","title":"Create lines for package name — logo_lines","text":"Create lines package name","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/logo_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create lines for package name — logo_lines","text":"","code":"logo_lines()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/logo_lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create lines for package name — logo_lines","text":"SpatialLines object package name.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":null,"dir":"Reference","previous_headings":"","what":"Space-time precision operator Euler discretization — make_Q_euler","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"precision matrix vertices space-time field","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"","code":"make_Q_euler(graph, t, kappa, rho, gamma, alpha, beta, sigma, theta = 1)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"graph metric_graph object. t Vector time points. kappa Spatial range parameter. rho Drift parameter. gamma Temporal range parameter. alpha Smoothness parameter (integer) spatial operator. beta Smoothness parameter (integer) Q-Wiener process. sigma Variance parameter. theta Parameter theta Euler scheme.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_euler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Space-time precision operator Euler discretization — make_Q_euler","text":"Precision matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Space-time precision operator discretization — make_Q_spacetime","title":"Space-time precision operator discretization — make_Q_spacetime","text":"precision matrix vertices space-time field.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Space-time precision operator discretization — make_Q_spacetime","text":"","code":"make_Q_spacetime(graph, t, kappa, rho, gamma, alpha, beta, sigma)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Space-time precision operator discretization — make_Q_spacetime","text":"graph metric_graph object. t Vector time points. kappa Spatial range parameter. rho Drift parameter. gamma Temporal range parameter. alpha Smoothness parameter (integer) spatial operator. beta Smoothness parameter (integer) Q-Wiener process. sigma Variance parameter.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/make_Q_spacetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Space-time precision operator discretization — make_Q_spacetime","text":"Precision matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph — metric_graph","title":"Metric graph — metric_graph","text":"Class representing general metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metric graph — metric_graph","text":"Object R6Class creating metric graphs.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"graph object created vertex edge matrices, sp::SpatialLines object line representing edge. details, see vignette: vignette(\"metric_graph\", package = \"MetricGraph\")","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"public-fields","dir":"Reference","previous_headings":"","what":"Public fields","title":"Metric graph — metric_graph","text":"V Matrix positions Euclidean space vertices graph. nV number vertices. E Matrix edges graph, row represents edge, E[,1] vertex start ith edge E[,2] vertex end edge. nE number edges. edge_lengths Vector lengths edges graph. C Constraint matrix used set Kirchhoff constraints. CoB Change--basis object used Kirchhoff constraints. PtV Vector indices vertices observation locations. mesh Mesh object used plotting. edges coordinates edges graph. vertices coordinates vertices graph, along several attributes. geo_dist Geodesic distances vertices graph. res_dist Resistance distances observation locations. Laplacian weighted graph Laplacian vertices graph. weights given edge lengths. characteristics List various characteristics graph.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Metric graph — metric_graph","text":"metric_graph$new() metric_graph$set_edge_weights() metric_graph$get_edge_weights() metric_graph$get_vertices_incomp_dir() metric_graph$summary() metric_graph$print() metric_graph$compute_characteristics() metric_graph$check_euclidean() metric_graph$check_distance_consistency() metric_graph$compute_geodist() metric_graph$compute_geodist_PtE() metric_graph$compute_geodist_mesh() metric_graph$compute_resdist() metric_graph$compute_resdist_PtE() metric_graph$get_degrees() metric_graph$compute_PtE_edges() metric_graph$compute_resdist_mesh() metric_graph$compute_laplacian() metric_graph$prune_vertices() metric_graph$get_groups() metric_graph$get_PtE() metric_graph$get_edge_lengths() metric_graph$get_locations() metric_graph$observation_to_vertex() metric_graph$edgeweight_to_data() metric_graph$get_mesh_locations() metric_graph$clear_observations() metric_graph$process_data() metric_graph$add_observations() metric_graph$mutate() metric_graph$drop_na() metric_graph$select() metric_graph$filter() metric_graph$summarise() metric_graph$get_data() metric_graph$buildDirectionalConstraints() metric_graph$buildC() metric_graph$build_mesh() metric_graph$compute_fem() metric_graph$mesh_A() metric_graph$fem_basis() metric_graph$VtEfirst() metric_graph$plot() metric_graph$plot_connections() metric_graph$is_tree() metric_graph$plot_function() metric_graph$plot_movie() metric_graph$add_mesh_observations() metric_graph$get_initial_graph() metric_graph$coordinates() metric_graph$clone()","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Metric graph — metric_graph","text":"Create new metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$new(   edges = NULL,   V = NULL,   E = NULL,   vertex_unit = NULL,   length_unit = vertex_unit,   edge_weights = 1,   kirchhoff_weights = NULL,   longlat = FALSE,   crs = NULL,   proj4string = NULL,   which_longlat = \"sp\",   project = FALSE,   project_data = FALSE,   which_projection = \"Winkel tripel\",   tolerance = list(vertex_vertex = 0.001, vertex_edge = 0.001, edge_edge = 0),   check_connected = TRUE,   remove_deg2 = FALSE,   merge_close_vertices = TRUE,   factor_merge_close_vertices = 1,   remove_circles = TRUE,   verbose = 1,   lines = deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"edges list containing coordinates m x 2 matrices (, matrix type) m x 2 data frames (data.frame type) sequence points connected straightlines. Alternatively, can also prove object type SpatialLinesDataFrame SpatialLines (sp package) MULTILINESTRING (sf package). V n x 2 matrix Euclidean coordinates n vertices. E m x 2 matrix row represents one m edges. vertex_unit unit vertices specified. options 'degrees' (great circle distance km), 'km', 'm' 'miles'. default NULL, means unit. However, set length_unit, need set vertex_unit. length_unit unit lengths computed. options 'km', 'm' 'miles'. default vertex_unit. Observe vertex_unit NULL, length_unit can NULL. vertex_unit 'degrees', default value length_unit 'km'. edge_weights Either number, numerical vector length given number edges, providing edge weights, data.frame number rows equal number edges, row gives vector weights corresponding edge. Can changed using set_edge_weights() method. kirchhoff_weights non-null, name (number) column edge_weights contain Kirchhoff weights. Must equal 1 (TRUE) case edge_weights single number Kirchhoff weights. longlat TRUE, assumed coordinates given. Longitude/Latitude distances computed meters. TRUE takes precedence vertex_unit length_unit, equivalent vertex_unit = 'degrees' length_unit = 'm'. crs Coordinate reference system used case longlat set TRUE which_longlat sf. Object class crs. default sf::st_crs(4326). proj4string Projection string class CRS-class used case longlat set TRUE which_longlat sp. default sp::CRS(\"+proj=longlat +datum=WGS84\"). which_longlat Compute distance using package? options sp sf. default sp. project longlat TRUE projection used compute distances used tolerances (see tolerance )? default FALSE. TRUE, construction graph faster. project_data longlat TRUE vertices project planar coordinates? default FALSE. TRUE, construction graph faster. which_projection projection used case project TRUE? options Robinson, Winkel tripel proj4string. default Winkel tripel. tolerance List provides tolerances construction graph: vertex_vertex Vertices closer number merged (default = 1e-7). vertex_edge vertex end one edge closer number another edge, vertex connected edge (default = 1e-7). Previously vertex_line, now deprecated. edge_edge two edges point closer number, new vertex added point two edges connected (default = 0). vertex_line, Deprecated. Use vertex_edge instead. line_line, Deprecated. Use edge_edge instead. case longlat = TRUE, tolerances given length_unit. check_connected TRUE, checked whether graph connected warning given case. remove_deg2 Set TRUE remove vertices degree 2 initialization. Default FALSE. merge_close_vertices additional step merge close vertices done? factor_merge_close_vertices factor multiplied tolerance vertex_vertex merging close vertices additional step? remove_circles circlular edges length smaller number removed. TRUE, vertex_vertex tolerance used. FALSE, circles removed. verbose Print progress graph creation. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1. lines Use edges instead.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"graph object can initialized two ways. first method specify V E. case, edges assumed straight lines. second option specify graph via lines input. case, vertices set end points lines. Thus, two lines intersecting somewhere else, viewed vertex.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-set-edge-weights-","dir":"Reference","previous_headings":"","what":"Method set_edge_weights()","title":"Metric graph — metric_graph","text":"Sets edge weights","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$set_edge_weights(   weights = rep(1, self$nE),   kirchhoff_weights = NULL )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"weights Either number, numerical vector length given number edges, providing edge weights, data.frame number rows equal number edges, row gives vector weights corresponding edge. kirchhoff_weights non-null, name (number) column weights contain Kirchhoff weights. Must equal 1 (TRUE) case weights single number Kirchhoff weights.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-edge-weights-","dir":"Reference","previous_headings":"","what":"Method get_edge_weights()","title":"Metric graph — metric_graph","text":"Gets edge weights","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_edge_weights(data.frame = FALSE, tibble = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data.frame edge weights given vectors, result returned data.frame? tibble edge weights returned tibble?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-2","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"vector data.frame containing edge weights.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-vertices-incomp-dir-","dir":"Reference","previous_headings":"","what":"Method get_vertices_incomp_dir()","title":"Metric graph — metric_graph","text":"Gets vertices incompatible directions","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_vertices_incomp_dir()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-3","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"vector containing vertices incompatible directions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-summary-","dir":"Reference","previous_headings":"","what":"Method summary()","title":"Metric graph — metric_graph","text":"Prints summary various informations graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$summary(   messages = FALSE,   compute_characteristics = TRUE,   check_euclidean = TRUE,   check_distance_consistency = TRUE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"messages message explaining build results given missing quantities? compute_characteristics characteristics graph computed? check_euclidean Check graph Euclidean edges? check_distance_consistency Check distance consistency assumption?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-4","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Metric graph — metric_graph","text":"Prints various characteristics graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$print()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-5","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-characteristics-","dir":"Reference","previous_headings":"","what":"Method compute_characteristics()","title":"Metric graph — metric_graph","text":"Computes various characteristics graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_characteristics(check_euclidean = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"check_euclidean Also check graph Euclidean edges? essentially means distance consistency check also perfomed. graph Euclidean edges due another reason rather distance consistency, already indicated graph Euclidean edges.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-6","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. computed characteristics stored characteristics element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-check-euclidean-","dir":"Reference","previous_headings":"","what":"Method check_euclidean()","title":"Metric graph — metric_graph","text":"Check graph Euclidean edges.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$check_euclidean()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-7","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"Returns TRUE graph Euclidean edges, FALSE otherwise. result stored characteristics element metric_graph object. result displayed graph printed.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-check-distance-consistency-","dir":"Reference","previous_headings":"","what":"Method check_distance_consistency()","title":"Metric graph — metric_graph","text":"Checks distance consistency graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$check_distance_consistency()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-8","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. result stored characteristics element metric_graph object. result displayed graph printed.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-geodist-","dir":"Reference","previous_headings":"","what":"Method compute_geodist()","title":"Metric graph — metric_graph","text":"Computes shortest path distances vertices graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_geodist(   full = FALSE,   obs = TRUE,   group = NULL,   verbose = 0 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"full geodesic distances computed available locations? FALSE, computed separately locations group. obs geodesic distances computed observation locations? group Vector list containing groups compute distance . NULL, computed groups. verbose Print progress computation geodesic distances. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-9","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. computed geodesic distances stored geo_dist element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-geodist-pte-","dir":"Reference","previous_headings":"","what":"Method compute_geodist_PtE()","title":"Metric graph — metric_graph","text":"Computes shortest path distances vertices graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_geodist_PtE(   PtE,   normalized = TRUE,   include_vertices = TRUE,   verbose = 0 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Points compute metric . normalized locations PtE normalized distance? include_vertices original vertices included distance matrix? verbose Print progress computation geodesic distances. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-10","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"matrix containing geodesic distances.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-geodist-mesh-","dir":"Reference","previous_headings":"","what":"Method compute_geodist_mesh()","title":"Metric graph — metric_graph","text":"Computes shortest path distances vertices mesh.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_geodist_mesh()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-11","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. geodesic distances mesh stored mesh$geo_dist metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-resdist-","dir":"Reference","previous_headings":"","what":"Method compute_resdist()","title":"Metric graph — metric_graph","text":"Computes resistance distance observation locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_resdist(   full = FALSE,   obs = TRUE,   group = NULL,   check_euclidean = FALSE,   include_vertices = FALSE,   verbose = 0 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"full resistance distances computed available locations. FALSE, computed separately locations group. obs resistance distances computed observation locations? group Vector list containing groups compute distance . NULL, computed groups. check_euclidean Check graph used compute resistance distance Euclidean edges? graph used compute resistance distance observation locations vertices. include_vertices vertices graph also included resulting matrix using FULL=TRUE? verbose Print progress computation resistance distances. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-12","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. geodesic distances stored res_dist element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-resdist-pte-","dir":"Reference","previous_headings":"","what":"Method compute_resdist_PtE()","title":"Metric graph — metric_graph","text":"Computes resistance distance observation locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_resdist_PtE(   PtE,   normalized = TRUE,   include_vertices = FALSE,   check_euclidean = FALSE,   verbose = 0 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Points compute metric . normalized locations PtE normalized distance? include_vertices original vertices included Laplacian matrix? check_euclidean Check graph used compute resistance distance Euclidean edges? graph used compute resistance distance observation locations vertices. verbose Print progress computation resistance distances. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-13","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"matrix containing resistance distances.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-degrees-","dir":"Reference","previous_headings":"","what":"Method get_degrees()","title":"Metric graph — metric_graph","text":"Returns degrees vertices metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_degrees(which = \"degree\")"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"\"degree\", returns degree vertex. \"indegree\", returns indegree, \"outdegree\", returns outdegree.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-14","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"vector containing degrees vertices.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-pte-edges-","dir":"Reference","previous_headings":"","what":"Method compute_PtE_edges()","title":"Metric graph — metric_graph","text":"Computes relative positions coordinates edges save attribute edge. improves quality plots obtained plot_function() method, however might costly compute.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_PtE_edges()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-15","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value, called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-resdist-mesh-","dir":"Reference","previous_headings":"","what":"Method compute_resdist_mesh()","title":"Metric graph — metric_graph","text":"Computes resistance metric vertices mesh.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_resdist_mesh()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-16","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. geodesic distances mesh stored mesh$res_dist element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-laplacian-","dir":"Reference","previous_headings":"","what":"Method compute_laplacian()","title":"Metric graph — metric_graph","text":"Computes weigthed graph Laplacian graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_laplacian(   full = FALSE,   obs = TRUE,   group = NULL,   verbose = 0 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"full resistance distances computed available locations. FALSE, computed separately locations group. obs resistance distances computed observation locations? compute locations least one observations NA. group Vector list containing groups compute Laplacian . NULL, computed groups. verbose Print progress computation Laplacian. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-17","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"reutrn value. Called side effects. Laplacian stored Laplacian element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-prune-vertices-","dir":"Reference","previous_headings":"","what":"Method prune_vertices()","title":"Metric graph — metric_graph","text":"Removes vertices degree 2 metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$prune_vertices(check_weights = TRUE, verbose = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"check_weights TRUE prune edges different weights. verbose Print progress pruning. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-2","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"Vertices degree 2 removed long corresponding edges merged compatible terms direction.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-18","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-groups-","dir":"Reference","previous_headings":"","what":"Method get_groups()","title":"Metric graph — metric_graph","text":"Gets groups data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_groups(get_cols = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"get_cols names columns created group variable returned?","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-19","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"vector containing available groups internal data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-pte-","dir":"Reference","previous_headings":"","what":"Method get_PtE()","title":"Metric graph — metric_graph","text":"Gets PtE data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_PtE()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"group group, PtE returned? NULL means PtEs available returned. include_group group included column? TRUE, PtEs group concatenated, otherwise single matrix containing unique PtEs returned.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-20","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"matrix two columns, first column contains edge number second column contains distance edge observation locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-edge-lengths-","dir":"Reference","previous_headings":"","what":"Method get_edge_lengths()","title":"Metric graph — metric_graph","text":"Gets edge lengths corresponding unit.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_edge_lengths(unit = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"unit non-NULL, changes length_unit graph construction unit.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-21","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"vector length unit (graph constructed length unit).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-locations-","dir":"Reference","previous_headings":"","what":"Method get_locations()","title":"Metric graph — metric_graph","text":"Gets spatial locations data.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_locations()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-22","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"data.frame object observation locations. longlat = TRUE, column names lon lat, otherwise column names x y.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-observation-to-vertex-","dir":"Reference","previous_headings":"","what":"Method observation_to_vertex()","title":"Metric graph — metric_graph","text":"Adds observation locations vertices graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$observation_to_vertex(tolerance = 1e-15, mesh_warning = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"tolerance Observations locations merged single vertex closer number (given relative edge distance 0 1). default 1e-15. mesh_warning Display warning graph structure change metric graph mesh object. share_weights weight shared among split edges? FALSE, weights removed, common weight given 1 given.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-23","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-edgeweight-to-data-","dir":"Reference","previous_headings":"","what":"Method edgeweight_to_data()","title":"Metric graph — metric_graph","text":"Turns edge weights data metric graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$edgeweight_to_data(   loc = NULL,   mesh = FALSE,   data_loc = FALSE,   weight_col = NULL,   add = TRUE,   data_coords = c(\"PtE\", \"spatial\"),   normalized = FALSE,   tibble = TRUE,   verbose = 1,   suppress_warnings = FALSE,   return = FALSE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"loc matrix data.frame two columns containing locations generate data edge weights. data_coords 'spatial', first column must x-coordinate data, second column must y-coordinate. data_coords 'PtE', first column must edge number second column must distance edge. mesh data generated mesh locations? case, loc argument ignored. Observe metric graph must mesh built one use option. CAUTION: add edgeweight data data locations mesh locations, please, add data locations first, mesh locations. data_loc data generated data locations? case, loc argument ignored. Observe metric graph must data one use option. CAUTION: add edgeweight data data locations mesh locations, please, add data locations first, mesh locations. weight_col columns edge weights turned data? NULL, columns turned data. add data generated added metric graph internal data? data_coords used mesh FALSE. decides coordinate system use. PtE, user must provide edge_number distance_on_edge, otherwise spatial, user must provide coord_x coord_y. normalized TRUE, distances distance_on_edge assumed normalized (0,1). Default FALSE. tibble data returned tidyr::tibble? verbose Print progress steps adding observations. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1. suppress_warnings Suppress warnings related duplicated observations? return data returned? return_removed TRUE, removed locations return ().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-mesh-locations-","dir":"Reference","previous_headings":"","what":"Method get_mesh_locations()","title":"Metric graph — metric_graph","text":"Returns list matrix mesh locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_mesh_locations(bru = FALSE, loc = NULL, normalized = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"bru 'inlabru'-friendly list returned? loc bru set TRUE, name location variable. default name 'loc'. normalized TRUE, distances distance_on_edge assumed normalized (0,1). Default TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-24","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"list matrix containing mesh locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-clear-observations-","dir":"Reference","previous_headings":"","what":"Method clear_observations()","title":"Metric graph — metric_graph","text":"Clear observations metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$clear_observations()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-25","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-process-data-","dir":"Reference","previous_headings":"","what":"Method process_data()","title":"Metric graph — metric_graph","text":"Process data metric graph data format.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-27","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$process_data(   data = NULL,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   coord_x = \"coord_x\",   coord_y = \"coord_y\",   data_coords = c(\"PtE\", \"spatial\"),   group = NULL,   group_sep = \".\",   normalized = FALSE,   tibble = TRUE,   duplicated_strategy = \"closest\",   include_distance_to_graph = TRUE,   only_return_removed = FALSE,   tolerance = max(self$edge_lengths)/2,   verbose = FALSE,   suppress_warnings = FALSE,   Spoints = lifecycle::deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data data.frame named list containing observations. case groups, data.frames groups stacked vertically, column indicating index group. data NULL, takes priority eventual data Spoints. edge_number Column (entry list) data contains edge numbers. supplied, column name \"edge_number\" chosen. used Spoints NULL. distance_on_edge Column (entry list) data contains edge numbers. supplied, column name \"distance_on_edge\" chosen.  used Spoints NULL. coord_x Column (entry list) data contains x coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. coord_y Column (entry list) data contains y coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. data_coords decides coordinate system use. PtE, user must provide edge_number distance_on_edge, otherwise spatial, user must provide coord_x coord_y. option euclidean . Use spatial instead. group Vector. data grouped (example measured different time points), argument specifies columns (entries list) group variables stored. stored single column .group combined entries. group_sep separator character creating new group variable grouping two variables. normalized TRUE, distances distance_on_edge assumed normalized (0,1). Default FALSE. tibble data returned tidyr::tibble? duplicated_strategy strategy handle observations location metric graph (, two observations projected location). options 'closest' 'jitter'. 'closest', closest observation used. 'jitter', small perturbation performed projected observation location. default 'closest'. include_distance_to_graph data_coord 'spatial', distance observations graph included column? only_return_removed removed data (exists) using 'closest' duplicated_strategy returned instead processed data? tolerance Parameter control warning adding observations. distance location closest point graph greater tolerance, function display warning. helps detecting mistakes input locations adding new data. verbose TRUE, report steps times. suppress_warnings Suppress warnings related duplicated observations? Spoints Use data instead.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-26","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. observations stored data element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-add-observations-","dir":"Reference","previous_headings":"","what":"Method add_observations()","title":"Metric graph — metric_graph","text":"Add observations metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-28","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$add_observations(   data = NULL,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   coord_x = \"coord_x\",   coord_y = \"coord_y\",   data_coords = c(\"PtE\", \"spatial\"),   group = NULL,   group_sep = \".\",   normalized = FALSE,   clear_obs = FALSE,   tibble = FALSE,   tolerance = max(self$edge_lengths)/2,   duplicated_strategy = \"closest\",   include_distance_to_graph = TRUE,   return_removed = TRUE,   verbose = 1,   suppress_warnings = FALSE,   Spoints = lifecycle::deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-19","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data data.frame named list containing observations. case groups, data.frames groups stacked vertically, column indicating index group. data can also sf object SpatialPointsDataFrame object. case data_coords automatically spatial, need specify coord_x coord_y arguments. edge_number Column (entry list) data contains edge numbers. supplied, column name \"edge_number\" chosen. used Spoints NULL. distance_on_edge Column (entry list) data contains edge numbers. supplied, column name \"distance_on_edge\" chosen.  used Spoints NULL. coord_x Column (entry list) data contains x coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. coord_y Column (entry list) data contains y coordinate. supplied, column name \"coord_x\" chosen. used Spoints NULL data_coords PtE. data_coords decides coordinate system use. PtE, user must provide edge_number distance_on_edge, otherwise spatial, user must provide coord_x coord_y. option euclidean . Use spatial instead. group Vector. data grouped (example measured different time points), argument specifies columns (entries list) group variables stored. stored single column .group combined entries. group_sep separator character creating new group variable grouping two variables. normalized TRUE, distances distance_on_edge assumed normalized (0,1). Default FALSE. clear_obs existing observations removed adding data? tibble data returned tidyr::tibble? tolerance Parameter control warning adding observations. distance location closest point graph greater tolerance, function display warning. helps detecting mistakes input locations adding new data. duplicated_strategy strategy handle observations location metric graph (, two observations projected location). options 'closest' 'jitter'. 'closest', closest observation used. 'jitter', small perturbation performed projected observation location. default 'closest'. include_distance_to_graph data_coord 'spatial', distance observations graph included column? return_removed removed data (exists) using 'closest' duplicated_strategy returned? verbose Print progress steps adding observations. 3 levels verbose, level 0, 1 2. level 0, messages printed. level 1, messages regarding important steps printed. Finally, level 2, messages detailing steps printed. default 1. suppress_warnings Suppress warnings related duplicated observations? Spoints Use data instead.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-27","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. observations stored data element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-mutate-","dir":"Reference","previous_headings":"","what":"Method mutate()","title":"Metric graph — metric_graph","text":"Use dplyr::mutate function internal metric graph data object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-29","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$mutate(..., .drop_na = FALSE, .drop_all_na = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-20","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"... Arguments passed dplyr::mutate(). .drop_na rows least one NA one columns removed? DEFAULT FALSE. .drop_all_na rows variables NA removed? DEFAULT TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-3","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"wrapper use dplyr::mutate() within internal metric graph data object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-28","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"tidyr::tibble object containing resulting data list mutate.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-drop-na-","dir":"Reference","previous_headings":"","what":"Method drop_na()","title":"Metric graph — metric_graph","text":"Use tidyr::drop_na() function internal metric graph data object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-30","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$drop_na(...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-21","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"... Arguments passed tidyr::drop_na().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-4","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"wrapper use dplyr::drop_na() within internal metric graph data object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-29","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"tidyr::tibble object containing resulting data list drop_na.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-select-","dir":"Reference","previous_headings":"","what":"Method select()","title":"Metric graph — metric_graph","text":"Use dplyr::select function internal metric graph data object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-31","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$select(..., .drop_na = FALSE, .drop_all_na = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-22","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"... Arguments passed dplyr::select(). .drop_na rows least one NA one columns removed? DEFAULT FALSE. .drop_all_na rows variables NA removed? DEFAULT TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-5","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"wrapper use dplyr::select() within internal metric graph data object. Observe bit different directly using dplyr::select() since allow remove internal positions needed metric_graph methods work.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-30","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"tidyr::tibble object containing resulting data list selection.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-filter-","dir":"Reference","previous_headings":"","what":"Method filter()","title":"Metric graph — metric_graph","text":"Use dplyr::filter function internal metric graph data object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-32","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$filter(..., .drop_na = FALSE, .drop_all_na = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-23","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"... Arguments passed dplyr::filter(). .drop_na rows least one NA one columns removed? DEFAULT FALSE. .drop_all_na rows variables NA removed? DEFAULT TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-6","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"wrapper use dplyr::filter() within internal metric graph data object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-31","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"tidyr::tibble object containing resulting data list filter.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-summarise-","dir":"Reference","previous_headings":"","what":"Method summarise()","title":"Metric graph — metric_graph","text":"Use dplyr::summarise function internal metric graph data object grouped spatial locations internal group variable.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-33","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$summarise(   ...,   .include_graph_groups = FALSE,   .groups = NULL,   .drop_na = FALSE,   .drop_all_na = TRUE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-24","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"... Arguments passed dplyr::summarise(). .include_graph_groups internal graph groups included grouping variables? default FALSE. means , summarising, data grouped internal group variable together spatial locations. .groups vector strings containing names columns additionally grouped, computing summaries. default NULL. .drop_na rows least one NA one columns removed? DEFAULT FALSE. .drop_all_na rows variables NA removed? DEFAULT TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-7","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"wrapper use dplyr::summarise() within internal metric graph data object grouped manually inserted groups (optional), internal group variable (optional) spatial locations. Observe integral group variable used grouping variable summarise, new column, called .group, added, value 1 rows.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-32","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"tidyr::tibble object containing resulting data list summarise.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-data-","dir":"Reference","previous_headings":"","what":"Method get_data()","title":"Metric graph — metric_graph","text":"Return internal data option filter groups.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-34","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_data(   group = NULL,   tibble = TRUE,   drop_na = FALSE,   drop_all_na = TRUE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-25","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"group vector contaning groups returned? default NULL, gives result groups. tibble data returned tidyr::tibble? drop_na rows least one NA one columns removed? DEFAULT FALSE. drop_all_na rows variables NA removed? DEFAULT TRUE.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-builddirectionalconstraints-","dir":"Reference","previous_headings":"","what":"Method buildDirectionalConstraints()","title":"Metric graph — metric_graph","text":"Build directional ODE constraint matrix edges.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-35","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$buildDirectionalConstraints(alpha = 1)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-26","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"alpha many derivatives processes ","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-8","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"Currently implemented circles (edges start end vertex)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-33","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-buildc-","dir":"Reference","previous_headings":"","what":"Method buildC()","title":"Metric graph — metric_graph","text":"Build Kirchoff constraint matrix edges.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-36","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$buildC(alpha = 2, edge_constraint = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-27","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"alpha type constraint (currently supports 2) edge_constraint TRUE, add constraints vertices degree 1","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-9","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"Currently implemented circles (edges start end vertex)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-34","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-build-mesh-","dir":"Reference","previous_headings":"","what":"Method build_mesh()","title":"Metric graph — metric_graph","text":"Builds mesh object graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-37","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$build_mesh(   h = NULL,   n = NULL,   continuous = TRUE,   continuous.outs = FALSE,   continuous.deg2 = FALSE )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-28","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"h Maximum distance mesh nodes (provided n provided). n Maximum number nodes per edge (provided h provided). continuous TRUE (default), mesh contains one node per vertex. FALSE, vertex v split deg(v) disconnected nodes allow creation discontinuities vertices. continuous.outs continuous = FALSE continuous.outs = TRUE, continuity assumed outgoing edges vertex. continuous.deg2 TRUE, continuity assumed degree 2 vertices.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-10","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"mesh list objects: PtE mesh locations excluding original vertices; V verties mesh; E edges mesh; n_e number vertices mesh per original edge graph; h_e mesh width per edge graph; ind indices vertices mesh; VtE mesh locations including original vertices.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-35","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. mesh stored mesh element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-compute-fem-","dir":"Reference","previous_headings":"","what":"Method compute_fem()","title":"Metric graph — metric_graph","text":"Build mass stiffness matrices given mesh object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-38","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$compute_fem(petrov = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-29","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"petrov Compute Petrov-Galerkin matrices? (default FALSE). defined \\(Cpet_{ij} = <\\phi_i, \\psi_j>\\) \\(Gpet_{ij} = <d\\phi_i, \\psi_j>\\), \\(\\psi_{}\\) piecewise constant basis functions edges mesh.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-11","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"function builds: matrix C mass matrix elements \\(C_{ij} = <\\phi_i, \\phi_j>\\), matrix G stiffness matrix elements \\(G_{ij} = <d\\phi_i, d\\phi_j>\\), matrix B elements \\(B_{ij} = <d\\phi_i, \\phi_j>\\), matrix D elements \\(D_{ij} = \\sum_{v\\V}\\phi_i(v)\\phi_j(v)\\), vector weights \\(<\\phi_i, 1>\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-36","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. finite element matrices C, G B stored mesh element metric_graph object. petrov=TRUE, corresponding Petrov-Galerkin matrices stored Cpet Gpet.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-mesh-a-","dir":"Reference","previous_headings":"","what":"Method mesh_A()","title":"Metric graph — metric_graph","text":"Deprecated - Computes observation matrix mesh. favour metric_graph$fem_basis().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-39","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$mesh_A(PtE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-30","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Locations given (edge number graph, normalized location edge)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-12","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"n locations mesh m nodes, n x m matrix elements \\(A_{ij} = \\phi_j(s_i)\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-37","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"observation matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-fem-basis-","dir":"Reference","previous_headings":"","what":"Method fem_basis()","title":"Metric graph — metric_graph","text":"Computes observation matrix mesh.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-40","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$fem_basis(PtE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-31","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Locations given (edge number graph, normalized location edge)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"details-13","dir":"Reference","previous_headings":"","what":"Details","title":"Metric graph — metric_graph","text":"n locations mesh m nodes, n x m matrix elements \\(A_{ij} = \\phi_j(s_i)\\).","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-38","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"observation matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-vtefirst-","dir":"Reference","previous_headings":"","what":"Method VtEfirst()","title":"Metric graph — metric_graph","text":"Find one edge corresponding vertex.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-41","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$VtEfirst()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-39","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"nV x 2 matrix first element ith row edge number corresponding ith vertex second value 0 vertex start edge 1 vertex end edge.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Metric graph — metric_graph","text":"Plots metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-42","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot(   data = NULL,   newdata = NULL,   group = 1,   plotly = FALSE,   interactive = FALSE,   vertex_size = 3,   vertex_color = \"black\",   edge_width = 0.3,   edge_color = \"black\",   data_size = 1,   support_width = 0.5,   support_color = \"gray\",   mesh = FALSE,   X = NULL,   X_loc = NULL,   p = NULL,   degree = FALSE,   direction = FALSE,   edge_weight = NULL,   edge_width_weight = NULL,   scale_color_main = ggplot2::scale_color_viridis_c(option = \"D\"),   scale_color_weights = ggplot2::scale_color_viridis_c(option = \"C\"),   scale_color_degree = ggplot2::scale_color_viridis_d(option = \"D\"),   add_new_scale_weights = TRUE,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-32","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data column data plot? NULL, data plotted. newdata dataset class metric_graph_data, obtained get_data(), mutate(), filter(), summarise(), drop_na() methods metric graphs, see vignette data manipulation details. group groups, group plot? group number newdata NULL, index group stored internally newdata provided, index group stored newdata. group character, group chosen name. plotly Use plot_ly 3D plot (default FALSE). option requires 'plotly' package. interactive works 2d plots. TRUE, interactive plot displayed. Unfortunately, interactive compatible edge_weight add_new_scale_weights TRUE. vertex_size Size vertices. vertex_color Color vertices. edge_width Line width edges. edge_width_weight NULL, determines maximum edge width. edge_color Color edges. data_size Size markers data. support_width 3D plot, width support lines. support_color 3D plot, color support lines. mesh Plot mesh locations? X Additional values plot. X_loc Locations additional values format (edge, normalized distance edge). p Existing objects obtained 'ggplot2' 'plotly' add graph degree Show degrees vertices? direction Show direction edges? edge_weight column edge weights plot? NULL edge weights plotted. plot edge weights metric graph edge_weights vector instead data.frame, simply set 1. edge_weight available 2d plots. 3d plots edge weights, please use plot_function() method. edge_width_weight column edge weights determine edges widths? NULL edge width determined edge_width. scale_color_main Color scale data plotted. scale_color_weights Color scale edge weights. used add_new_scale_weights TRUE. scale_color_degree Color scale degrees. add_new_scale_weights new color scale edge weights created? ... Additional arguments pass ggplot() plot_ly()","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-40","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"plot_ly (plotly = TRUE) ggplot object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-connections-","dir":"Reference","previous_headings":"","what":"Method plot_connections()","title":"Metric graph — metric_graph","text":"Plots connections graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-43","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot_connections()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-41","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-is-tree-","dir":"Reference","previous_headings":"","what":"Method is_tree()","title":"Metric graph — metric_graph","text":"Checks graph tree (without considering directions)","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-44","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$is_tree()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-42","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"TRUE graph tree FALSE otherwise.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-function-","dir":"Reference","previous_headings":"","what":"Method plot_function()","title":"Metric graph — metric_graph","text":"Plots continuous function graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-45","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot_function(   data = NULL,   newdata = NULL,   group = 1,   X = NULL,   plotly = FALSE,   improve_plot = FALSE,   continuous = TRUE,   edge_weight = NULL,   vertex_size = 5,   vertex_color = \"black\",   edge_width = 1,   edge_color = \"black\",   line_width = NULL,   line_color = \"rgb(0,0,200)\",   scale_color = ggplot2::scale_color_viridis_c(option = \"D\"),   support_width = 0.5,   support_color = \"gray\",   p = NULL,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-33","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data column data plot? NULL, data plotted. newdata dataset class metric_graph_data, obtained get_data(), mutate(), filter(), summarise(), drop_na() methods metric graphs, see vignette data manipulation details. group groups, group plot? group number, index group stored internally. group character, group chosen name. X vector values function evaluated mesh graph plotly TRUE, plot shown 3D. option requires package 'plotly'. improve_plot original edge coordinates added data linearly interpolated values improve plot? continuous continuity assumed plot uses newdata? edge_weight column edge weights plot? NULL edge weights plotted. plot edge weights metric graph edge_weights vector instead data.frame, simply set 1. vertex_size Size vertices. vertex_color Color vertices. edge_width Width edges. edge_color 3D plot, color edges. line_width 3D plot, line width function curve. line_color Color function curve. scale_color Color scale used data weights. support_width 3D plot, width support lines. support_color 3D plot, color support lines. p Previous plot new plot added. ... Additional arguments ggplot() plot_ly()","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-43","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"Either ggplot (plotly = FALSE) plot_ly object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-plot-movie-","dir":"Reference","previous_headings":"","what":"Method plot_movie()","title":"Metric graph — metric_graph","text":"Plots movie continuous function evolving graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-46","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$plot_movie(   X,   plotly = TRUE,   vertex_size = 5,   vertex_color = \"black\",   edge_width = 1,   edge_color = \"black\",   line_width = NULL,   line_color = \"rgb(0,0,200)\",   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-34","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"X m x T matrix ith column represents function ith time, evaluated mesh locations. plotly TRUE, plot shown 3D. option requires package 'plotly'. vertex_size Size vertices. vertex_color Color vertices. edge_width Width edges. edge_color 3D plot, color edges. line_width 3D plot, line width function curve. line_color Color function curve. ... Additional arguments ggplot plot_ly.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-44","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"Either ggplot (plotly=FALSE) plot_ly object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-add-mesh-observations-","dir":"Reference","previous_headings":"","what":"Method add_mesh_observations()","title":"Metric graph — metric_graph","text":"Add observations mesh object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-47","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$add_mesh_observations(data = NULL, group = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-35","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"data data.frame named list containing observations. case groups, data.frames groups stacked vertically, column indicating index group. data_frame NULL, takes priority eventual data Spoints. group data_frame contains groups, one must provide column group indices stored.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-45","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"return value. Called side effects. observations stored data element metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-get-initial-graph-","dir":"Reference","previous_headings":"","what":"Method get_initial_graph()","title":"Metric graph — metric_graph","text":"Returns copy initial metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-48","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$get_initial_graph()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-46","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-coordinates-","dir":"Reference","previous_headings":"","what":"Method coordinates()","title":"Metric graph — metric_graph","text":"Convert locations graph Euclidean coordinates.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-49","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$coordinates(PtE = NULL, XY = NULL, normalized = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-36","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"PtE Matrix locations graph (edge number normalized position edge). XY Matrix locations Euclidean space normalized TRUE, assumed positions PtE normalized (0,1), object returned XY specified contains normalized locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"returns-47","dir":"Reference","previous_headings":"","what":"Returns","title":"Metric graph — metric_graph","text":"PtE specified, matrix Euclidean coordinates locations returned. XY provided, matrix closest locations graph returned. Gets edge weights data.frame edge weights given vectors, result returned data.frame? vector data.frame containing edge weights. data List containing data metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Metric graph — metric_graph","text":"objects class cloneable method.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"usage-50","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph — metric_graph","text":"","code":"metric_graph$clone(deep = FALSE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"arguments-37","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph — metric_graph","text":"deep Whether make deep clone.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/metric_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Metric graph — metric_graph","text":"","code":"edge1 <- rbind(c(0, 0), c(2, 0)) edge2 <- rbind(c(2, 0), c(1, 1)) edge3 <- rbind(c(1, 1), c(0, 0)) edges <- list(edge1, edge2, edge3) graph <- metric_graph$new(edges) #> Starting graph creation... #> LongLat is set to FALSE #> The current tolerances are: #> \t Vertex-Vertex 0.001 #> \t Vertex-Edge 0.001 #> \t Edge-Edge 0 #> Setup edges and merge close vertices #> Snap vertices to close edges #> Total construction time: 0.82 secs graph$plot()"},{"path":"https://davidbolin.github.io/MetricGraph/reference/mutate.metric_graph_data.html","id":null,"dir":"Reference","previous_headings":"","what":"A version of dplyr::mutate() function for datasets on metric graphs — mutate.metric_graph_data","title":"A version of dplyr::mutate() function for datasets on metric graphs — mutate.metric_graph_data","text":"Applies dplyr::mutate() function datasets obtained metric graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/mutate.metric_graph_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A version of dplyr::mutate() function for datasets on metric graphs — mutate.metric_graph_data","text":"","code":"# S3 method for metric_graph_data mutate(.data, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/mutate.metric_graph_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A version of dplyr::mutate() function for datasets on metric graphs — mutate.metric_graph_data","text":".data data list tidyr::tibble obtained metric graph object. ... Additional parameters passed dplyr::mutate().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/mutate.metric_graph_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A version of dplyr::mutate() function for datasets on metric graphs — mutate.metric_graph_data","text":"tidyr::tibble resulting selected columns.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":null,"dir":"Reference","previous_headings":"","what":"Traffic speed data from San Jose, California — pems","title":"Traffic speed data from San Jose, California — pems","text":"Data set traffic speed observations highways city San Jose, California.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Traffic speed data from San Jose, California — pems","text":"","code":"pems"},{"path":[]},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"pems","dir":"Reference","previous_headings":"","what":"pems","title":"Traffic speed data from San Jose, California — pems","text":"list three elements: edges list object containing coordinates road segments. data Locations observations road segments data.frame 325 rows 2 columns. first column indicates edge number second column indicates distance edge position. Y Observations traffic speed. Consists vector 325 observations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Traffic speed data from San Jose, California — pems","text":"https://www.openstreetmap.org https://github.com/spbu-math-cs/Graph-Gaussian-Processes/blob/main/examples/data/PEMS.zip","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pems.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Traffic speed data from San Jose, California — pems","text":"Chen, C., K. Petty, . Skabardonis, P. Varaiya, Z. Jia (2001). Freeway performance measurement system: mining loop detector data. Transportation Research Record 1748(1), 96–102. OpenStreetMap contributors (2017). Planet dump retrieved https://planet.osm.org. https://www.openstreetmap.org.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See %>% details.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"Auxiliary function obtain plots predictions field using 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"","code":"# S3 method for graph_bru_pred plot(x, y = NULL, vertex_size = 0, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"x predicted object obtained predict method. y used. vertex_size Size vertices. ... Additional parameters passed plot_function.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/plot.graph_bru_pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of predicted values with 'inlabru' — plot.graph_bru_pred","text":"'ggplot2' object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":null,"dir":"Reference","previous_headings":"","what":"Leave-one-out crossvalidation for graph_lme models assuming observations at the vertices of metric graphs — posterior_crossvalidation","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at the vertices of metric graphs — posterior_crossvalidation","text":"Leave-one-crossvalidation graph_lme models assuming observations vertices metric graphs","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at the vertices of metric graphs — posterior_crossvalidation","text":"","code":"posterior_crossvalidation(object, factor = 1, tibble = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at the vertices of metric graphs — posterior_crossvalidation","text":"object fitted model using graph_lme() function named list fitted objects using graph_lme() function. factor factor multiply scores. default 1. tibble Return scores tidyr::tibble()","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/posterior_crossvalidation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leave-one-out crossvalidation for graph_lme models assuming observations at the vertices of metric graphs — posterior_crossvalidation","text":"Vector posterior expectations variances well mean absolute error (MAE), root mean squared errors (RMSE), three negatively oriented proper scoring rules: log-score, CRPS, scaled CRPS.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"Prediction mixed effects regression model metric graph","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"","code":"# S3 method for graph_lme predict(   object,   newdata = NULL,   mesh = FALSE,   mesh_h = 0.01,   which_repl = NULL,   compute_variances = FALSE,   compute_pred_variances = FALSE,   posterior_samples = FALSE,   pred_samples = FALSE,   n_samples = 100,   edge_number = \"edge_number\",   distance_on_edge = \"distance_on_edge\",   normalized = FALSE,   no_nugget = FALSE,   return_as_list = FALSE,   return_original_order = TRUE,   check_euclidean = TRUE,   ...,   data = deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"object fitted object graph_lme() function. newdata data.frame list containing covariates, edge number distance edge locations obtain prediction. Observe provide locations replicate. single set locations covariates, predictions different replicates obtained set locations. mesh Obtain predictions mesh nodes? graph must mesh covariates. mesh_h graph mesh, one created value 'h'. which_repl replicates obtain prediction. NULL predictions obtained replicates. Default NULL. compute_variances Set TRUE compute kriging variances. compute_pred_variances Set TRUE compute prediction variances. computed newdata NULL. posterior_samples TRUE, posterior samples random effect returned. pred_samples TRUE, prediction samples response variable returned. computed newdata NULL. n_samples Number samples returned. used sampling TRUE. edge_number Name variable contains edge number, default edge_number. distance_on_edge Name variable contains distance edge, default distance_on_edge. normalized distances edges normalized? no_nugget prediction carried without nugget? return_as_list means predictions posterior samples returned list, replicate element? return_original_order results return original (input) order order inside graph? check_euclidean Check graph used compute resistance distance Euclidean edges? graph used compute resistance distance observation locations vertices. ... used. data Use newdata instead.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction for a mixed effects regression model on a metric graph — predict.graph_lme","text":"list elements mean, contains means predictions, fe_mean, prediction fixed effects, re_mean, prediction random effects, variance (compute_variance TRUE), contains posterior variances random effects, samples (posterior_samples TRUE), contains posterior samples.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"Auxiliar function obtain predictions field using 'inlabru'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"","code":"# S3 method for inla_metric_graph_spde predict(   object,   cmp,   bru_fit,   newdata = NULL,   formula = NULL,   data_coords = c(\"PtE\", \"euclidean\"),   normalized = TRUE,   n.samples = 100,   seed = 0L,   probs = c(0.025, 0.5, 0.975),   return_original_order = TRUE,   num.threads = NULL,   include = NULL,   exclude = NULL,   drop = FALSE,   ...,   data = deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"object inla_metric_graph_spde object built graph_spde() function. cmp 'inlabru' component used fit model. bru_fit fitted model using 'inlabru' 'INLA'. newdata data.frame covariates needed prediction. locations must normalized PtE. formula formula right hand side defines R expression evaluate generated sample. NULL, latent hyperparameter states returned named list elements. See Details information. data_coords decides coordinate system use. PtE, user must provide locations data frame first column edge number second column distance edge, otherwise euclidean, user must provide data frame first column x Euclidean coordinates second column y Euclidean coordinates. normalized TRUE, distances distance edge assumed normalized (0,1). Default TRUE. used data_coords euclidean. n.samples Integer setting number samples draw order calculate posterior statistics. default rather low provides quick approximate result. seed Random number generator seed passed inla.posterior.sample() probs numeric vector probabilities values standard unit interval passed stats::quantile return_original_order predictions returned original order? num.threads Specification desired number threads parallel computations. Default NULL, leaves 'INLA'. seed != 0, overridden \"1:1\" include Character vector component labels needed predictor expression; Default: NULL (include components explicitly excluded) exclude Character vector component labels used predictor expression. exclusion list applied list determined include parameter; Default: NULL (remove components inclusion list) drop logical; keep=FALSE, data SpatialDataFrame, prediciton summary number rows data, output SpatialDataFrame object. Default FALSE. ... Additional arguments passed inla.posterior.sample(). data Use newdata instead.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.inla_metric_graph_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for 'inlabru' fits on Metric Graphs — predict.inla_metric_graph_spde","text":"list predictions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"Auxiliar function obtain predictions field using 'inlabru' 'rSPDE'.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"","code":"# S3 method for rspde_metric_graph predict(   object,   cmp,   bru_fit,   newdata = NULL,   formula = NULL,   data_coords = c(\"PtE\", \"euclidean\"),   normalized = TRUE,   n.samples = 100,   seed = 0L,   probs = c(0.025, 0.5, 0.975),   num.threads = NULL,   include = NULL,   exclude = NULL,   drop = FALSE,   ...,   data = deprecated() )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"object rspde_metric_graph object built rspde.metric_graph() function. cmp 'inlabru' component used fit model. bru_fit fitted model using 'inlabru' 'INLA'. newdata data.frame covariates needed prediction. locations must normalized PtE. formula formula right hand side defines R expression evaluate generated sample. NULL, latent hyperparameter states returned named list elements. See Details information. data_coords decides coordinate system use. PtE, user must provide locations data frame first column edge number second column distance edge, otherwise euclidean, user must provide data frame first column x Euclidean coordinates second column y Euclidean coordinates. normalized TRUE, distances distance edge assumed normalized (0,1). Default TRUE. used data_coords euclidean. n.samples Integer setting number samples draw order calculate posterior statistics. default rather low provides quick approximate result. seed Random number generator seed passed inla.posterior.sample probs numeric vector probabilities values standard unit interval passed stats::quantile. num.threads Specification desired number threads parallel computations. Default NULL, leaves 'INLA'. seed != 0, overridden \"1:1\" include Character vector component labels needed predictor expression; Default: NULL (include components explicitly excluded) exclude Character vector component labels used predictor expression. exclusion list applied list determined include parameter; Default: NULL (remove components inclusion list) drop logical; keep=FALSE, data SpatialDataFrame, prediciton summary number rows data, output SpatialDataFrame object. Default FALSE. ... Additional arguments passed inla.posterior.sample. data Use newdata instead.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/predict.rspde_metric_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for 'inlabru' fits on Metric Graphs for 'rSPDE' models — predict.rspde_metric_graph","text":"list predictions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":null,"dir":"Reference","previous_headings":"","what":"Samples a Whittle-Matérn field on a metric graph — sample_spde","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"Obtains samples Whittle-Matérn field metric graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"","code":"sample_spde(   kappa,   tau,   range,   sigma,   sigma_e = 0,   alpha = 1,   graph,   PtE = NULL,   type = \"manual\",   posterior = FALSE,   nsim = 1,   method = c(\"conditional\", \"Q\"),   BC = 1 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"kappa Range parameter. tau Precision parameter. range Practical correlation range parameter. sigma Marginal standard deviation parameter. sigma_e Standard deviation measurement noise. alpha Smoothness parameter. graph metric_graph object. PtE Matrix locations (edge, normalized distance edge) samples generated. type \"manual\" set, sampling done locations specified PtE. Set \"mesh\" simulation mesh nodes, \"obs\" simulation observation locations. posterior Sample conditionally observations? nsim Number samples generated. method method use sampling? options \"conditional\" \"Q\". , \"Q\" stable takes longer. BC Boundary conditions degree 1 vertices. BC = 0 gives Neumann boundary conditions BC = 1 gives stationary boundary conditions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"Matrix vector samples.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/sample_spde.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Samples a Whittle-Matérn field on a metric graph — sample_spde","text":"Samples Gaussian Whittle-Matérn field metric graph, either prior conditionally observations $$y_i = u(t_i) + \\sigma_e e_i$$ graph,  \\(e_i\\) independent standard Gaussian variables. parameters field can either specified terms tau kappa practical correlation range marginal standard deviation.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/select.metric_graph_data.html","id":null,"dir":"Reference","previous_headings":"","what":"A version of dplyr::select() function for datasets on metric graphs — select.metric_graph_data","title":"A version of dplyr::select() function for datasets on metric graphs — select.metric_graph_data","text":"Selects columns metric graphs, keeps spatial positions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/select.metric_graph_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A version of dplyr::select() function for datasets on metric graphs — select.metric_graph_data","text":"","code":"# S3 method for metric_graph_data select(.data, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/select.metric_graph_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A version of dplyr::select() function for datasets on metric graphs — select.metric_graph_data","text":".data data list tidyr::tibble obtained metric graph object. ... Additional parameters passed dplyr::select().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/select.metric_graph_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A version of dplyr::select() function for datasets on metric graphs — select.metric_graph_data","text":"tidyr::tibble resulting selected columns.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate.graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of models on metric graphs — simulate.graph_lme","title":"Simulation of models on metric graphs — simulate.graph_lme","text":"function samples Gaussian random field based fitted model using graph_lme().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate.graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of models on metric graphs — simulate.graph_lme","text":"","code":"# S3 method for graph_lme simulate(   object,   nsim = 1,   seed = NULL,   sample_latent = FALSE,   posterior = FALSE,   which_repl = NULL,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate.graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of models on metric graphs — simulate.graph_lme","text":"object graph_lme object nsim number simulations. seed object specifying random number generator initialized (‘seeded’). sample_latent FALSE, samples response variable generated. TRUE, samples latent model generated. default FALSE. posterior posterior samples generated? FALSE, samples computed based estimated prior distribution. default FALSE. which_repl replicates generate samples. NULL samples generated replicates. Default NULL. ... Currently used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate.graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of models on metric graphs — simulate.graph_lme","text":"list containing elements samples, edge_number distance_on_edge. list, whose indexes replicates, samples matrix given nsim columns, one sample. edge_number distance_on_edges contain respective edge numbers distances edge sampled element. locations samples location data model fitted.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":null,"dir":"Reference","previous_headings":"","what":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"Simulation starting value u0","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"","code":"simulate_spacetime(graph, t, kappa, rho, gamma, alpha, beta, sigma, u0, BC = 0)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"graph metric_graph object. t Vector time points. kappa Spatial range parameter. rho Drift parameter. gamma Temporal range parameter. alpha Smoothness parameter (integer) spatial operator. beta Smoothness parameter (integer) Q-Wiener process. sigma Variance parameter. u0 Starting value. BC boundary condition use (0,1). , 0 adjustment boundary 1 results making boundary condition stationary.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/simulate_spacetime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"space-time simulation based on implicit Euler discretization in time — simulate_spacetime","text":"Precision matrix.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Covariance function for Whittle-Matérn fields — spde_covariance","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"Computes covariance function Whittle-Matérn field.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"","code":"spde_covariance(P, kappa, tau, range, sigma, alpha, graph)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"P Location (edge number normalized location edge) location evaluate covariance function . kappa Parameter kappa SPDE. tau Parameter tau SPDE. range Range parameter. sigma Standard deviation parameter. alpha Smoothness parameter (1 2). graph metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"Vector covariance function evaluate mesh locations.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_covariance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Covariance function for Whittle-Matérn fields — spde_covariance","text":"Compute covariance function \\(\\rho(P,s_i)\\) P provided location \\(s_i\\) locations mesh graph.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"Extract field parameter values distributions metric graph spde effect 'INLA' result object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"","code":"spde_metric_graph_result(   inla,   name,   metric_graph_spde,   compute.summary = TRUE,   n_samples = 5000,   n_density = 1024 )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"inla 'INLA' object obtained call inla(). name character string name 'rSPDE' effect model. metric_graph_spde inla_metric_graph_spde object used random effect model. compute.summary summary computed? n_samples number samples used parameterization matern. n_density number equally spaced points estimate density.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_metric_graph_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Metric graph SPDE result extraction from 'INLA' estimation results — spde_metric_graph_result","text":"model fitted matern parameterization (default), returns list containing: marginals.range Marginal densities range parameter. marginals.log.range Marginal densities log(range). marginals.sigma Marginal densities std. deviation. marginals.log.sigma Marginal densities log(std. deviation). marginals.values Marginal densities field values. summary.log.range Summary statistics log(range). summary.log.sigma Summary statistics log(std. deviation). summary.values Summary statistics field values. compute.summary TRUE, list also contain summary.kappa Summary statistics kappa. summary.tau Summary statistics tau. model fitted spde parameterization, returns list containing: marginals.kappa Marginal densities kappa. marginals.log.kappa Marginal densities log(kappa). marginals.log.tau Marginal densities log(tau). marginals.tau Marginal densities tau. marginals.values Marginal densities field values. summary.log.kappa Summary statistics log(kappa). summary.log.tau Summary statistics log(tau). summary.values Summary statistics field values. compute.summary TRUE, list also contain summary.kappa Summary statistics kappa. summary.tau Summary statistics tau.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix for Whittle-Matérn fields — spde_precision","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"Computes precision matrix vertices Whittle-Matérn field.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"","code":"spde_precision(kappa, tau, alpha, graph, BC = 1, build = TRUE)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"kappa Range parameter. tau Precision parameter. alpha Smoothness parameter (1 2). graph metric_graph object. BC Set boundary conditions degree=1 vertices. BC =0 gives Neumann boundary conditions BC=1 gives stationary boundary conditions. build TRUE, precision matrix returned. Otherwise list list(,j,x, nv) returned.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/spde_precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix for Whittle-Matérn fields — spde_precision","text":"Precision matrix list.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summarise.metric_graph_data.html","id":null,"dir":"Reference","previous_headings":"","what":"A version of dplyr::summarise() function for datasets on metric graphs — summarise.metric_graph_data","title":"A version of dplyr::summarise() function for datasets on metric graphs — summarise.metric_graph_data","text":"Creates summaries, keeps spatial positions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summarise.metric_graph_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A version of dplyr::summarise() function for datasets on metric graphs — summarise.metric_graph_data","text":"","code":"# S3 method for metric_graph_data summarise(.data, ..., .include_graph_groups = FALSE, .groups = NULL)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/summarise.metric_graph_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A version of dplyr::summarise() function for datasets on metric graphs — summarise.metric_graph_data","text":".data data list tidyr::tibble obtained metric graph object. ... Additional parameters passed dplyr::summarise(). .include_graph_groups internal graph groups included grouping variables? default FALSE. means , summarising, data grouped internal group variable together spatial locations. .groups vector strings containing names columns additionally grouped, computing summaries. default NULL.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summarise.metric_graph_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A version of dplyr::summarise() function for datasets on metric graphs — summarise.metric_graph_data","text":"tidyr::tibble resulting selected columns.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for graph_lme Objects — summary.graph_lme","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"Function providing summary results related metric graph mixed effects regression models.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"","code":"# S3 method for graph_lme summary(object, all_times = FALSE, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"object object class graph_lme containing results fitted model. all_times Show computed times. ... used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.graph_lme.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Method for graph_lme Objects — summary.graph_lme","text":"object class summary_graph_lme containing information graph_lme object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for metric_graph Objects — summary.metric_graph","title":"Summary Method for metric_graph Objects — summary.metric_graph","text":"Function providing summary several informations/characteristics metric graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for metric_graph Objects — summary.metric_graph","text":"","code":"# S3 method for metric_graph summary(   object,   messages = FALSE,   compute_characteristics = TRUE,   check_euclidean = TRUE,   check_distance_consistency = TRUE,   ... )"},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for metric_graph Objects — summary.metric_graph","text":"object object class metric_graph. messages message explaining build results given missing quantities? compute_characteristics characteristics graph computed? check_euclidean Check graph Euclidean edges? check_distance_consistency Check distance consistency assumption?#' ... used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Method for metric_graph Objects — summary.metric_graph","text":"object class summary_graph_lme containing information metric_graph object.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for posteriors of field parameters for an inla_rspde model from a rspde.result object — summary.metric_graph_spde_result","title":"Summary for posteriors of field parameters for an inla_rspde model from a rspde.result object — summary.metric_graph_spde_result","text":"Summary posteriors 'rSPDE' field parameters original scales.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for posteriors of field parameters for an inla_rspde model from a rspde.result object — summary.metric_graph_spde_result","text":"","code":"# S3 method for metric_graph_spde_result summary(object, digits = 6, ...)"},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for posteriors of field parameters for an inla_rspde model from a rspde.result object — summary.metric_graph_spde_result","text":"object rspde.result object. digits Integer, used number formatting signif() ... Currently used.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/reference/summary.metric_graph_spde_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for posteriors of field parameters for an inla_rspde model from a rspde.result object — summary.metric_graph_spde_result","text":"data.frame containing summary.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-development-version","dir":"Changelog","previous_headings":"","what":"MetricGraph (development version)","title":"MetricGraph (development version)","text":"Added INLA implementation alpha=2. Added vignette handling multiple likelihoods R-INLA inlabru, updated graph_spde_data() function cases.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-130","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.3.0","title":"MetricGraph 1.3.0","text":"CRAN release: 2024-02-27 Handlers added add_observations() situations observations projected location, specifically duplicated_strategy argument. simulate method added graph_lme objects. possibility fixing parameters estimation added. Spoints argument add_observations() deprecated. Now, SpatialPointsDataFrame can added directly data argument. sf objects containing data can also directly added using add_observations() method data argument. option using graph_lme object provide starting values fitting model using graph_lme() added. option fitting directional Whittle-Matérn model alpha=1 using graph_lme() added. kirchhoff_weights argument added obtain weights Kirchhoff vertex conditions edge_weights. Handling edge weights improved. example, pruning changes edge weight, warning given. edgeweight_to_data() method added turn edge weights data internal metric graph format. edge_weight edge_width_weight added plot() method plots metric graphs can produced weights providing colors edges, also (possibly different) weights providing thickness edges. edge_weights added graph_components connected components correct corresponding edge weights. edge_weight edge_width_weight added plot_function() method, work similar manner counterparts plot() method. difference weights plotted piecewise constant functions. prune_vertices now option prune vertices whose edges incompatible edge weights. plot method interactive argument returns 2D plot plotly object, interactive using ggplotly. dependency viridis package removed.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-120","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.2.0","title":"MetricGraph 1.2.0","text":"CRAN release: 2023-11-07 Changed argument data newdata predict methods. argument data deprecated. Bugfixes sample_spde adding observations based Euclidean positions. Added options vertex_unit length_unit graph creations. Units given edge lengths get_edge_lengths() method. Added method check graph tree. graph construction thoroughly refactored. resulting construction faster cleaner. graph constructions now accepts list coordinates (coordinates given either matrices data frames), SpatialLines, SpatialLinesDataFrames MULTILINESTRING. Adding two options (sf package sp package) handling longlat using which_longlat option. Adding crs (using sf) proj4string (using sp) handling general coordinate reference systems. Moving data private environment. Several data manipulation helper tools methods introduced, together vignette brief tutorial tools. method mesh_A() deprecated, use fem_basis() instead. Several quality life improvements. Improved plot() method option plotly=TRUE. Improved plot_function() method accept data newdata. Included process_data() method metric graphs Renamed data internal structure “__group”, “__edge_number”, “__distance_on_edge”, “__coord_x”, “__coord_y” “.group”, “.edge_number”, “.distance_on_edge”, “.coord_x” “.coord_y”. Added “advanced grouping” option, group variable can combination several columns. Improved graph_lme() behavior avoid NaN std.errors. Added check distance consistency , generally, check see graph euclidean edges. Added method get_groups() get unique groups, also retrieve columns used create group variable. Added get_data() method get data user-friendly manner. Added glance() augment() methods graph_lme() objects. Added get_vertices_incomp_dir() method return vertices incompatible directions. Added print(), summary(), compute_characteristics(), check_euclidean(), check_distance_consistency() methods. Added support edge weights. Created vertices element metric graph object, containing information degrees, indegrees, outdegrees. Created print methods edges, vertices, entries. Added improve_plot option plot_function. Added support discontinuous meshes (vertices). Added support discontinuous functions (vertices) plot_function().","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-112","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.1.2","title":"MetricGraph 1.1.2","text":"CRAN release: 2023-07-04 Adjusts ensure compatibility future releases Matrix package.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-111","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.1.1","title":"MetricGraph 1.1.1","text":"CRAN release: 2023-06-01 Adjusts documentation CRAN.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-110","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.1.0","title":"MetricGraph 1.1.0","text":"Improved documentation. Reorganized functions.","code":""},{"path":"https://davidbolin.github.io/MetricGraph/news/index.html","id":"metricgraph-100","dir":"Changelog","previous_headings":"","what":"MetricGraph 1.0.0","title":"MetricGraph 1.0.0","text":"First version package.","code":""}]
