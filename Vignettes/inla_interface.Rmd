---
title: "INLA and inlabru interfaces"
author: "David Bolin, Alexandre B. Simas, and Jonas Wallin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{INLA and inlabru interfaces}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: BSW2022a
  title: "Gaussian Whittle--Matéern fields on metric graphs"
  author:
  - family: Bolin
    given: David
  - family: Simas
    given: Alexandre B.
  - family: Wallin
    given: Jonas
  container-title: arXiv:2205.06163
  type: preprint
  issued:
  year: 2022
- id: BSW2022b
  title: "Statistical properties of Gaussian Whittle--Matérn fields on metric graphs"
  author:
  - family: Bolin
    given: David
  - family: Simas
    given: Alexandre B.
  - family: Wallin
    given: Jonas
  container-title: arXiv:??
  type: preprint
  issued:
  year: 2022
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(GPGraph)
```

# Introduction

In this vignette we will present our `R-INLA` and `inlabru` 
interfaces to Whittle--Matérn fields. The underlying theory
for this approach is provided in 
[@BSW2022a](https://arxiv.org/abs/2205.06163) and [@BSW2022b](??). 

For an introduction to the `metric_graph` class, please see 
the [Working with metric graphs](metric_graph.html) vignette.

In the [Gaussian random fields on metric graphs](random_fields.html) vignette,
we introduce all the models in metric graphs contained in this package,
as well as, how to perform statistical tasks on these models, but without
the `R-INLA` or `inlabru` interfaces.

We will present our `R-INLA` and `inlabru` interfaces to 
the Whittle-Matérn fields by providing a step-by-step illustration.

The Whittle--Matérn fields are specified as solutions to the stochastic
differential equation 
$$
  (\kappa^2 - \Delta)^{\alpha} \tau u = \mathcal{W}
$$
on the metric graph $\Gamma$. We can work with these models without
any approximations if the smoothness parameter $\alpha$ is an integer, and this 
is what we focus on in this vignette. For details on the case of a general 
smoothness parameter, see [Whittle--Matérn fields with general smoothness](fem_models.html). 

# A toy dataset 

Let us begin by loading the `GPGraph` package
and creating a metric graph:

```{r}
library(GPGraph)

line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line4),ID="3"),
                              Lines(list(line3),ID="4")))
graph <- metric_graph$new(Lines = Lines)
```

Let us add 50 random locations in each edge where we will 
have observations:

```{r}
obs.per.edge <- 50
obs.loc <- NULL
for(i in 1:(graph$nE)) {
  obs.loc <- rbind(obs.loc,
                   cbind(rep(i,obs.per.edge), 
                   runif(obs.per.edge)))
}
```

We will now sample in these observation locations
and plot the latent field:

```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
sigma <- 2
alpha <- 1
nu <- alpha - 0.5
r <- 0.15 # r stands for range
kappa <- sqrt(8 * nu) / r

u <- sample_spde(kappa = kappa, sigma = sigma, alpha = alpha,
                 graph = graph, PtE = obs.loc)
graph$plot(X = u, X_loc = obs.loc)
```

Let us now generate the observed responses, which we will
call `y`. We will also plot the observed responses on the
metric graph.

```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
n.obs <- length(u)
sigma.e <- 0.1

y <- u + sigma.e * rnorm(n.obs)
graph$plot(X = y, X_loc = obs.loc)
```

# `R-INLA` implementation

We are now in a position to fit the model with our
`R-INLA` implementation. To this end,
we need to add the observations to the graph, which we 
will do with the `add_observations2()` method. Then,
we need to turn the observations into vertices of the 
graph with the `observation_to_vertex()` method. 

Before adding the observations we will grab a copy of
the graph with the `clone()` for two reasons: i. to make it better to 
visualization; ii. we will need to provide another
approach of kriging as we will see in the *Kriging
with `R-INLA` implementation* section.

```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
# Cloning the graph
graph_bkp <- graph$clone()
# Adding observations and turning them to vertices
graph$add_observations2(y, PtE = obs.loc, normalized=TRUE)
graph$observation_to_vertex()
graph$plot(data=TRUE)
```

Now, we create the `inla` model object with the
`gpgraph_spde` function. By default we have
`alpha=1`. 

```{r}
spde_model <- gpgraph_spde(graph)
```

Now, we need to create the index object with 
the `graph_spde_make_index()` function:

```{r}
spde.index <- graph_spde_make_index(name="field", graph=graph)
```

Observe that, as in `R-INLA`, we need to name the field.

The next step is to create the observation matrix, to which
we use the `graph_spde_make_A()` function:

```{r}
A <- graph_spde_make_A(graph)
```

The remaining is standard in `R-INLA`. We create the
formula object and the
`inla.stack` object with the `inla.stack()` function:

```{r}
f.s <- y ~ -1 + Intercept + f(field, model = spde_model)

stk.dat <- inla.stack(data = list(y=as.vector(y)), 
                        A = A, 
                        effects = c(
      spde.index,
      list(Intercept = 1)
    ))
```

Now, we use the `graph_stack()` function that behaves in 
an analogous manner to the `inla.stack.data()` function:
```{r}
data_stk <- graph_stack(stk.dat, "field")
```

Finally, we fit the model:

```{r}
spde_fit <- inla(f.s, data = data_stk)
```

Let us now obtain the estimates in the original scale:

```{r}
spde_result <- spde_metric_graph_result(spde_fit, "field", spde_model)

summary(spde_result)
```

We will now compare the means of the estimated values with
the true values:

```{r}
  result_df <- data.frame(
    parameter = c("std.dev", "range"),
    true = c(sigma, r),
    mean = c(
      spde_result$summary.sigma$mean,
      spde_result$summary.range$mean
    ),
    mode = c(
      spde_result$summary.sigma$mode,
      spde_result$summary.range$mode
    )
  )
  print(result_df)
```


We can also plot the posterior marginal densities with the 
help of the `gg_df()` function:
```{r, fig.show='hold',fig.align = "center",echo=TRUE, fig.width=7, warning=FALSE}
  posterior_df_fit <- gg_df(spde_result)

  ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) + 
  facet_wrap(~parameter, scales = "free") + labs(y = "Density")
```

## Kriging with the `R-INLA` implementation

We can have two approaches to do kriging with our `R-INLA`
implementation of Whittle-Matérn fields on metric graphs.

* In the first we add a second set of `NA` add_observations
at the locations in which we want to do kriging to the 
graph in which we fitted the model. Then, fit a new model,
and obtain the posterior mean at the desired locations.
Observe that on this method, if we use the
`add_observations2()` method, we will need to provide the locations
in which we want to predict in terms of the positions of
the new graph, which contains the observed set of 
observations as vertices.

* In the second method we add the locations in which we
want to predict together with the observations and 
observed locations. In this method we provide the locations we
want to predict in terms of the same base graph, as the
observations are not vertices of the base graph.

We will now do kriging at an evenly spaced mesh across
the metric graph.

## Kriging by adding new observation locations to the fitted graph

Since the fitted graph contains the observed locations as vertices,
we will use our backup graph `graph_bkp` to obtain the spatial 
locations of the points in which we want to do kriging.
We will create a copy of `graph_bkp` as we will still need
`graph_bkp` for the second approach of kriging.

```{r}
graph_tmp <- graph_bkp$clone()
```

Let us obtain an evenly spaced mesh with respect to the base
graph:

```{r}
obs_per_edge_prd <- 50
obs_loc_prd <- NULL
loc_tmp <- 0:(obs_per_edge_prd+1)/(obs_per_edge_prd+1)
loc_tmp <- loc_tmp[2:(obs_per_edge_prd+1)]
for(i in 1:(graph_tmp$nE)) {
    obs_loc_prd <- rbind(obs_loc_prd,
                 cbind(rep(i,obs_per_edge_prd), 
                 loc_tmp))
}
```
Let us add the locations as vertices and plot the resulting graph:
```{r, fig.width=7,}
n_obs_prd <- obs_per_edge_prd * graph_tmp$nE
y_prd <- rep(NA, n_obs_prd)
graph_tmp$add_observations2(y_prd, obs_loc_prd,
                            normalized = TRUE)
graph_tmp$observation_to_vertex()
graph_tmp$plot()
```
We will now extract the spatial locations and use
these to add these new locations to the graph
we used to fit the `R-INLA` model:

```{r}
spatial_loc_prd <- graph_tmp$Points
```

We will now add them to the graph we fitted the
`R-INLA` model:

```{r}
graph$add_observations(Spoints = spatial_loc_prd)
graph$observation_to_vertex()
```

Let us plot the resulting graph (the gray dots indicate
the new locations):

```{r, fig.width=7,}
graph$plot(data=TRUE)
```

We will now fit a new model with `R-INLA` with this new
graph that contains the prediction locations. To this end,
we create a new model object with the `gpgraph_spde()` function:

```{r}
spde_model_prd <- gpgraph_spde(graph)
```

Now, let us create a new index object and a new observation (`A`):
```{r}
spde_index_prd <- graph_spde_make_index(name="field", graph=graph)

A_prd <- graph_spde_make_A(graph)
```

We will create a new vector of response variables,
concatenating `y` to `y_prd`, then create a new
formula object and the
`inla.stack` object:

```{r}
y_cmp <- c(y, y_prd)

f_s_prd <- y ~ -1 + Intercept + f(field, model = spde_model_prd)

stk_dat_prd <- inla.stack(data = list(y=y_cmp), 
                        A = A_prd, 
                        effects = c(
      spde_index_prd,
      list(Intercept = 1)
    ))
```

Now, we use the `graph_stack()` function and fit the model:
```{r}
data_stk_prd <- graph_stack(stk_dat_prd, "field")

spde_fit_prd <- inla(f_s_prd, data = data_stk_prd)
```

Let us now obtain the estimates in the original scale:

```{r}
spde_result_prd <- spde_metric_graph_result(spde_fit_prd, "field", spde_model_prd)

summary(spde_result_prd)
```

We will now extract the means at the prediction locations:
```{r}
idx_prd <- which(is.na(y_cmp))

m_prd <- spde_fit_prd$summary.fitted.values$mean[idx_prd]
```

To improve visualization, we will plot the posterior means
on `graph_bkp`:
```{r}
graph_bkp$plot(X = m_prd, X_loc = obs_loc_prd)
```

We will now plot the predictions together with
the data. To this end we need to create a new 
vector `y` which is a concatenation of `y`
and `m_prd`, then use it as the vector of 
responses of `graph`, which is done by using the
`add_responses()` method. Then, we plot.

Let us begin by concatenating the vectors and adding
the responses to `graph`:
```{r}
y_new <- c(y, m_prd)
graph$add_responses(y_new)
```

Now, we plot:
```{r}
graph$plot(data=TRUE)
```