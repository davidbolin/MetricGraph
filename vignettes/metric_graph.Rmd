---
title: "Working with metric graphs"
author: "David Bolin, Alexandre B. Simas, and Jonas Wallin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with metric graphs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(MetricGraph)
set.seed(1)
```

# Introduction

In this vignette we will introduce the `metric_graph` class. We will first show
how to construct metric graphs and then how to add data to them. For details 
about how to work with Gaussian processes on metric graphs, we refer to the
Vignettes 

* [Gaussian random fields on metric graphs](random_fields.html)
* [INLA interface of Whittle--Matérn fields](inla_interface.html)
* [inlabru interface of Whittle--Matérn fields](inlabru_interface.html)
* [Whittle--Matérn fields with general smoothness](fem_models.html)

# Constructing metric graphs

## Basic constructions and properties
A metric graph can be constructed in two ways. The first is to specify all edges
in the graph as a `SpatialLines` object using the `sp` package. To illustrate
this, we first load the `sp` package
```{r}
library(sp)
```
and construct the following lines
```{r}
line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
```
We can now create the graph based on the `Lines` object as follows

```{r}
graph <- metric_graph$new(lines = Lines)
graph$plot()
```
The plot function that was used to create the plot above has various parameters
to set the sizes and colors of the vertices and edges, and it has a `plotly`
argument to visualize the graph in 3D:
```{r}
graph$plot(plotly = TRUE, vertex_size = 5, vertex_color = "blue",
           edge_color = "red", edge_width = 2)
```
We can now obtain various properties of the graph: The vertex matrix, which
specifies the Euclidian coordinates of the vertices is
```{r}
graph$V
```
and the edge matrix that specified the edges of the graph (i.e., which vertices
that are connected by lines) is
```{r}
graph$E
```
To obtain the geodesic (shortes path) distance between the vertices, we can use
the function `compute_geodist`:
```{r}
graph$compute_geodist()
graph$geo_dist
```
The second option it to construct the graph using two matrices `V` and `E` that
specify the location (in Euclidean space) of the vertices and the edges. In this
case, it is assumed that the graph only has straight lines:
```{r}
V <- rbind(c(0, 0), c(1, 0), c(0, 1), c(-1, 1))
E <- rbind(c(1, 2), c(1, 3), c(3, 4), c(4, 1))
graph2 <- metric_graph$new(V = V, E = E)
graph2$plot()
```

The constructor of the graph has one argument `tolerance` which is used to merge
vertices that are close in Euclidean space. The default value for this parameter
is `2e-16`, which means that any two vertices that are closer than that are 
merged. For example, in the following graph, we have two vertices that are 
close but not close enough to be merged:
```{r}
V <- rbind(c(0, 0), c(1, 0), c(0, 1), c(-1, 1), c(0,-0.03))
E <- rbind(c(1, 2), c(1, 3), c(3, 4), c(4, 5))
graph3 <- metric_graph$new(V = V, E = E)
graph3$plot()
print(graph3$nV)
```

This can be adjusted by increasing the tolerance:
```{r}
graph4 <- metric_graph$new(V = V, E = E, tolerance = 0.05)
graph4$plot()
print(graph4$nV)
```
## An example with data from OpenStreetMap
This format of constructing graphs is compatible with data from OpenStreetMap,
and to illustrate this we use the `osmdata` to construct a metric graph 
consting of highways in Copenhagen:
```{r}
library(osmdata)
set_overpass_url("https://maps.mail.ru/osm/tools/overpass/api/interpreter")
call <- opq(bbox = c(12.4,55.5,12.65,55.9))
call <- add_osm_feature(call, key = "highway",value=c("motorway",
                                                        "primary","secondary"))
data <- osmdata_sp(call)

graph5 <- metric_graph$new(SpatialLines(data$osm_lines@lines))
graph5$plot(vertex_size = 0)
```

As can be noted, the constructor here gave a warning that the graph is not 
connected. This might not be ideal for modeling and we may want to study the 
different connected components separately. To construct all connected components,
we can use the `graph_components` function:
```{r message=FALSE, warning=FALSE}
graphs <- graph_components(SpatialLines(data$osm_lines@lines))
p <- graphs[[1]]$plot(vertex_size = 0, edge_color = "black")  
for(i in 2:(length(graphs)-1)){
p <- graphs[[i]]$plot(vertex_size = 0, 
                      edge_color = rgb(runif(1),runif(1),runif(1)),
                      p = p)  
}
graphs[[length(graphs)]]$plot(vertex_size = 0,
                              edge_color = rgb(runif(1),runif(1),runif(1)),
                              p = p)
```

Thus, we see that there are a few different connected components. One reason for
this might be that we set the tolerance for merging nodes too low. Let us
increase the tolerance and redo the creation: 
```{r message=FALSE, warning=FALSE}
graphs <- graph_components(SpatialLines(data$osm_lines@lines),
                           tolerance = 1e-6)
p <- graphs[[1]]$plot(vertex_size = 0, edge_color = "black")
for(i in 2:(length(graphs)-1)){
p <- graphs[[i]]$plot(vertex_size = 0, 
                      edge_color = rgb(runif(1),runif(1),runif(1)),
                      p = p)  
}
graphs[[length(graphs)]]$plot(vertex_size = 0,
                              edge_color = rgb(runif(1),runif(1),runif(1)),
                              p = p)
```

With this choice, we see that there is one large connected component and a few
small. If we are interested in only getting the largest component, we can
extract it as the first element of the `graphs` list (which is ordered by size).
Alternatively, we can call `graph_components` with the argument 
`only_largest = TRUE`. 

# Adding data to the graph 

Given that we have constructed the metric graph, we can now add data to it. 
As an example, let us consider the first graph again and suppose that we have 
observations at a distance 0.5 from the start of each edge. One way of specifying
this is as follows 
```{r}
obs.loc <- cbind(1:4, rep(0.5, 4))
obs <- c(1,2,3,4)
graph$add_PtE_observations(obs, PtE = obs.loc)
graph$plot(data = TRUE)
```

Thus, each row in `PtE` specifies the edge of the observation and the distance
along that edge where the observation location is. In certain situations, 
it might be easier to specify the relative distances on the edges, so that 
0 represents the start and 1 the end of the edge (instead of the edge length). 
To do so, we can simply specify `normalized = TRUE` when adding the 
observations. For example, let us add one more observation at the midpoint 
of the fourth edge:
```{r}
obs.loc <- matrix(c(4, 0.5),1,2)
obs <- c(5)
graph$add_PtE_observations(obs, PtE = obs.loc, normalized = TRUE)
graph$plot(data = TRUE)
```

An alternative method is to specify the observations as spatial points objects,
where the locations are given in Euclidean coordinates: 
```{r}
obs.loc <- rbind(c(0.7, 0), c(0, 0.2))
obs <- c(6,7)
points <- SpatialPointsDataFrame(coords = obs.loc,
                                 data = data.frame(y = obs))
graph$add_observations(points)
graph$plot(data = TRUE)
```

If we want to replace the data in the object, we can use `clear_observations()`
to remove all current data, and then add the new data:
```{r}
graph$clear_observations()
graph$add_observations(points)
graph$plot(data = TRUE)
```

In some cases, we might want to add the observation locations as vertices 
in the graph. This can be done as follows: 
```{r}
graph$observation_to_vertex()
graph$plot(data = TRUE)
```
