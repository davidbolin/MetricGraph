---
title: "inlabru interface of Whittle--Matérn fields"
author: "David Bolin, Alexandre B. Simas, and Jonas Wallin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{inlabru interface of Whittle--Matérn fields}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: BSW2022a
  title: "Gaussian Whittle--Matérn fields on metric graphs"
  author:
  - family: Bolin
    given: David
  - family: Simas
    given: Alexandre B.
  - family: Wallin
    given: Jonas
  container-title: arXiv:2205.06163
  type: preprint
  issued:
    year: 2022
- id: BSW2022b
  title: "Statistical properties of Gaussian Whittle--Matérn fields on metric graphs"
  author:
  - family: Bolin
    given: David
  - family: Simas
    given: Alexandre B.
  - family: Wallin
    given: Jonas
  container-title: arXiv:??
  type: preprint
  issued:
    year: 2022
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(MetricGraph)
```

# Introduction

In this vignette we will present our `inlabru`
interface to Whittle--Matérn fields. The underlying theory
for this approach is provided in 
[@BSW2022a](https://arxiv.org/abs/2205.06163) and [@BSW2022b](??). 

For an introduction to the `metric_graph` class, please see 
the [Working with metric graphs](metric_graph.html) vignette.

For our `R-INLA` interface, see
the [INLA interface of Whittle--Matérn fields](inla_interface.html) vignette.

In the [Gaussian random fields on metric graphs](random_fields.html) vignette,
we introduce all the models in metric graphs contained in this package,
as well as, how to perform statistical tasks on these models, but without
the `R-INLA` or `inlabru` interfaces.

We will present our `inlabru` interface to 
the Whittle-Matérn fields by providing a step-by-step illustration.

The Whittle--Matérn fields are specified as solutions to the stochastic
differential equation 
$$
  (\kappa^2 - \Delta)^{\alpha} \tau u = \mathcal{W}
$$
on the metric graph $\Gamma$. We can work with these models without
any approximations if the smoothness parameter $\alpha$ is an integer, and this 
is what we focus on in this vignette. For details on the case of a general 
smoothness parameter, see [Whittle--Matérn fields with general smoothness](fem_models.html). 

# A toy dataset 

Let us begin by loading the `MetricGraph` package
and creating a metric graph:

```{r}
library(MetricGraph)
library(sp)

line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line4),ID="3"),
                              Lines(list(line3),ID="4")))
graph_bru <- metric_graph$new(lines = Lines)
```

Let us add 50 random locations in each edge where we will 
have observations:

```{r}
obs_per_edge <- 50
obs_loc <- NULL
for(i in 1:(graph_bru$nE)) {
  obs_loc <- rbind(obs_loc,
                   cbind(rep(i,obs_per_edge), 
                   runif(obs_per_edge)))
}
```

We will now sample in these observation locations
and plot the latent field:

```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
sigma <- 2
alpha <- 1
nu <- alpha - 0.5
r <- 0.15 # r stands for range
kappa <- sqrt(8 * nu) / r

u <- sample_spde(kappa = kappa, sigma = sigma, alpha = alpha,
                 graph = graph_bru, PtE = obs_loc)
graph_bru$plot(X = u, X_loc = obs_loc)
```

Let us now generate the observed responses, which we will
call `y`. We will also plot the observed responses on the
metric graph.

```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
n_obs <- length(u)
sigma.e <- 0.1

y <- u + sigma.e * rnorm(n_obs)
graph_bru$plot(X = y, X_loc = obs_loc)
```


# `inlabru` implementation

We will now present our `inlabru` implementation
of the Whittle-Matérn fields for metric graphs.
It has the advantage, over our `R-INLA`
implementation, of not requiring the user
to provide observation matrices, indices nor 
stack objects.

We are now in a position to fit the model with our
`inlabru` implementation. To this end,
we need to add the observations to the graph, which we 
will do with the `add_observations()` method. 

```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
# Creating the data frame
df_graph <- data.frame(y = y, edge_number = obs_loc[,1],
                      distance_on_edge = obs_loc[,2])
# Adding observations and turning them to vertices
graph_bru$add_observations(data = df_graph, normalized=TRUE)
graph_bru$plot(data="y")
```

Now, we load `INLA` and `inlabru` packages. We will also
need to create the `inla` model object with the
`graph_spde` function. By default we have
`alpha=1`. 

```{r, message=FALSE}
library(INLA)
library(inlabru)
spde_model_bru <- graph_spde(graph_bru)
```

Now, we create `inlabru`'s component, which is a 
formula-like object. The index parameter in `inlabru`
is not used in our implementation, thus, we replace it 
by the `repl` argument, which tells which 
replicates to use. If there is no replicates, we
supply `NULL`.
```{r}
cmp <-
    y ~ -1 + Intercept(1) + field(loc,
                    model = spde_model_bru)
```

Now, we directly fit the model:

```{r}
spde_bru_fit <-
    bru(cmp, data=graph_data_spde(spde_model_bru, loc = "loc"))
```

Let us now obtain the estimates in the original scale
by using the `spde_metric_graph_result()` function, then
taking a `summary()`:

```{r}
spde_bru_result <- spde_metric_graph_result(spde_bru_fit, 
                    "field", spde_model_bru)

summary(spde_bru_result)
```

We will now compare the means of the estimated values with
the true values:

```{r}
  result_df_bru <- data.frame(
    parameter = c("std.dev", "range"),
    true = c(sigma, r),
    mean = c(
      spde_bru_result$summary.sigma$mean,
      spde_bru_result$summary.range$mean
    ),
    mode = c(
      spde_bru_result$summary.sigma$mode,
      spde_bru_result$summary.range$mode
    )
  )
  print(result_df_bru)
```

We can also plot the posterior marginal densities with the 
help of the `gg_df()` function:
```{r, fig.show='hold',fig.align = "center",echo=TRUE, fig.width=7, warning=FALSE}
  posterior_df_bru_fit <- gg_df(spde_bru_result)

  library(ggplot2)

  ggplot(posterior_df_bru_fit) + geom_line(aes(x = x, y = y)) + 
  facet_wrap(~parameter, scales = "free") + labs(y = "Density")
```

## Kriging with the `inlabru` implementation

Unfortunately, our `inlabru` implementation is not 
compatible with `inlabru`'s `predict()` method. This has
to do with the nature of the metric graph's object.

To this end, we have provided a helper function, namely
the `inlabru_predict()` function. We will first show
how to do kriging with the help of this function. Then,
we will show how to do it manually.

We begin by creating a data list
with the positions we want the predictions. In this case,
we will want the predictions on a mesh.

Let us begin by obtaining an evenly spaced mesh with respect to the base
graph:

```{r}
obs_per_edge_prd <- 50
graph_bru$build_mesh(n = obs_per_edge_prd)
```

Let us plot the resulting graph:

```{r, fig.show='hold',fig.align = "center",echo=TRUE, fig.width=7, warning=FALSE}
graph_bru$plot(mesh=TRUE)
```

The positions we want are the mesh positions, which
are given in `graph_bru$mesh$PtE`.

```{r}
PtE_prd <- graph_bru$mesh$PtE
```

To use the `inlabru_predict()` function, we need to pass
the previous model object, the previous fitted model, the component
and a data, through the argument 
`data_pred`, with `NA` on the response variables, containing the
prediction locations, along with other covariates used in the
model. If the model has no covariates, one can simply 
pass the locations. The locations can be either Euclidean coordinates, 
given by the argument `XY`, or relative positions on the
edge, given by the `PtE` argument.

Now, we simply call the `inlabru_predict()` function with
the previous component, the previous model object,
the previous fitted model and the locations:

```{r}
fitted_values <- inlabru_predict(spde_model_bru, 
                                spde_bru_fit, 
                                cmp, 
                                PtE = PtE_prd)
```

Now, we can get the mean values:

```{r}
m_prd_bru <- fitted_values$mean
```

To improve visualization, we will plot the posterior means
using the `plot_function()` method:
```{r, fig.show='hold',fig.align = "center",echo=TRUE, fig.width=7, warning=FALSE}
graph_bru$plot_function(X = m_prd_bru, vertex_size = 0)
```

Finally, we can plot the predictions together with
the data:
```{r, fig.show='hold',fig.align = "center",echo=TRUE, fig.width=7, warning=FALSE, message=FALSE}
p <- graph_bru$plot_function(X = m_prd_bru, vertex_size = 0) 
graph_bru$plot(data=TRUE, vertex_size = 0, edge_width = 0, p = p, data_size = 2)
```

## Kriging by adding new observation locations to the fitted graph

We will now illustrate the manual approach, which is very similar 
to `R-INLA`'s implementation. However, it is much simpler 
since it does not require the user to handle 
observation matrices, indices nor on stack objects.

Therefore, in the same manner as in `R-INLA`'s
implementation, we have two approaches to do 
kriging with our `inlabru`
implementation of Whittle-Matérn fields on metric graphs.

* In the first we add a second set of `NA` add_observations
at the locations in which we want to do kriging to the 
graph in which we fitted the model. Then, fit a new model,
and obtain the posterior mean at the desired locations.
Observe that on this method, if we use the
`add_PtE_observations()` method, we will need to provide the locations
in which we want to predict in terms of the positions of
the new graph, which contains the observed set of 
observations as vertices.

* In the second method we add the locations in which we
want to predict together with the observations and 
observed locations. In this method we provide the locations we
want to predict in terms of the same base graph, as the
observations are not vertices of the base graph.

We will do kriging at an evenly spaced mesh across
the metric graph.

Let us begin by obtaining an evenly spaced mesh with respect to the base
graph:

```{r}
obs_per_edge_prd <- 50
graph_bru$build_mesh(n = obs_per_edge_prd)
```

We will now add the observations on the mesh
locations to the graph we fitted the
`R-INLA` model. To this end we will use the
`add_mesh_observations()` method. We will enter the response variables
as `NA`. We can get the number of mesh nodes by counting 
the number of rows of the `mesh$PtE` attribute.

```{r}
n_obs_mesh <- nrow(graph_bru$mesh$PtE)
y_prd <- rep(NA, n_obs_mesh)
df_mesh <- data.frame(y = y_prd)
graph_bru$add_mesh_observations(data = df_mesh)
```

We will now fit a new model with `inlabru` with this new
graph that contains the prediction locations. To this end,
we create a new model object with the `graph_spde()` function:

```{r}
spde_model_bru_prd <- graph_spde(graph_bru)
```

We will create a new vector of response variables,
concatenating `y` to `y_prd`. We will also
concatenate the observation and prediction
locations vertically. Then, create 
a new data list
```{r}
y_cmp <- c(y, y_prd)

data_list_prd <- list(y = y_cmp, loc = graph_bru$PtE)
```

Now, let us create a new
`inlabru` component:

```{r}
cmp_prd <- y ~ -1 + Intercept(1) + field(NULL, 
                            model = spde_model_bru_prd)
```

Now, we fit the model:
```{r}
spde_bru_fit_prd <-
    bru(cmp_prd, data=graph_data_spde(spde_model_bru_prd))
```

We will now extract the means at the prediction locations:
```{r}
idx_prd <- which(is.na(graph_data_spde(spde_model_bru_prd)[["y"]]))

m_prd_bru <- spde_bru_fit_prd$summary.fitted.values$mean[idx_prd]
```

To improve visualization, we will plot the posterior means
using the `plot_function()` method:
```{r, fig.show='hold',fig.align = "center",echo=TRUE, fig.width=7, warning=FALSE}
graph_bru$plot_function(X = m_prd_bru, vertex_size = 0)
```

Finally, we can plot the predictions together with
the data:
```{r, fig.show='hold',fig.align = "center",echo=TRUE, fig.width=7, warning=FALSE, message=FALSE}
p <- graph_bru$plot_function(X = m_prd_bru, vertex_size = 0) 
graph_bru$plot(data=TRUE, vertex_size = 0, edge_width = 0, p = p, data_size = 2)
```

## Fitting `inlabru` models with replicates

We will now illustrate how to use our `inlabru` implementation to 
fit models with replicates.

To simplify exposition, we will use the same base graph.
So, we begin by clearing the observations:
```{r}
graph_bru$clear_observations()
```

We will use the same observation locations as for the
previous cases. Let us sample 30 replicates:
```{r}
sigma_rep <- 1.5
alpha_rep <- 1
nu_rep <- alpha_rep - 0.5
r_rep <- 0.2 # r stands for range
kappa_rep <- sqrt(8 * nu_rep) / r_rep

n_repl <- 30

u_rep <- sample_spde(kappa = kappa_rep, sigma = sigma_rep,
                 alpha = alpha_rep,
                 graph = graph_bru, PtE = obs_loc,
                 nsim = n_repl)
```

Let us now generate the observed responses, which we will
call `y_rep`.

```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
n_obs_rep <- nrow(u_rep)
sigma_e <- 0.1

y_rep <- u_rep + sigma_e * matrix(rnorm(n_obs_rep * n_repl),
                                    ncol=n_repl)
```


We can now add the the observations by setting the `group`
argument to `repl`:
```{r, fig.show='hold',fig.align = "center",fig.width=7,echo=TRUE}
dl_rep_graph <- lapply(1:ncol(y_rep), function(i){data.frame(y = y_rep[,i],
                                          edge_number = obs_loc[,1],
                                          distance_on_edge = obs_loc[,2],
                                          repl = i)})
dl_rep_graph <- do.call(rbind, dl_rep_graph)

graph_bru$add_observations(data = dl_rep_graph, normalized=TRUE,
                                    group = "repl")
```

By definition the `plot()` method plots the first replicate.
We can select the other replicates with the `group` argument.
See the [Working with metric graphs](metric_graphs.html)
for more details.

```{r}
graph_bru$plot(data="y")
```

Let us plot another replicate:

```{r}
graph_bru$plot(data="y", group=2)
```


Let us now create the model object:

```{r}
spde_model_bru_rep <- graph_spde(graph_bru)
```

Let us first create a model using the replicates
1, 3, 5, 7 and 9. To this end, we provide the vector
of the replicates we want as the `input` argument to the `field`.
We created a helper function, namely 
`bru_graph_rep()` to help building this vector:
```{r}
repl <- bru_graph_rep(c(1,3,5,7,9), spde_model_bru_rep)
cmp_rep <-
    y ~ -1 + Intercept(1) + field(loc, 
                        model = spde_model_bru_rep,
                        replicate = repl)
```

Now, we fit the model, by setting the `repl` argument 
to the replicates we want inside the
`graph_data_spde()` function:
```{r}
spde_bru_fit_rep <-
    bru(cmp_rep,
        data=graph_data_spde(spde_model_bru_rep, loc = "loc",
        repl=c(1,3,5,7,9)))
```

Let us see the estimated values in the original scale:
```{r}
spde_result_bru_rep <- spde_metric_graph_result(spde_bru_fit_rep, 
                        "field", spde_model_bru_rep)

summary(spde_result_bru_rep)
```

Let us compare with the true values:

```{r}
  result_df_bru_rep <- data.frame(
    parameter = c("std.dev", "range"),
    true = c(sigma_rep, r_rep),
    mean = c(
      spde_result_bru_rep$summary.sigma$mean,
      spde_result_bru_rep$summary.range$mean
    ),
    mode = c(
      spde_result_bru_rep$summary.sigma$mode,
      spde_result_bru_rep$summary.range$mode
    )
  )
  print(result_df_bru_rep)
```


We will now show how to fit the model considering all replicates.
To this end, we simply set the argument in `bru_graph_rep()`
function to `__all`.

```{r}
repl <- bru_graph_rep("__all", spde_model_bru_rep)
cmp_rep <-
    y ~ -1 + Intercept(1) + field(loc, 
                        model = spde_model_bru_rep,
                        replicate = repl)
```

Similarly, we fit the model, by setting the `repl` argument 
to "__all" inside the
`graph_data_spde()` function:
```{r}
spde_bru_fit_rep <-
    bru(cmp_rep,
        data=graph_data_spde(spde_model_bru_rep, 
        loc = "loc",
        repl="__all"))
```

Let us see the estimated values in the original scale:
```{r}
spde_result_bru_rep <- spde_metric_graph_result(spde_bru_fit_rep, 
                        "field", spde_model_bru_rep)

summary(spde_result_bru_rep)
```

Let us compare with the true values:

```{r}
  result_df_bru_rep <- data.frame(
    parameter = c("std.dev", "range"),
    true = c(sigma_rep, r_rep),
    mean = c(
      spde_result_bru_rep$summary.sigma$mean,
      spde_result_bru_rep$summary.range$mean
    ),
    mode = c(
      spde_result_bru_rep$summary.sigma$mode,
      spde_result_bru_rep$summary.range$mode
    )
  )
  print(result_df_bru_rep)
```

