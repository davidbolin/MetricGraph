% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric_graph.R
\name{metric_graph}
\alias{metric_graph}
\title{Metric graph object for specification of Gaussian processes}
\description{
Class representing general metric graphs.
}
\details{
A graph object created from vertex and edge matrices, or from an sp::Lines
object where each line is representing and edge.
}
\examples{

## ------------------------------------------------
## Method `metric_graph$plot`
## ------------------------------------------------

line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(Lines = Lines)
graph$plot()
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{V}}{Position in Euclidean space of the vertices}

\item{\code{nV}}{number of vertices}

\item{\code{E}}{Edges,  E[i,1] is the vertex at the start of the edge and  E[i,2] is
the vertex at the end of the edge}

\item{\code{nE}}{number of edges}

\item{\code{edge_lengths}}{length of edges}

\item{\code{EID}}{ID of edges}

\item{\code{EtL}}{[i,] - edge i position on lines}

\item{\code{C}}{constraint matrix used to set Kirchhoff constraints}

\item{\code{A}}{observation matrix specifying which vertices are observation locations}

\item{\code{CBobj}}{svd stuct obj}

\item{\code{Points}}{Observations in SpatialPointsDataFrame}

\item{\code{y}}{the data connected to P}

\item{\code{PtE}}{Points to Line (connected to Points),
[,1] - edge index,
[,2] - distance along the line (i.e. distance to initial point)}

\item{\code{PtV}}{Points to Vertex observations to vertex
[,1] - vertex index,}

\item{\code{mesh}}{mesh object used for plotting}

\item{\code{Lines}}{List of Lines object for building the graph}

\item{\code{geo.dist}}{Geodesic distance matrix}

\item{\code{res.dist}}{Resistance distance matrix}

\item{\code{Laplacian}}{The weighted graph Laplacian}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{EtL}}{[i,] - edge i position on lines}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-GPGraph::graph-new}{\code{metric_graph$new()}}
\item \href{#method-GPGraph::graph-compute_geodist}{\code{metric_graph$compute_geodist()}}
\item \href{#method-GPGraph::graph-compute_resdist}{\code{metric_graph$compute_resdist()}}
\item \href{#method-GPGraph::graph-compute_laplacian}{\code{metric_graph$compute_laplacian()}}
\item \href{#method-GPGraph::graph-observation_to_vertex}{\code{metric_graph$observation_to_vertex()}}
\item \href{#method-GPGraph::graph-add_observations}{\code{metric_graph$add_observations()}}
\item \href{#method-GPGraph::graph-add_observations2}{\code{metric_graph$add_observations2()}}
\item \href{#method-GPGraph::graph-buildC}{\code{metric_graph$buildC()}}
\item \href{#method-GPGraph::graph-build_mesh}{\code{metric_graph$build_mesh()}}
\item \href{#method-GPGraph::graph-compute_fem}{\code{metric_graph$compute_fem()}}
\item \href{#method-GPGraph::graph-mesh_A}{\code{metric_graph$mesh_A()}}
\item \href{#method-GPGraph::graph-VtEfirst}{\code{metric_graph$VtEfirst()}}
\item \href{#method-GPGraph::graph-plot}{\code{metric_graph$plot()}}
\item \href{#method-GPGraph::graph-plot_function}{\code{metric_graph$plot_function()}}
\item \href{#method-GPGraph::graph-plot_function_mesh}{\code{metric_graph$plot_function_mesh()}}
\item \href{#method-GPGraph::graph-clone}{\code{metric_graph$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-new"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-new}{}}}
\subsection{Method \code{new()}}{
Create a new gpgraph_graph object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$new(Lines = NULL, P = NULL, E = NULL, edge_lengths = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Lines}}{sp object SpatialLines DataFrame or SpatialLines}

\item{\code{P}}{n x 2 matrix with Euclidean coordinates of the n vertices}

\item{\code{E}}{m x 2 matrix where each line represents an edge}

\item{\code{edge_lengths}}{m x 1 vector with edge lengths}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A graph object can be initialized in two ways. The first method is
to specify P and E. In this case, if edge_lengths is not specified, all edges are
assumed to be straight lines. Otherwise the edge lengths set in edge_lengths are used.
The second option is to specify the graph based on Lines. In this case,
the vertices are set by the end points of the lines. Thus, if two lines are intersecting
somewhere else, this will not be viewed as a vertex.
}

\subsection{Returns}{
A metric_graph object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_geodist"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_geodist}{}}}
\subsection{Method \code{compute_geodist()}}{
Computes shortest path distances between the vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_resdist"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_resdist}{}}}
\subsection{Method \code{compute_resdist()}}{
Computes the resistance metric between the vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_laplacian"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_laplacian}{}}}
\subsection{Method \code{compute_laplacian()}}{
Compute graph Laplacian for the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_laplacian()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-observation_to_vertex"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-observation_to_vertex}{}}}
\subsection{Method \code{observation_to_vertex()}}{
Add observation locations as vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$observation_to_vertex()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_observations"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_observations}{}}}
\subsection{Method \code{add_observations()}}{
Add observations to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations(Spoints, y = NULL, y.index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Spoints}}{SpatialPoints or SpatialPointsDataFrame of the observations}

\item{\code{y}}{(n x 1) the value of the observations}

\item{\code{y.index}}{(string, int) column in Spoints where y is located}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_observations2"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_observations2}{}}}
\subsection{Method \code{add_observations2()}}{
add observations to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations2(y, PtE, Spoints = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{(n x 1) the value of the observations}

\item{\code{PtE}}{(n x 2) edge index, distance on index}

\item{\code{Spoints}}{SpatialPoints or SpatialPointsDataFrame of the observations}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-buildC"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-buildC}{}}}
\subsection{Method \code{buildC()}}{
build Kirchoff constraint matrix from edges, NOT implemented
for circles (i.e. self closed edges)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$buildC(alpha, edge_constraint = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{alpha}}{(int) which type of constraint (currently only 2 implemented)}

\item{\code{edge_constraint}}{(bool) if true add constraint on vertices of
degree 1.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-build_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-build_mesh}{}}}
\subsection{Method \code{build_mesh()}}{
build mesh object for graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$build_mesh(h, n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{h}}{maximum distance between mesh nodes}

\item{\code{n}}{maximum number of nodes per edge}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The mesh is a list with the objects
- PtE which contains the mesh locations excluding the original vertices
- V the verties of the mesh
- E the edges of the mesh
- n_e the number of vertices in the mesh per original edge in the graph
- h_e the mesh width per edge in the graph
- ind the indices of the vertices in the mesh
- VtE all mesh locations including the original vertices
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_fem"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_fem}{}}}
\subsection{Method \code{compute_fem()}}{
build mass and stiffness matrices for given mesh object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_fem()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-mesh_A"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-mesh_A}{}}}
\subsection{Method \code{mesh_A()}}{
Computes observation matrix for mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$mesh_A(PtE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{locations given as (edge number in graph, location on edge)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-VtEfirst"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-VtEfirst}{}}}
\subsection{Method \code{VtEfirst()}}{
Find one Edge correspond to each Vertex (warning very
inefficient implementation)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$VtEfirst()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
VtE (n.v x 2) [1] edge number, [2] 0=  lower edge, 1=  upper edge
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-plot"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-plot}{}}}
\subsection{Method \code{plot()}}{
plot a metric graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot(
  plotly = FALSE,
  show = TRUE,
  line_width = 0.3,
  marker_size = 3,
  vertex_color = "black",
  edge_color = "black",
  data = FALSE,
  data_size = 1,
  mesh = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{plotly}}{use plot_ly for 3D plot (default FALSE)}

\item{\code{show}}{show the plot?}

\item{\code{line_width}}{line width for edges}

\item{\code{marker_size}}{size of markers for vertices}

\item{\code{vertex_color}}{color of vertices}

\item{\code{edge_color}}{color of edges}

\item{\code{data}}{Plot the data?}

\item{\code{data_size}}{size of markers for data}

\item{\code{mesh}}{Plot the mesh locations?}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a plot_ly or or ggplot object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(Lines = Lines)
graph$plot()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-plot_function"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-plot_function}{}}}
\subsection{Method \code{plot_function()}}{
plot function X on the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot_function(
  X,
  flat = TRUE,
  show = TRUE,
  graph_color = "rgb(0,0,0)",
  graph_width = 1,
  marker_size = 10,
  color = "rgb(0,0,200)",
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Either an m x 3 matrix with (edge number, position on
curve (in length), value) or a vector with values for the function
evaluated at a precomputed mesh.}

\item{\code{flat}}{plot in 2D or 3D?}

\item{\code{show}}{show the plot?}

\item{\code{graph_color}}{for 3D plot, the color of the graph.}

\item{\code{graph_width}}{for 3D plot, the line width of the graph.}

\item{\code{marker_size}}{for 3D plot, the marker size of the vertices}

\item{\code{color}}{Color of curve}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-plot_function_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-plot_function_mesh}{}}}
\subsection{Method \code{plot_function_mesh()}}{
plot function mesh X on the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot_function_mesh(
  X,
  plotly = FALSE,
  show = TRUE,
  graph_color = "black",
  graph_width = 1,
  marker_size = 10,
  color = "rgb(0,0,200)",
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{(m x 1) a vector with values for the function
evaluated at a precomputed mesh (V,and PtE)}

\item{\code{plotly}}{use plot_ly for 3D plot?}

\item{\code{show}}{show the plot?}

\item{\code{graph_color}}{for 3D plot, the color of the graph.}

\item{\code{graph_width}}{for 3D plot, the line width of the graph.}

\item{\code{marker_size}}{for 3D plot, the marker size of the vertices}

\item{\code{color}}{Color of curve}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-clone"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
