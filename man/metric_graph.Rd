% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric_graph.R
\name{metric_graph}
\alias{metric_graph}
\title{Metric graph object for specification of Gaussian processes}
\description{
Class representing general metric graphs.
}
\details{
A graph object created from vertex and edge matrices, or from an
sp::Lines object where each line is representing and edge.
}
\examples{

## ------------------------------------------------
## Method `metric_graph$plot`
## ------------------------------------------------

library(sp)
line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(Lines = Lines)
graph$plot()
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{V}}{Position in Euclidean space of the vertices}

\item{\code{nV}}{number of vertices}

\item{\code{E}}{Edges,  E\link{i,1} is the vertex at the start of the edge and  E\link{i,2}
is the vertex at the end of the edge}

\item{\code{nE}}{number of edges}

\item{\code{edge_lengths}}{length of edges}

\item{\code{EID}}{ID of edges}

\item{\code{LtE}}{Edge positions on lines}

\item{\code{ELend}}{normalized end point of edge on line (normalized on the line)}

\item{\code{ELstart}}{normalized start point of edge on line (normalized on the line)}

\item{\code{C}}{constraint matrix used to set Kirchhoff constraints}

\item{\code{A}}{Matrix specifying which vertices are observation locations}

\item{\code{CBobj}}{svd stuct object used for Kirchhoff constraints}

\item{\code{Points}}{Observations in SpatialPointsDataFrame}

\item{\code{y}}{the data connected to P}

\item{\code{PtE}}{Points to Line (connected to Points)
\link{,1} edge index
\link{,2} normalized distance along the line (i.e. distance to initial point)}

\item{\code{PtV}}{Vector with the indices of the vertices which are observation
locations}

\item{\code{mesh}}{mesh object used for plotting}

\item{\code{Lines}}{List of Lines object for building the graph}

\item{\code{geo.dist}}{Geodesic distance matrix}

\item{\code{res.dist}}{Resistance distance matrix}

\item{\code{Laplacian}}{The weighted graph Laplacian}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-GPGraph::graph-new}{\code{metric_graph$new()}}
\item \href{#method-GPGraph::graph-compute_geodist}{\code{metric_graph$compute_geodist()}}
\item \href{#method-GPGraph::graph-compute_geodist_mesh}{\code{metric_graph$compute_geodist_mesh()}}
\item \href{#method-GPGraph::graph-compute_resdist}{\code{metric_graph$compute_resdist()}}
\item \href{#method-GPGraph::graph-compute_resdist_mesh}{\code{metric_graph$compute_resdist_mesh()}}
\item \href{#method-GPGraph::graph-compute_laplacian}{\code{metric_graph$compute_laplacian()}}
\item \href{#method-GPGraph::graph-observation_to_vertex}{\code{metric_graph$observation_to_vertex()}}
\item \href{#method-GPGraph::graph-clear_observations}{\code{metric_graph$clear_observations()}}
\item \href{#method-GPGraph::graph-add_observations}{\code{metric_graph$add_observations()}}
\item \href{#method-GPGraph::graph-add_observations2}{\code{metric_graph$add_observations2()}}
\item \href{#method-GPGraph::graph-buildC}{\code{metric_graph$buildC()}}
\item \href{#method-GPGraph::graph-build_mesh}{\code{metric_graph$build_mesh()}}
\item \href{#method-GPGraph::graph-compute_fem}{\code{metric_graph$compute_fem()}}
\item \href{#method-GPGraph::graph-mesh_A}{\code{metric_graph$mesh_A()}}
\item \href{#method-GPGraph::graph-VtEfirst}{\code{metric_graph$VtEfirst()}}
\item \href{#method-GPGraph::graph-plot}{\code{metric_graph$plot()}}
\item \href{#method-GPGraph::graph-plot_function}{\code{metric_graph$plot_function()}}
\item \href{#method-GPGraph::graph-plot_function_mesh}{\code{metric_graph$plot_function_mesh()}}
\item \href{#method-GPGraph::graph-split_edge}{\code{metric_graph$split_edge()}}
\item \href{#method-GPGraph::graph-add_responses}{\code{metric_graph$add_responses()}}
\item \href{#method-GPGraph::graph-add_mesh_observations}{\code{metric_graph$add_mesh_observations()}}
\item \href{#method-GPGraph::graph-get_initial_graph}{\code{metric_graph$get_initial_graph()}}
\item \href{#method-GPGraph::graph-clone}{\code{metric_graph$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-new"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-new}{}}}
\subsection{Method \code{new()}}{
Create a new gpgraph_graph object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$new(Lines = NULL, P = NULL, E = NULL, edge_lengths = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Lines}}{sp object SpatialLines DataFrame or SpatialLines}

\item{\code{P}}{n x 2 matrix with Euclidean coordinates of the n vertices}

\item{\code{E}}{m x 2 matrix where each line represents an edge}

\item{\code{edge_lengths}}{m x 1 vector with edge lengths}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A graph object can be initialized in two ways. The first method
is to specify P and E. In this case, if edge_lengths is not specified, all
edges are assumed to be straight lines. Otherwise the edge lengths set in
edge_lengths are used. The second option is to specify the graph based on
Lines. In this case, the vertices are set by the end points of the lines.
Thus, if two lines are intersecting somewhere else, this will not be
viewed as a vertex.
}

\subsection{Returns}{
A metric_graph object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_geodist"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_geodist}{}}}
\subsection{Method \code{compute_geodist()}}{
Computes shortest path distances between the vertices in the
graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_geodist_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_geodist_mesh}{}}}
\subsection{Method \code{compute_geodist_mesh()}}{
Computes shortest path distances between the vertices in the
mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist_mesh()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_resdist"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_resdist}{}}}
\subsection{Method \code{compute_resdist()}}{
Computes the resistance metric of observations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist(PtE = NULL, normalized = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{points to compute the metric for, if not provided, the metric
is computed and stored for the observations in the graph}

\item{\code{normalized}}{are the locations in PtE in normalized distance?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_resdist_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_resdist_mesh}{}}}
\subsection{Method \code{compute_resdist_mesh()}}{
Computes the resistance metric between the vertices in the
mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist_mesh()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_laplacian"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_laplacian}{}}}
\subsection{Method \code{compute_laplacian()}}{
Compute graph Laplacian for the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_laplacian()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-observation_to_vertex"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-observation_to_vertex}{}}}
\subsection{Method \code{observation_to_vertex()}}{
Add observation locations as vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$observation_to_vertex()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-clear_observations"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-clear_observations}{}}}
\subsection{Method \code{clear_observations()}}{
Clear all observations from the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clear_observations()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_observations"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_observations}{}}}
\subsection{Method \code{add_observations()}}{
Add observations to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations(Spoints, y = NULL, y.index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Spoints}}{SpatialPoints or SpatialPointsDataFrame of the observations,
which may include the coordinates only, or the coordinates as well as the
observations}

\item{\code{y}}{the observations. These are used if provided, and otherwise the
observations are assumed to be in Spoints}

\item{\code{y.index}}{If \code{y} is not provided, \code{y.index} gives the column number
for the data to use in \code{Spoints@data}. If it is not provided, it is assumed
that the data is in the first column}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_observations2"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_observations2}{}}}
\subsection{Method \code{add_observations2()}}{
add observations to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations2(y, PtE, Spoints = NULL, normalized = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{(n x 1) the value of the observations}

\item{\code{PtE}}{(n x 2) edge index, distance on index}

\item{\code{Spoints}}{Optional argument of class SpatialPoints or
SpatialPointsDataFrame specifying the Euclidean coordinates of the
observation locations. If this is not provided, the coordinates are
calculated internally.}

\item{\code{normalized}}{if TRUE, then the distances in PtE are assumed to be
normalized to (0,1), default FALSE.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-buildC"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-buildC}{}}}
\subsection{Method \code{buildC()}}{
build Kirchoff constraint matrix from edges, NOT implemented
for circles (i.e. self closed edges)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$buildC(alpha, edge_constraint = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{alpha}}{(int) which type of constraint (currently only 2 implemented)}

\item{\code{edge_constraint}}{(bool) if true add constraint on vertices of
degree 1.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-build_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-build_mesh}{}}}
\subsection{Method \code{build_mesh()}}{
build mesh object for graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$build_mesh(h, n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{h}}{maximum distance between mesh nodes}

\item{\code{n}}{maximum number of nodes per edge}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The mesh is a list with the objects
\itemize{
\item PtE which contains the mesh locations excluding the original vertices
\item V the verties of the mesh
\item E the edges of the mesh
\item n_e the number of vertices in the mesh per original edge in the graph
\item h_e the mesh width per edge in the graph
\item ind the indices of the vertices in the mesh
\item VtE all mesh locations including the original vertices
}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_fem"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_fem}{}}}
\subsection{Method \code{compute_fem()}}{
build mass and stiffness matrices for given mesh object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_fem()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-mesh_A"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-mesh_A}{}}}
\subsection{Method \code{mesh_A()}}{
Computes observation matrix for mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$mesh_A(PtE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{locations given as (edge number in graph, location on edge)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-VtEfirst"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-VtEfirst}{}}}
\subsection{Method \code{VtEfirst()}}{
Find one Edge correspond to each Vertex (warning very
inefficient implementation)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$VtEfirst()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
VtE (n.v x 2) \link{1} edge number, \link{2} 0=  lower edge, 1=  upper edge
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-plot"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-plot}{}}}
\subsection{Method \code{plot()}}{
plot a metric graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot(
  plotly = FALSE,
  line_width = 0.3,
  vertex_size = 3,
  vertex_color = "black",
  edge_color = "black",
  data = FALSE,
  data_size = 1,
  mesh = FALSE,
  X = NULL,
  X_loc = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{plotly}}{use plot_ly for 3D plot (default FALSE)}

\item{\code{line_width}}{line width for edges}

\item{\code{vertex_size}}{size of the vertices}

\item{\code{vertex_color}}{color of vertices}

\item{\code{edge_color}}{color of edges}

\item{\code{data}}{Plot the data?}

\item{\code{data_size}}{size of markers for data}

\item{\code{mesh}}{Plot the mesh locations?}

\item{\code{X}}{Additional values to plot}

\item{\code{X_loc}}{locations of the additional values in the format
(edge, normalized distance on edge)}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a plot_ly or or ggplot object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(sp)
line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(Lines = Lines)
graph$plot()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-plot_function"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-plot_function}{}}}
\subsection{Method \code{plot_function()}}{
plot continuous function X on the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot_function(
  X,
  plotly = FALSE,
  graph_color = "black",
  line_width = 1,
  vertex_size = 10,
  color = "rgb(0,0,200)",
  p = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Either an m x 3 matrix with (edge number, position on
curve (in length), value) or a vector with values for the function
evaluated at a precomputed mesh.}

\item{\code{plotly}}{plot in 2D or 3D?}

\item{\code{graph_color}}{for 3D plot, the color of the graph.}

\item{\code{line_width}}{for 3D plot, the line width of the graph.}

\item{\code{vertex_size}}{for 3D plot, the vertex size of the vertices}

\item{\code{color}}{Color of curve}

\item{\code{p}}{previous plot in which the new plot should be added.}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-plot_function_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-plot_function_mesh}{}}}
\subsection{Method \code{plot_function_mesh()}}{
plot continuous function on the mesh of a graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot_function_mesh(
  X,
  plotly = FALSE,
  graph_color = "black",
  line_width = 1,
  vertex_size = 10,
  color = "rgb(0,0,200)",
  p = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Either an m x 3 matrix with (edge number, position on
curve (in length), value) or a vector with values for the function
evaluated at a precomputed mesh.}

\item{\code{plotly}}{plot in 2D or 3D?}

\item{\code{graph_color}}{for 3D plot, the color of the graph.}

\item{\code{line_width}}{for 3D plot, the line width of the curves.}

\item{\code{vertex_size}}{for 3D plot, the size of the vertices}

\item{\code{color}}{Color of the curves}

\item{\code{p}}{previous ggplot or plot_ly object to add the plot to}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-split_edge"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-split_edge}{}}}
\subsection{Method \code{split_edge()}}{
split_edge Function for splitting lines
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$split_edge(Ei, t)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Ei}}{index of line to split}

\item{\code{t}}{position on line to split (normalized)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_responses"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_responses}{}}}
\subsection{Method \code{add_responses()}}{
Auxiliar function for adding simulated response variables in the correct order.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_responses(y)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{A vector of response variables}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_mesh_observations"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_mesh_observations}{}}}
\subsection{Method \code{add_mesh_observations()}}{
Add observations on mesh to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_mesh_observations(y)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{the observations. These are used if provided, and otherwise the
observations are assumed to be in Spoints}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-get_initial_graph"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-get_initial_graph}{}}}
\subsection{Method \code{get_initial_graph()}}{
Get a copy of the initial graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$get_initial_graph()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-clone"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
