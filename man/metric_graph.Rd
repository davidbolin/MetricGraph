% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric_graph.R
\name{metric_graph}
\alias{metric_graph}
\title{Metric graph}
\description{
Class representing a general metric graph
}
\details{
A graph object created from vertex and edge matrices, or from an
sp::Lines object where each line is representing and edge. For more details,
see the help vignette:
\code{vignette("metric_graph", package = "MetricGraph")}
}
\examples{
library(sp)
line1 <- Line(rbind(c(0, 0), c(2, 0)))
line2 <- Line(rbind(c(2, 0), c(1, 1)))
line3 <- Line(rbind(c(1, 1), c(0, 0)))
lines <-  SpatialLines(list(Lines(list(line1), ID = "1"),
                           Lines(list(line2), ID = "2"),
                           Lines(list(line3), ID = "3")))
graph <- metric_graph$new(lines)
graph$plot()


## ------------------------------------------------
## Method `metric_graph$plot`
## ------------------------------------------------

library(sp)
line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(lines = Lines)
graph$plot()
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{V}}{matrix with positions in Euclidean space of the vertices of the
graph}

\item{\code{nV}}{the number of vertices}

\item{\code{E}}{matrix with the edges of the graph, where \code{E[i,1]} is the vertex
at the start of the ith edge and \code{E[i,2]} is the vertex at the end of the
edge}

\item{\code{nE}}{the number of edges}

\item{\code{edge_lengths}}{vector with the lengths of the edges in the graph}

\item{\code{EID}}{vector with the IDs of the edges in the graph}

\item{\code{LtE}}{matrix with edge positions on the lines}

\item{\code{ELend}}{vector with the locations of the end points of the edges on
the lines in the graph. The locations are normalized on the line}

\item{\code{ELstart}}{vector with the locations of the starting points of the
edges on the lines in the graph. The locations are normalized on the line}

\item{\code{C}}{constraint matrix used to set Kirchhoff constraints}

\item{\code{CoB}}{change-of-basis object used for Kirchhoff constraints}

\item{\code{points}}{the observations in a SpatialPointsDataFrame}

\item{\code{data}}{a list containing the data on the graph}

\item{\code{PtV}}{vector with the indices of the vertices which are observation
locations}

\item{\code{mesh}}{mesh object used for plotting}

\item{\code{lines}}{the lines in the graph}

\item{\code{geo_dist}}{geodesic distances between the vertices in the graph}

\item{\code{res_dist}}{resistance distances between the observation locations}

\item{\code{Laplacian}}{the weighted graph Laplacian of the vertices in the
graph. The weights are given by the edge lengths}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-metric_graph-new}{\code{metric_graph$new()}}
\item \href{#method-metric_graph-compute_geodist}{\code{metric_graph$compute_geodist()}}
\item \href{#method-metric_graph-compute_geodist_PtE}{\code{metric_graph$compute_geodist_PtE()}}
\item \href{#method-metric_graph-compute_geodist_mesh}{\code{metric_graph$compute_geodist_mesh()}}
\item \href{#method-metric_graph-compute_resdist}{\code{metric_graph$compute_resdist()}}
\item \href{#method-metric_graph-compute_resdist_PtE}{\code{metric_graph$compute_resdist_PtE()}}
\item \href{#method-metric_graph-get_degrees}{\code{metric_graph$get_degrees()}}
\item \href{#method-metric_graph-compute_resdist_mesh}{\code{metric_graph$compute_resdist_mesh()}}
\item \href{#method-metric_graph-compute_laplacian}{\code{metric_graph$compute_laplacian()}}
\item \href{#method-metric_graph-compute_laplacian_PtE}{\code{metric_graph$compute_laplacian_PtE()}}
\item \href{#method-metric_graph-get_PtE}{\code{metric_graph$get_PtE()}}
\item \href{#method-metric_graph-get_Spoints}{\code{metric_graph$get_Spoints()}}
\item \href{#method-metric_graph-observation_to_vertex}{\code{metric_graph$observation_to_vertex()}}
\item \href{#method-metric_graph-get_mesh_locations}{\code{metric_graph$get_mesh_locations()}}
\item \href{#method-metric_graph-clear_observations}{\code{metric_graph$clear_observations()}}
\item \href{#method-metric_graph-add_observations}{\code{metric_graph$add_observations()}}
\item \href{#method-metric_graph-buildC}{\code{metric_graph$buildC()}}
\item \href{#method-metric_graph-build_mesh}{\code{metric_graph$build_mesh()}}
\item \href{#method-metric_graph-compute_fem}{\code{metric_graph$compute_fem()}}
\item \href{#method-metric_graph-mesh_A}{\code{metric_graph$mesh_A()}}
\item \href{#method-metric_graph-VtEfirst}{\code{metric_graph$VtEfirst()}}
\item \href{#method-metric_graph-plot}{\code{metric_graph$plot()}}
\item \href{#method-metric_graph-plot_connections}{\code{metric_graph$plot_connections()}}
\item \href{#method-metric_graph-plot_function}{\code{metric_graph$plot_function()}}
\item \href{#method-metric_graph-add_mesh_observations}{\code{metric_graph$add_mesh_observations()}}
\item \href{#method-metric_graph-get_initial_graph}{\code{metric_graph$get_initial_graph()}}
\item \href{#method-metric_graph-A}{\code{metric_graph$A()}}
\item \href{#method-metric_graph-coordinates}{\code{metric_graph$coordinates()}}
\item \href{#method-metric_graph-clone}{\code{metric_graph$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-new"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{metric_graph} object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$new(
  lines = NULL,
  V = NULL,
  E = NULL,
  longlat = FALSE,
  tolerance = list(vertex_vertex = 1e-07, vertex_line = 1e-07, line_line = 0),
  check_connected = TRUE,
  adjust_lines = NULL,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lines}}{object of type \code{SpatialLinesDataFrame} or \code{SpatialLines}}

\item{\code{V}}{n x 2 matrix with Euclidean coordinates of the n vertices}

\item{\code{E}}{m x 2 matrix where each row represents an edge}

\item{\code{longlat}}{If TRUE, then it is assumed that the coordinates are given
in Longitude/Latitude and that distances should be computed in km.}

\item{\code{tolerance}}{a list that provides tolerances during the construction of
the graph:
\itemize{
\item \code{vertex_vertex} vertices that are closer than this number are merged
(default = 1e-7).
\item \code{vertex_line} if a vertex at the end of one line is closer than this
number to another line, this vertex is connected to that line
(default = 1e-7)
\item \code{line_line} if two lines at some point are closer than this number, a new
vertex is added at that point and the two lines are connected (default = 0)
}

If \code{longlat = TRUE}, the tolerances are given in km.}

\item{\code{check_connected}}{If \code{TRUE}, it is checked whether the graph is
connected and a warning is given if this is not the case.}

\item{\code{adjust_lines}}{Set to \code{TRUE} to adjust the lines object to match the graph
connections. This can take some time for large graphs, so by default it is \code{TRUE}
for graphs with at most 100 lines, and \code{FALSE} for larger graphs}

\item{\code{verbose}}{Print progress of graph creation}

\item{\code{merge_intersections}}{Which strategy should we use when lines intersect?
The options are: "end_points", we merge the lines only if the end points intersect;
"end_mid", we merge lines if the end of one line intersects another line;
"all_intersections", we merge the lines whenever they intersect. By default
we have "end_points".}

\item{\code{tolerance_intersections}}{tolerance for considering intersections of
lines according to the \code{merge_intersections} argument. Default = 0.}

\item{\code{tolerance_overlapping}}{tolerance for merging vertices that might seem overlapping.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A graph object can be initialized in two ways. The first method
is to specify V and E. In this case, all edges are assumed to be straight
lines. The second option is to specify the graph via the \code{lines} input.
In this case, the vertices are set by the end points of the lines.
Thus, if two lines are intersecting somewhere else, this will not be
viewed as a vertex.
}

\subsection{Returns}{
A metric_graph object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_geodist"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_geodist}{}}}
\subsection{Method \code{compute_geodist()}}{
Computes shortest path distances between the vertices in the
graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist(full = FALSE, obs = TRUE, group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{full}}{Should the geodesic distances be computed for all
the available locations. If \code{FALSE}, it will be computed
separately for the locations of each group.}

\item{\code{obs}}{Should the geodesic distances be computed at the observation locations?}

\item{\code{group}}{vector or list containing which groups to compute the distance
for. If \code{NULL}, it will be computed for all groups.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_geodist_PtE"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_geodist_PtE}{}}}
\subsection{Method \code{compute_geodist_PtE()}}{
Computes shortest path distances between the vertices in the
graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist_PtE(PtE, normalized = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{points to compute the metric for.}

\item{\code{normalized}}{are the locations in PtE in normalized distance?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_geodist_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_geodist_mesh}{}}}
\subsection{Method \code{compute_geodist_mesh()}}{
Computes shortest path distances between the vertices in the
mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist_mesh()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_resdist"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_resdist}{}}}
\subsection{Method \code{compute_resdist()}}{
Computes the resistance distance between the observation
locations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist(full = FALSE, obs = TRUE, group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{full}}{Should the resistance distances be computed for all
the available locations. If \code{FALSE}, it will be computed
separately for the locations of each group.}

\item{\code{obs}}{Should the resistance distances be computed at the observation locations?}

\item{\code{group}}{vector or list containing which groups to compute the distance
for. If \code{NULL}, it will be computed for all groups.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_resdist_PtE"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_resdist_PtE}{}}}
\subsection{Method \code{compute_resdist_PtE()}}{
Computes the resistance distance between the observation
locations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist_PtE(PtE, normalized = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{points to compute the metric for.}

\item{\code{normalized}}{are the locations in PtE in normalized distance?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-get_degrees"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-get_degrees}{}}}
\subsection{Method \code{get_degrees()}}{
Gets the degrees of the vertices
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$get_degrees()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_resdist_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_resdist_mesh}{}}}
\subsection{Method \code{compute_resdist_mesh()}}{
Computes the resistance metric between the vertices in the
mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist_mesh()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_laplacian"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_laplacian}{}}}
\subsection{Method \code{compute_laplacian()}}{
Computes the weigthed graph Laplacian for the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_laplacian(full = FALSE, obs = TRUE, group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{full}}{Should the resistance distances be computed for all
the available locations. If \code{FALSE}, it will be computed
separately for the locations of each group.}

\item{\code{obs}}{Should the resistance distances be computed at the observation locations?}

\item{\code{group}}{vector or list containing which groups to compute the
Laplacian for. If \code{NULL}, it will be computed for all groups.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_laplacian_PtE"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_laplacian_PtE}{}}}
\subsection{Method \code{compute_laplacian_PtE()}}{
Computes the weigthed graph Laplacian for the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_laplacian_PtE(PtE, normalized = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{points to compute the metric for.}

\item{\code{normalized}}{are the locations in PtE in normalized distance?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-get_PtE"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-get_PtE}{}}}
\subsection{Method \code{get_PtE()}}{
Gets PtE from the data
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$get_PtE()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-get_Spoints"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-get_Spoints}{}}}
\subsection{Method \code{get_Spoints()}}{
Gets the spatial points from the data.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$get_Spoints()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-observation_to_vertex"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-observation_to_vertex}{}}}
\subsection{Method \code{observation_to_vertex()}}{
Adds observation locations as vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$observation_to_vertex(tolerance = 1e-10)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tolerance}}{parameter in which we merge vertices together. Not intended for non-expert use.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-get_mesh_locations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-get_mesh_locations}{}}}
\subsection{Method \code{get_mesh_locations()}}{
Returns a list or a matrix with the mesh locations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$get_mesh_locations(bru = FALSE, loc = "loc")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{bru}}{logical. Should an \code{inlabru}-friendly list be returned?}

\item{\code{loc}}{character. If \code{bru} is set to \code{TRUE}, the name of the location variable.
The default name is 'loc'.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-clear_observations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-clear_observations}{}}}
\subsection{Method \code{clear_observations()}}{
Clear all observations from the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clear_observations()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-add_observations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-add_observations}{}}}
\subsection{Method \code{add_observations()}}{
Add observations to the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations(
  Spoints = NULL,
  data = NULL,
  edge_number = "edge_number",
  distance_on_edge = "distance_on_edge",
  coord_x = "coord_x",
  coord_y = "coord_y",
  data_coords = c("PtE", "euclidean"),
  group = NULL,
  normalized = FALSE,
  tolerance = max(self$edge_lengths)/2
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Spoints}}{SpatialPoints or SpatialPointsDataFrame of the observations,
which may include the coordinates only, or the coordinates as well as the
observations.}

\item{\code{data}}{A data.frame or named list containing the observations. In case
of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. If \code{data} is not \code{NULL},
it takes priority over any eventual data in \code{Spoints}.}

\item{\code{edge_number}}{Column (or entry on the list) of the \code{data} that
contains the edge numbers. If not supplied, the column with name
"edge_number" will be chosen. Will not be used if \code{Spoints} is not \code{NULL}.}

\item{\code{distance_on_edge}}{Column (or entry on the list) of the \code{data} that
contains the edge numbers. If not supplied, the column with name
"distance_on_edge" will be chosen.  Will not be used if \code{Spoints} is not
\code{NULL}.}

\item{\code{coord_x}}{Column (or entry on the list) of the \code{data} that contains
the x coordinate. If not supplied, the column with name "coord_x" will be
chosen. Will not be used if \code{Spoints} is not \code{NULL} or if \code{data_coords} is
\code{PtE}.}

\item{\code{coord_y}}{Column (or entry on the list) of the \code{data} that contains
the y coordinate. If not supplied, the column with name "coord_x" will be
chosen. Will not be used if \code{Spoints} is not \code{NULL} or if \code{data_coords} is
\code{PtE}.}

\item{\code{data_coords}}{To be used only if \code{Spoints} is \code{NULL}. It decides which
coordinate system to use. If \code{PtE}, the user must provide \code{edge_number} and
\code{distance_on_edge}, otherwise if \code{euclidean}, the user must provide
\code{coord_x} and \code{coord_y}.}

\item{\code{group}}{If the data is grouped (for example measured at different time
points), this argument specifies the the column (or entry on the list) in
which the group varialbe is stored.}

\item{\code{normalized}}{if TRUE, then the distances in \code{distance_on_edge} are
assumed to be normalized to (0,1). Default FALSE. Will not be used if
\code{Spoints} is not \code{NULL}.}

\item{\code{tolerance}}{Parameter to control a warning when adding observations.
If the distance of some location and the closest point on the graph is
greater than the tolerance, the function will display a warning.
This helps detecting mistakes on the input
locations when adding new data.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-buildC"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-buildC}{}}}
\subsection{Method \code{buildC()}}{
build Kirchoff constraint matrix from edges, currently not
implemented for circles (edges that start and end in the same vertex)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$buildC(alpha = 2, edge_constraint = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{alpha}}{the type of constraint (currently only supports 2)}

\item{\code{edge_constraint}}{if TRUE, add constraints on vertices of degree 1}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-build_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-build_mesh}{}}}
\subsection{Method \code{build_mesh()}}{
build mesh object for graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$build_mesh(h = NULL, n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{h}}{maximum distance between mesh nodes (should be provided if n is not provided)}

\item{\code{n}}{maximum number of nodes per edge (should be provided if h is not provided)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The mesh is a list with the objects
\itemize{
\item PtE which contains the mesh locations excluding the original vertices
\item V the verties of the mesh
\item E the edges of the mesh
\item n_e the number of vertices in the mesh per original edge in the graph
\item h_e the mesh width per edge in the graph
\item ind the indices of the vertices in the mesh
\item VtE all mesh locations including the original vertices
}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_fem"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_fem}{}}}
\subsection{Method \code{compute_fem()}}{
build mass and stiffness matrices for given mesh object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_fem()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-mesh_A"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-mesh_A}{}}}
\subsection{Method \code{mesh_A()}}{
Computes observation matrix for mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$mesh_A(PtE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{locations given as (edge number in graph, normalized location on
edge)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-VtEfirst"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-VtEfirst}{}}}
\subsection{Method \code{VtEfirst()}}{
Find one edge corresponding to each vertex
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$VtEfirst()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
VtE matrix where \code{VtE[i,1]} is the edge number, \code{VtE[i,2] = 0}
if the vertex is at the start of the edge and \code{VtE[i,1] = 1} if the vertex
is at the end of the edge
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-plot"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-plot}{}}}
\subsection{Method \code{plot()}}{
plot a metric graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot(
  data = NULL,
  group = 1,
  plotly = FALSE,
  vertex_size = 3,
  vertex_color = "black",
  edge_width = 0.3,
  edge_color = "black",
  data_size = 1,
  mesh = FALSE,
  X = NULL,
  X_loc = NULL,
  p = NULL,
  degree = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{Which column of the data to plot? If \code{NULL}, no data will be
plotted.}

\item{\code{group}}{If there are groups, which group to plot? If \code{group} is a
number, it will be the index of the group as stored internally. If \code{group}
is a character, then the group will be chosen by its name.}

\item{\code{plotly}}{use plot_ly for 3D plot (default FALSE). This option requires
the 'plotly' package.}

\item{\code{vertex_size}}{size of the vertices}

\item{\code{vertex_color}}{color of vertices}

\item{\code{edge_width}}{line width for edges}

\item{\code{edge_color}}{color of edges}

\item{\code{data_size}}{size of markers for data}

\item{\code{mesh}}{Plot the mesh locations?}

\item{\code{X}}{Additional values to plot}

\item{\code{X_loc}}{locations of the additional values in the format
(edge, normalized distance on edge)}

\item{\code{p}}{existing ggplot or plot_ly object to add the graph to}

\item{\code{degree}}{show the degrees of the vertices?}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a plot_ly or or ggplot object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(sp)
line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(lines = Lines)
graph$plot()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-plot_connections"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-plot_connections}{}}}
\subsection{Method \code{plot_connections()}}{
Plots the connections
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot_connections()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-plot_function"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-plot_function}{}}}
\subsection{Method \code{plot_function()}}{
plot continuous function on the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot_function(
  X,
  plotly = FALSE,
  vertex_size = 5,
  vertex_color = "black",
  edge_width = 1,
  edge_color = "black",
  line_width = NULL,
  line_color = "rgb(0,0,200)",
  support_width = 0.5,
  support_color = "gray",
  p = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Either an m x 3 matrix with (edge number, position on
curve (in length), value) or a vector with values for the function
evaluated at the mesh in the graph}

\item{\code{plotly}}{if TRUE, then plot is shown in 3D. This option requires the
package 'plotly'.}

\item{\code{vertex_size}}{(for both 2d and 3d plots) size of the vertices}

\item{\code{vertex_color}}{color of vertices}

\item{\code{edge_width}}{width for edges}

\item{\code{edge_color}}{for 3D plot, color of edges}

\item{\code{line_width}}{for 3D plot, line width of the function curve.}

\item{\code{line_color}}{color of the function curve}

\item{\code{support_width}}{for 3D plot, width of support lines}

\item{\code{support_color}}{for 3D plot, color of support lines}

\item{\code{p}}{previous plot in which the new plot should be added.}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
either a ggplot or a plot_ly object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-add_mesh_observations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-add_mesh_observations}{}}}
\subsection{Method \code{add_mesh_observations()}}{
Add observations on mesh to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_mesh_observations(data = NULL, group = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{A data.frame or named list containing the observations. In case
of groups, the data.frames for the groups should be stacked vertically,
with a column indicating the index of the group. If \code{data_frame} is not
\code{NULL}, it takes priority over any eventual data in \code{Spoints}.}

\item{\code{group}}{If the data_frame contains groups, one must provide the column
in which the group indices are stored.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-get_initial_graph"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-get_initial_graph}{}}}
\subsection{Method \code{get_initial_graph()}}{
Get a copy of the initial graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$get_initial_graph()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-A"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-A}{}}}
\subsection{Method \code{A()}}{
Get the observation/prediction matrix A
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$A(group = NULL, obs_to_vert = FALSE, include_NA = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{group}}{A vector. If \code{NULL}, the A matrix for the first group will be
returned. One can use all groups by simply setting the \code{group} variable
to \verb{__all}. Otherwise, the A matrix for the groups in the vector will be
returned.}

\item{\code{obs_to_vert}}{Should the observations be turned into vertices?}

\item{\code{include_NA}}{Should the locations for which all observations are NA be
included?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-coordinates"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-coordinates}{}}}
\subsection{Method \code{coordinates()}}{
Convert between locations on the graph and Euclidean
coordinates
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$coordinates(PtE = NULL, XY = NULL, normalized = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{matrix with locations on the graph (edge number and normalized
position on the edge).}

\item{\code{XY}}{matrix with locations in Euclidean space}

\item{\code{normalized}}{If TRUE, it is assumed that the positions in \code{PtE} are
normalized to (0,1), and the object returned if \code{XY} is specified contains
normalized locations.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
If \code{PtE} is specified, then a matrix with Euclidean coordinates of
the locations is returned. If \code{XY} is provided, then a matrix with the
closest locations on the graph is returned
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-clone"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
