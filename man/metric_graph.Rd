% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric_graph.R
\name{metric_graph}
\alias{metric_graph}
\title{Metric graph object for specification of Gaussian processes}
\description{
Class representing a general metric graphs.
}
\details{
A graph object created from vertex and edge matrices, or from an
sp::Lines object where each line is representing and edge. For more details,
see the help vignette:
\code{vignette("metric_graph", package = "MetricGraph")}
}
\examples{
library(sp)
line1 <- Line(rbind(c(0, 0), c(2, 0)))
line2 <- Line(rbind(c(2, 0), c(1, 1)))
line3 <- Line(rbind(c(1, 1), c(0, 0)))
lines <-  SpatialLines(list(Lines(list(line1), ID = "1"),
                           Lines(list(line2), ID = "2"),
                           Lines(list(line3), ID = "3")))
graph <- metric_graph$new(lines)
graph$plot()


## ------------------------------------------------
## Method `metric_graph$plot`
## ------------------------------------------------

library(sp)
line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(lines = Lines)
graph$plot()
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{V}}{matrix with positions in Euclidean space of the vertices of the
graph}

\item{\code{nV}}{the number of vertices}

\item{\code{E}}{matrix with the edges of the graph, where \code{E[i,1]} is the vertex
at the start of the ith edge and \code{E[i,2]} is the vertex at the end of the
edge}

\item{\code{nE}}{the number of edges}

\item{\code{edge_lengths}}{vector with the lengths of the edges in the graph}

\item{\code{EID}}{vector with the IDs of the edges in the graph}

\item{\code{LtE}}{matrix with edge positions on the lines}

\item{\code{ELend}}{vector with the locations of the end points of the edges on
the lines in the graph. The locations are normalized on the line}

\item{\code{ELstart}}{vector with the locations of the starting points of the
edges on the lines in the graph. The locations are normalized on the line}

\item{\code{C}}{constraint matrix used to set Kirchhoff constraints}

\item{\code{CoB}}{change-of-basis object used for Kirchhoff constraints}

\item{\code{points}}{the observations in a SpatialPointsDataFrame}

\item{\code{y}}{vector with data on the graph}

\item{\code{covariates}}{list containing the covariates}

\item{\code{PtE}}{matrix specifying the locations of the observation points on
the edges, where \code{PtE[i,1]} is the edge index for the ith observation
and  \code{PtE[,2]} is the normalized distance on the edge}

\item{\code{PtV}}{vector with the indices of the vertices which are observation
locations}

\item{\code{mesh}}{mesh object used for plotting}

\item{\code{lines}}{the lines in the graph}

\item{\code{geo_dist}}{geodesic distances between the vertices in the graph}

\item{\code{res_dist}}{resistance distances between the observation locations}

\item{\code{Laplacian}}{the weighted graph Laplacian of the vertices in the
graph. The weights are given by the edge lengths}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-metric_graph-new}{\code{metric_graph$new()}}
\item \href{#method-metric_graph-compute_geodist}{\code{metric_graph$compute_geodist()}}
\item \href{#method-metric_graph-compute_geodist_mesh}{\code{metric_graph$compute_geodist_mesh()}}
\item \href{#method-metric_graph-compute_resdist}{\code{metric_graph$compute_resdist()}}
\item \href{#method-metric_graph-compute_resdist_mesh}{\code{metric_graph$compute_resdist_mesh()}}
\item \href{#method-metric_graph-compute_laplacian}{\code{metric_graph$compute_laplacian()}}
\item \href{#method-metric_graph-observation_to_vertex}{\code{metric_graph$observation_to_vertex()}}
\item \href{#method-metric_graph-clear_observations}{\code{metric_graph$clear_observations()}}
\item \href{#method-metric_graph-add_observations}{\code{metric_graph$add_observations()}}
\item \href{#method-metric_graph-add_PtE_observations}{\code{metric_graph$add_PtE_observations()}}
\item \href{#method-metric_graph-buildC}{\code{metric_graph$buildC()}}
\item \href{#method-metric_graph-build_mesh}{\code{metric_graph$build_mesh()}}
\item \href{#method-metric_graph-compute_fem}{\code{metric_graph$compute_fem()}}
\item \href{#method-metric_graph-mesh_A}{\code{metric_graph$mesh_A()}}
\item \href{#method-metric_graph-VtEfirst}{\code{metric_graph$VtEfirst()}}
\item \href{#method-metric_graph-plot}{\code{metric_graph$plot()}}
\item \href{#method-metric_graph-plot_function}{\code{metric_graph$plot_function()}}
\item \href{#method-metric_graph-split_edge}{\code{metric_graph$split_edge()}}
\item \href{#method-metric_graph-add_responses}{\code{metric_graph$add_responses()}}
\item \href{#method-metric_graph-add_mesh_observations}{\code{metric_graph$add_mesh_observations()}}
\item \href{#method-metric_graph-get_initial_graph}{\code{metric_graph$get_initial_graph()}}
\item \href{#method-metric_graph-A}{\code{metric_graph$A()}}
\item \href{#method-metric_graph-coordinates}{\code{metric_graph$coordinates()}}
\item \href{#method-metric_graph-add_covariates}{\code{metric_graph$add_covariates()}}
\item \href{#method-metric_graph-clone}{\code{metric_graph$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-new"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-new}{}}}
\subsection{Method \code{new()}}{
Create a new \code{metric_graph} object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$new(
  lines = NULL,
  V = NULL,
  E = NULL,
  longlat = FALSE,
  tolerance = 1e-10
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lines}}{object of type \code{SpatialLinesDataFrame} or \code{SpatialLines}}

\item{\code{V}}{n x 2 matrix with Euclidean coordinates of the n vertices}

\item{\code{E}}{m x 2 matrix where each row represents an edge}

\item{\code{longlat}}{If TRUE, then it is assumed that the coordinates are given
in Longitude/Latitude and that distances should be computed in km.}

\item{\code{tolerance}}{vertices that are closer than this number are merged when
constructing the graph (default = 1e-10). If \code{longlat = TRUE}, the
tolerance is given in km.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A graph object can be initialized in two ways. The first method
is to specify V and E. In this case, all edges are assumed to be straight
lines. The second option is to specify the graph via the \code{lines} input.
In this case, the vertices are set by the end points of the lines.
Thus, if two lines are intersecting somewhere else, this will not be
viewed as a vertex.
}

\subsection{Returns}{
A metric_graph object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_geodist"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_geodist}{}}}
\subsection{Method \code{compute_geodist()}}{
Computes shortest path distances between the vertices in the
graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_geodist_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_geodist_mesh}{}}}
\subsection{Method \code{compute_geodist_mesh()}}{
Computes shortest path distances between the vertices in the
mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist_mesh()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_resdist"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_resdist}{}}}
\subsection{Method \code{compute_resdist()}}{
Computes the resistance distance between the observation
locations
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist(PtE = NULL, normalized = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{points to compute the metric for, if not provided, the metric
is computed and stored for the observations in the graph}

\item{\code{normalized}}{are the locations in PtE in normalized distance?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_resdist_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_resdist_mesh}{}}}
\subsection{Method \code{compute_resdist_mesh()}}{
Computes the resistance metric between the vertices in the
mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist_mesh()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_laplacian"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_laplacian}{}}}
\subsection{Method \code{compute_laplacian()}}{
Computes the weigthed graph Laplacian for the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_laplacian()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-observation_to_vertex"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-observation_to_vertex}{}}}
\subsection{Method \code{observation_to_vertex()}}{
Adds observation locations as vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$observation_to_vertex()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-clear_observations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-clear_observations}{}}}
\subsection{Method \code{clear_observations()}}{
Clear all observations from the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clear_observations()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-add_observations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-add_observations}{}}}
\subsection{Method \code{add_observations()}}{
Add observations to the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations(
  Spoints,
  y = NULL,
  covariates = NULL,
  y.index = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Spoints}}{SpatialPoints or SpatialPointsDataFrame of the observations,
which may include the coordinates only, or the coordinates as well as the
observations}

\item{\code{y}}{the observations. A matrix \verb{N x k}, where \code{N} is the number of observations and
\code{k} is the number of replicates. Can be \code{NA} if the observation is not available. These are used if provided, and otherwise the
observations are assumed to be in Spoints.}

\item{\code{covariates}}{the covariates. A list, with either 1 entry or entries \verb{1,...,n_repl}, where \code{n_repl} is the number of replicates.
Each entry consists of a matrix \verb{N x p}, where \code{N} is the number of observations and
\code{p} is the number of covariates.}

\item{\code{y.index}}{If \code{y} is not provided, \code{y.index} gives the column number
for the data to use in \code{Spoints@data}. If it is not provided, it is assumed
that the data is in the first column}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-add_PtE_observations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-add_PtE_observations}{}}}
\subsection{Method \code{add_PtE_observations()}}{
Add observations to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_PtE_observations(
  y,
  PtE,
  covariates = NULL,
  Spoints = NULL,
  normalized = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{vector with the values of the observations}

\item{\code{PtE}}{matrix where \code{PtE[i,1]} is the index of the edge for the ith
observation and \code{PtE[i,2]} is the distance on the edge where the
observation is located}

\item{\code{covariates}}{the covariates. A list, with either 1 entry or entries \verb{1,...,n_repl}, where \code{n_repl} is the number of replicates.
Each entry consists of a matrix \verb{N x p}, where \code{N} is the number of observations and
\code{p} is the number of covariates.}

\item{\code{Spoints}}{Optional argument of class \code{SpatialPoints} or
\code{SpatialPointsDataFrame} specifying the Euclidean coordinates of the
observation locations. If this is not provided, the coordinates are
calculated internally.}

\item{\code{normalized}}{if TRUE, then the distances in \code{PtE} are assumed to be
normalized to (0,1). Default FALSE.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-buildC"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-buildC}{}}}
\subsection{Method \code{buildC()}}{
build Kirchoff constraint matrix from edges, currently not
implemented for circles (edges that start and end in the same vertex)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$buildC(alpha = 2, edge_constraint = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{alpha}}{the type of constraint (currently only supports 2)}

\item{\code{edge_constraint}}{if TRUE, add constraints on vertices of degree 1}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-build_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-build_mesh}{}}}
\subsection{Method \code{build_mesh()}}{
build mesh object for graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$build_mesh(h = NULL, n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{h}}{maximum distance between mesh nodes (should be provided if n is not provided)}

\item{\code{n}}{maximum number of nodes per edge (should be provided if h is not provided)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The mesh is a list with the objects
\itemize{
\item PtE which contains the mesh locations excluding the original vertices
\item V the verties of the mesh
\item E the edges of the mesh
\item n_e the number of vertices in the mesh per original edge in the graph
\item h_e the mesh width per edge in the graph
\item ind the indices of the vertices in the mesh
\item VtE all mesh locations including the original vertices
}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-compute_fem"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-compute_fem}{}}}
\subsection{Method \code{compute_fem()}}{
build mass and stiffness matrices for given mesh object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_fem()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-mesh_A"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-mesh_A}{}}}
\subsection{Method \code{mesh_A()}}{
Computes observation matrix for mesh
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$mesh_A(PtE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{locations given as (edge number in graph, normalized location on edge)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-VtEfirst"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-VtEfirst}{}}}
\subsection{Method \code{VtEfirst()}}{
Find one edge corresponding to each vertex
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$VtEfirst()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
VtE matrix where \code{VtE[i,1]} is the edge number, \code{VtE[i,2] = 0}
if the vertex is at the start of the edge and \code{VtE[i,1] = 1} if the vertex
is at the end of the edge
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-plot"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-plot}{}}}
\subsection{Method \code{plot()}}{
plot a metric graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot(
  plotly = FALSE,
  vertex_size = 3,
  vertex_color = "black",
  edge_width = 0.3,
  edge_color = "black",
  data = FALSE,
  repl = 1,
  data_size = 1,
  mesh = FALSE,
  X = NULL,
  X_loc = NULL,
  p = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{plotly}}{use plot_ly for 3D plot (default FALSE). This option requires the 'plotly' package.}

\item{\code{vertex_size}}{size of the vertices}

\item{\code{vertex_color}}{color of vertices}

\item{\code{edge_width}}{line width for edges}

\item{\code{edge_color}}{color of edges}

\item{\code{data}}{Plot the data?}

\item{\code{repl}}{If there are replicates, which replicate to plot?}

\item{\code{data_size}}{size of markers for data}

\item{\code{mesh}}{Plot the mesh locations?}

\item{\code{X}}{Additional values to plot}

\item{\code{X_loc}}{locations of the additional values in the format
(edge, normalized distance on edge)}

\item{\code{p}}{existing ggplot or plot_ly object to add the graph to}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a plot_ly or or ggplot object
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{library(sp)
line1 <- Line(rbind(c(0,0),c(1,0)))
line2 <- Line(rbind(c(0,0),c(0,1)))
line3 <- Line(rbind(c(0,1),c(-1,1)))
theta <- seq(from=pi,to=3*pi/2,length.out = 20)
line4 <- Line(cbind(sin(theta),1+ cos(theta)))
Lines = sp::SpatialLines(list(Lines(list(line1),ID="1"),
                              Lines(list(line2),ID="2"),
                              Lines(list(line3),ID="3"),
                              Lines(list(line4),ID="4")))
graph <- metric_graph$new(lines = Lines)
graph$plot()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-plot_function"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-plot_function}{}}}
\subsection{Method \code{plot_function()}}{
plot continuous function on the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$plot_function(
  X,
  plotly = FALSE,
  vertex_size = 5,
  vertex_color = "black",
  edge_width = 1,
  edge_color = "black",
  line_width = NULL,
  line_color = "rgb(0,0,200)",
  support_width = 0.5,
  support_color = "gray",
  p = NULL,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{X}}{Either an m x 3 matrix with (edge number, position on
curve (in length), value) or a vector with values for the function
evaluated at the mesh in the graph}

\item{\code{plotly}}{if TRUE, then plot is shown in 3D. This option requires the package 'plotly'.}

\item{\code{vertex_size}}{(for both 2d and 3d plots) size of the vertices}

\item{\code{vertex_color}}{color of vertices}

\item{\code{edge_width}}{width for edges}

\item{\code{edge_color}}{for 3D plot, color of edges}

\item{\code{line_width}}{for 3D plot, line width of the function curve.}

\item{\code{line_color}}{color of the function curve}

\item{\code{support_width}}{for 3D plot, width of support lines}

\item{\code{support_color}}{for 3D plot, color of support lines}

\item{\code{p}}{previous plot in which the new plot should be added.}

\item{\code{...}}{additional arguments for ggplot or plot_ly}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
either a ggplot or a plot_ly object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-split_edge"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-split_edge}{}}}
\subsection{Method \code{split_edge()}}{
function for splitting lines in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$split_edge(Ei, t)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Ei}}{index of line to split}

\item{\code{t}}{position on line to split (normalized)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-add_responses"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-add_responses}{}}}
\subsection{Method \code{add_responses()}}{
function for adding simulated response variables in the
correct order.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_responses(y)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{A vector of response variables}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-add_mesh_observations"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-add_mesh_observations}{}}}
\subsection{Method \code{add_mesh_observations()}}{
Add observations on mesh to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_mesh_observations(y, covariates = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{the observations.}

\item{\code{covariates}}{A list containing the covariates.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-get_initial_graph"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-get_initial_graph}{}}}
\subsection{Method \code{get_initial_graph()}}{
Get a copy of the initial graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$get_initial_graph()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-A"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-A}{}}}
\subsection{Method \code{A()}}{
Get the observation/prediction matrix A
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$A(order = "internal", obs_to_vert = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{order}}{Which order should be considered? The options are 'internal' and 'original'.
The order 'internal' is the order of \verb{graph$y``, for a metric_graph }graph`. The order 'original'
is the order of the user's input.}

\item{\code{obs_to_vert}}{Should the observations be turned into vertices?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-coordinates"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-coordinates}{}}}
\subsection{Method \code{coordinates()}}{
Convert between locations on the graph and Euclidean coordinates
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$coordinates(PtE = NULL, XY = NULL, normalized = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{PtE}}{matrix with locations on the graph (edge number and normalized
position on the edge).}

\item{\code{XY}}{matrix with locations in Euclidean space}

\item{\code{normalized}}{If TRUE, it is assumed that the positions in \code{PtE} are
normalized to (0,1), and the object returned if \code{XY} is specified contains
normalized locations.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
If \code{PtE} is specified, then a matrix with Euclidean coordinates of
the locations is returned. If \code{XY} is provided, then a matrix with the
closest locations on the graph is returned
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-add_covariates"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-add_covariates}{}}}
\subsection{Method \code{add_covariates()}}{
function for adding covariates in the
correct order.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_covariates(covariates)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{covariates}}{the covariates. A list, with either 1 entry or entries \verb{1,...,n_repl}, where \code{n_repl} is the number of replicates.
Each entry consists of a matrix \verb{N x p}, where \code{N} is the number of observations and
\code{p} is the number of covariates.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-metric_graph-clone"></a>}}
\if{latex}{\out{\hypertarget{method-metric_graph-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
