% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph.object.R
\name{metric_graph}
\alias{metric_graph}
\title{Metric graph object for specification of Gaussian processes}
\description{
Class representing general metric graphs.
}
\details{
A graph object created from vertex and edge matrices, or from
an sp::Lines object where each line is representing and edge.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{V}}{Position in Euclidean space of the vertices}

\item{\code{nV}}{number of vertices}

\item{\code{E}}{Edges,  E[i,2] is the vertex at the start of the edge and
E[i,2] is the vertex at the end of the edge}

\item{\code{nE}}{number of edges}

\item{\code{edge_lengths}}{length of edges}

\item{\code{EID}}{ID of edges}

\item{\code{C}}{constraint matrix used to set Kirchhoff constraints}

\item{\code{A}}{observation matrix specifying which vertices are
observation locations}

\item{\code{CBobj}}{Change of basis structure object}

\item{\code{Points}}{Observations in SpatialPointsDataFrame}

\item{\code{y}}{the data connected to P}

\item{\code{PtE}}{Points to Line (connected to Points),
[,1] - edge index,
[,2] - distance along the line (i.e. distance to initial point)}

\item{\code{PtV}}{Points to Vertex observations to vertex
[,1] - vertex index,}

\item{\code{mesh}}{mesh object used for plotting}

\item{\code{Lines}}{List of Lines object for building the graph}

\item{\code{geo.dist}}{Geodesic distance matrix}

\item{\code{res.dist}}{Resistance distance matrix}

\item{\code{Laplacian}}{The weighted graph Laplacian}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-GPGraph::graph-new}{\code{metric_graph$new()}}
\item \href{#method-GPGraph::graph-split_line}{\code{metric_graph$split_line()}}
\item \href{#method-GPGraph::graph-compute_geodist}{\code{metric_graph$compute_geodist()}}
\item \href{#method-GPGraph::graph-compute_resdist}{\code{metric_graph$compute_resdist()}}
\item \href{#method-GPGraph::graph-compute_laplacian}{\code{metric_graph$compute_laplacian()}}
\item \href{#method-GPGraph::graph-observation_to_vertex}{\code{metric_graph$observation_to_vertex()}}
\item \href{#method-GPGraph::graph-add_observations}{\code{metric_graph$add_observations()}}
\item \href{#method-GPGraph::graph-add_observations2}{\code{metric_graph$add_observations2()}}
\item \href{#method-GPGraph::graph-buildC}{\code{metric_graph$buildC()}}
\item \href{#method-GPGraph::graph-build_mesh}{\code{metric_graph$build_mesh()}}
\item \href{#method-GPGraph::graph-clone}{\code{metric_graph$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-new"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-new}{}}}
\subsection{Method \code{new()}}{
Create a new metric_graph object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$new(Lines = NULL, P = NULL, E = NULL, edge_lengths = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Lines}}{sp object SpatialLines DataFrame or SpatialLines}

\item{\code{P}}{n x 2 matrix with Euclidean coordinates of the n vertices}

\item{\code{E}}{m x 2 matrix where each line represents an edge}

\item{\code{edge_lengths}}{m x 1 vector with edge lengths}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A graph object can be initialized in two ways. The first method is
to specify P and E. In this case, if edge_lengths is not specified, all
edges are assumed to be straight lines. Otherwise the edge lengths set in
edge_lengths are used. The second option is to specify the graph based on
Lines. In this case, the vertices are set by the end points of the lines.
Thus, if two lines are intersecting somewhere else, this will not be viewed
as a vertex.
}

\subsection{Returns}{
A gpgraph_graph object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-split_line"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-split_line}{}}}
\subsection{Method \code{split_line()}}{
Split line by point
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$split_line(Ei, t)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Ei}}{Index of edge to be split}

\item{\code{t}}{Normalized distance to first edge}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_geodist"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_geodist}{}}}
\subsection{Method \code{compute_geodist()}}{
Computes shortest path distances between the vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_geodist()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_resdist"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_resdist}{}}}
\subsection{Method \code{compute_resdist()}}{
Computes the resistance metric between the vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_resdist()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-compute_laplacian"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-compute_laplacian}{}}}
\subsection{Method \code{compute_laplacian()}}{
Compute graph Laplacian for the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$compute_laplacian()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-observation_to_vertex"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-observation_to_vertex}{}}}
\subsection{Method \code{observation_to_vertex()}}{
Add observation locations as vertices in the graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$observation_to_vertex()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_observations"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_observations}{}}}
\subsection{Method \code{add_observations()}}{
Add observations to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations(Spoints, y = NULL, y.index = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{Spoints}}{SpatialPoints or SpatialPointsDataFrame of the observations}

\item{\code{y}}{(n x 1) the value of the observations}

\item{\code{y.index}}{(string, int) position in Spoints where y is located}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-add_observations2"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-add_observations2}{}}}
\subsection{Method \code{add_observations2()}}{
add observations to the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$add_observations2(y, PtE, Spoints = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{y}}{(n x 1) the value of the observations}

\item{\code{PtE}}{(n x 2) edge index, distance on index}

\item{\code{Spoints}}{SpatialPoints or SpatialPointsDataFrame of the observations}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-buildC"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-buildC}{}}}
\subsection{Method \code{buildC()}}{
build Kirchoff constraint matrix from edges, NOT implemented for circles (i.e. self closed edges)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$buildC(alpha, edge_constraint = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{alpha}}{(int) which type of constraint (currently only 2 implemented)}

\item{\code{edge_constraint}}{(bool) if true add constraint on vertices of degree 1.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-build_mesh"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-build_mesh}{}}}
\subsection{Method \code{build_mesh()}}{
build mesh object for plotting
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$build_mesh(h, n = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{h}}{maximum distance between mesh nodes}

\item{\code{n}}{maximum number of nodes per edge}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GPGraph::graph-clone"></a>}}
\if{latex}{\out{\hypertarget{method-GPGraph::graph-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{metric_graph$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
